[{"content":"课程链接：程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\n1.虚函数和多态的基本概念 虚函数 在类的定义中，前面有 virtual 关键字的成员函数就是虚函数。 class base{ virtual int get(); }; int base::get(){} virtual 关键字只用在类定义里的函数声明中，写函数体时不用。 构造函数和静态成员函数不能是虚函数。（关于静态成员函数参考第三章 类和对象提高） 多态的表现形式一 派生类的指针可以赋给基类指针。 通过基类指针调用基类和派生类中的同名虚函数时： 若该指针指向一个基类的对象，那么被调用的是基类的虚函数； 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。 这种机制就叫做“多态”。\nclass CBase{ public: virtual void SomeVirtualFunction(){} }; class CDerived:public CBase{ public: virtual void SomeVirtualFunction(){} }; int main(){ CDerived ODerived; CBase* p=\u0026amp;ODerived; p-\u0026gt;SomeVirtualFunction();//调用哪个虚函数取决于p指向哪种类型的对象 return 0; } 多态的表现形式二 派生类的对象可以赋给基类引用。 通过基类引用来调用基类和派生类中的同名虚函数时： 若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数； 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。 这种机制也叫做“多态”。\nclass CBase{ public: virtual void SomeVirtualFunction(){} }; class CDerived:public CBase{ public: virtual void SomeVirtualFunction(){} }; int main(){ CDerived ODerived; CBase\u0026amp; r=ODerived; r.SomeVirtualFunction();//调用哪个虚函数取决于r引用哪种类型的对象 return 0; } 多态的简单示例 #include \u0026lt;iostream\u0026gt; using namespace std; class A{ public: virtual void Print(){cout \u0026lt;\u0026lt; \u0026#34;A::Print\u0026#34; \u0026lt;\u0026lt; endl;} }; class B:public A{ public: virtual void Print(){cout \u0026lt;\u0026lt; \u0026#34;B::Print\u0026#34; \u0026lt;\u0026lt; endl;} }; class D:public A{ public: virtual void Print(){cout \u0026lt;\u0026lt; \u0026#34;D::Print\u0026#34; \u0026lt;\u0026lt; endl;} }; class E:public B{ public: virtual void Print(){cout \u0026lt;\u0026lt; \u0026#34;E::Print\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ A a;B b;D d;E e; A* pa=\u0026amp;a;B* pb=\u0026amp;b; D* pd=\u0026amp;d;E* pe=\u0026amp;e; pa-\u0026gt;Print(); pa=pb; pa-\u0026gt;Print(); pa=pd; pa-\u0026gt;Print(); pa=pe; pa-\u0026gt;Print(); return 0; } 输出内容为\nA::Print B::Print D::Print E::Print 在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。\n2.多态实例：魔法门之英雄无敌 非多态实现方式 基本思路\n为每个怪物类编写 Attack、FightBack 和 Hurted 成员函数。 Attack 函数表现攻击动作，攻击某个怪物，并调用被攻击怪物的 Hurted 函数，以减少被攻击怪物的生命值，同时也调用被攻击怪物的 FightBack 函数，遭受被攻击怪物反击。 Hurted 函数减少自身生命值，并表现受伤动作。 FightBack 函数表现反击动作，并调用被反击对象的 Hurted 函数，使被反击对象受伤。 设置基类 CCreature，并且使 CDragon、CWolf 等其他类都从 CCreature 派生而来。 class CCreature{ protected: int nPower;//攻击力 int nLifeValue;//生命值 }; class CDragon:public CCreature{ public: void Attack(CWolf* pWolf){ ......//表现攻击动作的代码 pWolf-\u0026gt;Hurted(nPower); pWolf-\u0026gt;FightBack(this); } void Attack(CGhost* pGhost){ ......//表现攻击动作的代码 pGhost-\u0026gt;Hurted(nPower); pGhost-\u0026gt;FightBack(this); } void Hurted(int nPower){ ......//表现受伤动作的代码 nLifeValue-=nPower; } void FightBack(CWolf* pWolf){ ......//表现反击动作的代码 pWolf-\u0026gt;Hurted(nPower/2);//这里只是象征性地对反击的攻击力进行了调整 } void FightBack(CGhost* pWolf){ ......//表现反击动作的代码 pGhost-\u0026gt;Hurted(nPower/2); } }; 有 n 种怪物，CDragon 类中就会有 n 个 Attack 成员函数，以及 n 个 FightBack 成员函数等。对于其他类也是如此。 那么如果游戏版本升级，增加了新的怪物雷鸟 CThunderBird，则程序改动就会较大，不光要新增怪物类，其他所有的类都需要增加两个成员函数 ``` void Attack(CThunderBird* pThunderBird); void FightBack(CThunderBird* pThunderBird); 多态实现方式 基类只有一个 Attack 成员函数，也只有一个 FightBack 成员函数；所有 CCreature 的派生类也是这样。 class CCreature{//基类CCreature protected: int m_nLifeValue,m_nPower; public: virtual void Attack(CCreature* pCreature){} virtual void Hurted(int nPower){} virtual void FightBack(CCreature* pCreature){} }; class CDragon:public CCreature{//派生类CDragon public: virtual void Attack(CCreature* pCreature); virtual void Hurted(int nPower); virtual void FightBack(CCreature* pCreature); }; void CDragon::Attack(CCreature* p){ ......//表现攻击动作的代码 p-\u0026gt;Hurted(m_nPower);//多态 p-\u0026gt;FightBack(this);//多态 } void CDragon::Hurted(int nPower){ ......//表现受伤动作的代码 m_nLifeValue-=nPower; } void CDragon::FightBack(CCreature* p){ ......//表现反击动作的代码 p-\u0026gt;Hurted(m_nPower/2);//多态 } 在多态的写法中，只需要添加新类 CThunderBird，不需要在已有的类里专门为新怪物增加成员函数，已有的类可以原封不动。 原理\nCDragon Dragon;CWolf Wolf; CGhost Ghost;CThunderBird Bird; Dragon.Attack(\u0026amp;Wolf);//(1) Dragon.Attack(\u0026amp;Ghost);//(2) Dragon.Attack(\u0026amp;Bird);//(3) 根据多态的规则，上面的（1）（2）（3）进入到 CDragon::Attack 函数后，能分别调用 CWolf::Hurted、CGhost::Hurted、CBird::Hurted。\n3.多态实例：几何形体处理程序 几何形体处理程序 情景要求\n几何形体处理程序：输入若干个几何形体的参数，要求按面积排序输出，输出时要指明形状。\nInput 第一行是几何形体数目n（不超过100），下面有n行，每行以一个字母开头。 若字母为R，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高； 若字母为C，则代表一个圆，本行后面跟着一个整数代表其半径； 若字母为T，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度。 Output 按面积从小到大依次输出每个几何形体的种类及面积。每行一个几何形体，输出格式为 形体面积:面积 样例\nSample Input 3 R 3 5 C 9 T 3 4 5 Sample Output Triangle:6 Rectangle:15 Circle:254.34 完整代码如下\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; class CShape{ public: virtual double Area()=0;//纯虚数：连函数体都没有的虚函数 virtual void PrintInfo()=0; }; class CRectangle:public CShape{ public: int w,h; virtual double Area(); virtual void PrintInfo(); }; class CCircle:public CShape{ public: int r; virtual double Area(); virtual void PrintInfo(); }; class CTriangle:public CShape{ public: int a,b,c; virtual double Area(); virtual void PrintInfo(); }; double CRectangle::Area(){ return w*h; } void CRectangle::PrintInfo(){ cout \u0026lt;\u0026lt; \u0026#34;Rectangle:\u0026#34; \u0026lt;\u0026lt; Area() \u0026lt;\u0026lt; endl; } double CCircle::Area(){ return 3.14*r*r; } void CCircle::PrintInfo(){ cout \u0026lt;\u0026lt; \u0026#34;Circle:\u0026#34; \u0026lt;\u0026lt; Area() \u0026lt;\u0026lt; endl; } double CTriangle::Area(){ double p=(a+b+c)/2.0; return sqrt(p*(p-a)*(p-b)*(p-c)); } void CTriangle::PrintInfo(){ cout \u0026lt;\u0026lt; \u0026#34;Triangle:\u0026#34; \u0026lt;\u0026lt; Area() \u0026lt;\u0026lt; endl; } CShape* pShapes[100]; int MyCompare(const void* s1,const void* s2){ double a1,a2; CShape**p1;//s1、s2是void*，不可写*s1来获取s1指向的内容 CShape**p2; p1=(CShape**)s1;//s1、s2指向pShapes数组中的元素，数组元素的类型是CShape* p2=(CShape**)s2;//故p1、p2都是指向指针的指针，类型为CShape** a1=(*p1)-\u0026gt;Area();//*p1的类型是CShape*，是基类指针，故此句为多态 a2=(*p2)-\u0026gt;Area(); if(a1\u0026lt;a2) return -1; else if(a2\u0026lt;a1) return 1; else return 0; } int main(){ int i;int n; CRectangle* pr;CCircle* pc;CTriangle* pt; cin \u0026gt;\u0026gt; n; for(i=0;i\u0026lt;n;i++){ char c; cin \u0026gt;\u0026gt; c; switch(c){ case \u0026#39;R\u0026#39;: pr=new CRectangle(); cin \u0026gt;\u0026gt; pr-\u0026gt;w \u0026gt;\u0026gt; pr-\u0026gt;h; pShapes[i]=pr; break; case \u0026#39;C\u0026#39;: pc=new CCircle(); cin \u0026gt;\u0026gt; pc-\u0026gt;r; pShapes[i]=pc; break; case \u0026#39;T\u0026#39;: pt=new CTriangle(); cin \u0026gt;\u0026gt; pt-\u0026gt;a \u0026gt;\u0026gt; pt-\u0026gt;b \u0026gt;\u0026gt; pt-\u0026gt;c; pShapes[i]=pt; break; } } qsort(pShapes,n,sizeof(CShape*),MyCompare); for(i=0;i\u0026lt;n;i++) pShapes[i]-\u0026gt;PrintInfo(); return 0; } 如果添加新的几何形体，比如五边形，则只需要从 CShape 派生出 CPentagon，以及在 main 中的 switch 语句中增加一个 case，其余部分都不变，体现了多态在提高程序可扩充性方面具有良好作用。\n用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组就能对各个派生类对象做各种操作，是很常用的做法。 多态的又一例子 class Base{ public: void fun1(){fun2();}//等价于void fun1(){this-\u0026gt;fun2();} //而this是基类指针，fun2是虚函数，所以是多态 virtual void fun2(){cout \u0026lt;\u0026lt; \u0026#34;Base::fun2()\u0026#34; \u0026lt;\u0026lt; endl;} }; class Derived:public Base{ public: virtual void fun2(){cout \u0026lt;\u0026lt; \u0026#34;Derived:fun2()\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ Derived d; Base* pBase=\u0026amp;d; pBase-\u0026gt;fun1(); return 0; }//输出：Derived:fun2() 在非构造函数，非析构函数的成员函数中调用虚函数，是多态！！！ 在构造函数和析构函数中调用虚函数，不是多态。 编译时即可确定调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。 构造函数和析构函数中调用虚函数举例 #include \u0026lt;iostream\u0026gt; using namespace std; class myclass{ public: virtual void hello(){cout \u0026lt;\u0026lt; \u0026#34;hello from myclass\u0026#34; \u0026lt;\u0026lt; endl;} virtual void bye(){cout \u0026lt;\u0026lt; \u0026#34;bye from myclass\u0026#34; \u0026lt;\u0026lt; endl;} }; class son:public myclass{ public: void hello(){cout \u0026lt;\u0026lt; \u0026#34;hello from son\u0026#34; \u0026lt;\u0026lt; endl;} son(){hello();} ~son(){bye();} };//派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数 class grandson:public son{ public: void hello(){cout \u0026lt;\u0026lt; \u0026#34;hello from grandson\u0026#34; \u0026lt;\u0026lt; endl;} void bye(){cout \u0026lt;\u0026lt; \u0026#34;bye from grandson\u0026#34; \u0026lt;\u0026lt; endl;} grandson(){cout \u0026lt;\u0026lt; \u0026#34;constructing grandson\u0026#34; \u0026lt;\u0026lt; endl;} ~grandson(){cout \u0026lt;\u0026lt; \u0026#34;destructing grandson\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ grandson gson; son* pson; pson=\u0026amp;gson; pson-\u0026gt;hello();//多态 return 0; } 输出内容为\nhello from son constructing grandson hello from grandson destructing grandson bye from myclass 4.多态的实现原理 问题引入 “多态”的关键在于通过基类指针或引用调用一个虚函数时，编译不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫做 “动态联编”。这是如何实现的呢？\n#include \u0026lt;iostream\u0026gt; using namespace std; class Base{ public: int i; virtual void Print(){cout \u0026lt;\u0026lt; \u0026#34;Base:Print\u0026#34;;} }; class Derived:public Base{ public: int n; virtual void Print(){cout \u0026lt;\u0026lt; \u0026#34;Derived:Print\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ Derived d; cout \u0026lt;\u0026lt; sizeof(Base) \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; sizeof(Derived); return 0; } 此处的输出内容，在视频中老师的讲解下，理论输出为 4,8，实际输出为 8,12。\n但事实上在 DEV C++ 5.11 中程序运行得到的结果为 16,16 。该程序的输出取决于编译器的实现和系统位数（32 位或 64 位），但根据常见 64 位系统的行为分析：\n​基类 Base 的大小​：\n虚函数表指针（vptr）：8字节（64 位系统指针大小） 成员变量 int i：4字节 内存对齐填充：4字节（为了对齐到 8 字节边界） ​总计​：8 + 4 + 4 = 16字节 ​派生类 Derived 的大小​：\n继承自 Base 的虚函数表指针（vptr）：8字节 继承自 Base 的成员变量 int i：4字节 新增成员变量 int n：4字节 ​总计​：8 + 4 + 4 = 16字节（无需额外填充，总大小已是 8 的倍数） ​其他可能性​：\n​32 位系统​：输出 8,12（vptr 占 4 字节，int 占 4 字节，派生类添加的 int 导致总大小 12）。 ​编译器优化​：某些编译器可能减少填充，但主流通用编译器（如 GCC、Clang、MSVC）在 64 位模式下通常结果为 16,16。 ​总结​：在标准 64 位环境下，程序输出为 16,16。\n多态实现的关键——虚函数表 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都存放了虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的 4 个字节就是用来放虚函数表的地址的。\n多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。\n也正因如此，含有多态的程序在执行的过程中会有额外的时间和空间上的开销。(存表和查表的开销)\n虚函数表地址验证 #include \u0026lt;iostream\u0026gt; using namespace std; class A{ public: virtual void Func(){ cout \u0026lt;\u0026lt; \u0026#34;A::Func\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A{ public: virtual void Func(){ cout \u0026lt;\u0026lt; \u0026#34;B::Func\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(){ A a; A* pa=new B(); pa-\u0026gt;Func();//64位程序指针为8字节，输出B::Func long long* p1=(long long*)\u0026amp;a; long long* p2=(long long*)pa; *p2=*p1; pa-\u0026gt;Func();//输出A::Func return 0; } 这段代码很好地演示了 C++ 虚函数表的底层实现机制，我们可以分几个层次来理解：\n​类结构分析​\n基类 A 定义了一个虚函数 Func()，输出 \u0026ldquo;A::Func\u0026rdquo; 派生类 B 重写了 Func()，输出 \u0026ldquo;B::Func\u0026rdquo; B 继承自 A，形成继承体系 ​虚函数表原理​\n编译器会为每个包含虚函数的类生成虚函数表（vtable） 每个对象实例化时会包含一个隐藏的虚表指针（vptr），指向对应的虚表 A 的虚表存放 A::Func 的地址，B 的虚表存放 B::Func 的地址 ​内存操作解析​\nlong long* p1 = (long long*)\u0026amp;a; // 获取A实例的虚表指针 long long* p2 = (long long*)pa; // 获取B实例的虚表指针 *p2 = *p1; // 用A的虚表覆盖B的虚表 这里利用了 64 位系统中指针占 8 字节的特性（long long 也是 8 字节） 通过直接操作内存，修改了 B 实例的虚表指针，使其指向 A 的虚表 运行结果解释​\n第一次调用 pa-\u0026gt;Func()：正常输出 B::Func，符合多态特性 修改虚表指针后：pa 实际指向的对象虽然还是 B 类型，但虚表已被替换为 A 的，故输出 A::Func 重要概念验证​\n虚函数调用是通过查虚表实现的动态绑定，而非通过对象本身的类型 虚表指针存在于对象实例的内存起始位置 多态的实现依赖于虚表机制，而不是简单的类型继承 注意事项​\n这种直接操作内存的方式在实际开发中非常危险，会破坏面向对象特性 不同编译器实现可能有差异，此处演示的是典型实现方式 32 位系统需要将 long long 改为 long（4 字节） 这个例子深刻揭示了 C++ 多态性的底层实现，帮助我们理解：虚函数调用实际上是通过虚表指针间接跳转的，当修改了虚表指针后，即使对象类型未变，虚函数的行为也会改变。这是实现运行时多态的关键机制。\n5.虚析构函数、纯虚函数和抽象类 虚析构函数 通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数。\n但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。 解决办法：把基类的析构函数声明为 virtual。\n派生类的析构函数可以 virtual 不进行声明。 通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。 一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。\n注意：不允许以虚函数作为构造函数。\n#include \u0026lt;iostream\u0026gt; using namespace std; class son{ public: ~son(){cout \u0026lt;\u0026lt; \u0026#34;bye from son\u0026#34; \u0026lt;\u0026lt; endl;} }; class grandson:public son{ public: ~grandson(){cout \u0026lt;\u0026lt; \u0026#34;bye from grandson\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ son* pson; pson=new grandson(); delete pson; return 0; }//输出：bye from son，没有执行grandson::~grandson() 如果将基类的析构函数声明为 virtual\nclass son{ public: virtual ~son(){cout \u0026lt;\u0026lt; \u0026#34;bye from son\u0026#34; \u0026lt;\u0026lt; endl;} }; class grandson:public son{ public: ~grandson(){cout \u0026lt;\u0026lt; \u0026#34;bye from grandson\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ son* pson; pson=new grandson(); delete pson; return 0; } 则会输出\nbye from grandson bye from son 执行 grandson::~grandson()，引起执行 son::~son()。\n纯虚函数和抽象类 纯虚函数：没有函数体的虚函数 class A{ private: int a; public: virtual void Print()=0;//纯虚函数，如果不是=0而是{}，也认为是有函数体 }; 包含纯虚函数的类叫抽象类 抽象类只能作为基类来派生新类使用，不能创建抽象类的对象 抽象类的指针和引用可以指向由抽象类派生出来的类的对象 A a;//错，A是抽象类，不能创建对象 A* pa;//ok，可以定义抽象类的指针和引用 pa=new A;//错误，A是抽象类，不能创建对象 在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中所有纯虚函数，它才能成为非抽象类。（也就是说基类中的所有纯虚函数在派生类中都有了函数体） #include \u0026lt;iostream\u0026gt; using namespace std; class A{ public: virtual void f()=0;//纯虚函数 void g(){this-\u0026gt;f();}//ok //A(){f();}//编译错误，构造函数中不是多态 }; class B:public A{ public: void f(){cout \u0026lt;\u0026lt; \u0026#34;B:f()\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ B b; b.g();//输出B:f() return 0; } ","permalink":"http://localhost:1313/posts/c++6/","summary":"\u003cp\u003e课程链接：\u003ca href=\"https://www.icourse163.org/course/PKU-1002029030\"\u003e程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"1虚函数和多态的基本概念\"\u003e1.虚函数和多态的基本概念\u003c/h2\u003e\n\u003ch3 id=\"虚函数\"\u003e虚函数\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e在类的定义中，前面有 \u003ccode\u003evirtual\u003c/code\u003e 关键字的成员函数就是虚函数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003ebase\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003evirtual\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebase\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e(){}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003evirtual\u003c/code\u003e 关键字只用在类定义里的函数声明中，写函数体时不用。\u003c/li\u003e\n\u003cli\u003e构造函数和静态成员函数不能是虚函数。（关于静态成员函数参考第三章 类和对象提高）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"多态的表现形式一\"\u003e多态的表现形式一\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e派生类的指针可以赋给基类指针。\u003c/li\u003e\n\u003cli\u003e通过基类指针调用基类和派生类中的同名\u003cstrong\u003e虚函数\u003c/strong\u003e时：\n\u003cul\u003e\n\u003cli\u003e若该指针指向一个基类的对象，那么被调用的是基类的虚函数；\u003c/li\u003e\n\u003cli\u003e若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这种机制就叫做“\u003cstrong\u003e多态\u003c/strong\u003e”。\u003c/p\u003e","title":"面向对象的程序设计学习笔记 6"},{"content":"课程链接：程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\n1.继承和派生的基本概念 继承和派生的概念 继承： 在定义一个新的类 B 时，如果该类与某个已有的类 A 相似（指的是 B 拥有 A 的全部特点），那么就可以把 A 作为一个基类，而把 B 作为基类的一个派生类（也称子类）。 派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。 派生类一经定义后，可以独立使用，不依赖于基类。 派生类拥有基类的全部成员函数和成员变量，不论是 private、protected、public。 在派生类的各个成员函数中，不能访问基类中的 private 成员。 派生类的写法 class 派生类名:public 基类名 { ...... }; 举例如下\nclass CStudent{ private: string sName; int nAge; public: bool IsThreeGood(){}; void SetName(const string\u0026amp; name){sName=name;} //...... }; class CUndergraduateStudent:public CStudent{ private: int nDepartment; public: bool IsThreeGood(){...};//覆盖 bool CanBaoYan(){...}; };//派生类写法-类名:public 基类名 class CGraduatedStudent:public CStudent{ private: int nDepartment; char szMentorName[20]; public: int CountSalary(){...}; }; 派生类对象的内存空间 派生类对象的体积，等于基类对象的体积再加上派生类对象自己的成员变量的体积。在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。\nclass CBase{ int v1,v2; }; class CDerived:public CBase{ int v3; }; //CDerived对象：v1,v2,v3;CBase对象：v1,v2 继承实例程序：学籍管理 在原视频中展示的代码，缺少了对基类 CStudent 中 PrintInfo 和 SetInfo 的实现代码，此处进行了补齐。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class CStudent{ private: string name; string id;//学号 char gender;//性别，F代表女，M代表男 int age; public: void PrintInfo() { cout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;ID:\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Age:\u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Gender:\u0026#34; \u0026lt;\u0026lt; gender \u0026lt;\u0026lt; endl; } void SetInfo(const string\u0026amp; name_, const string\u0026amp; id_, int age_, char gender_) { name = name_; id = id_; age = age_; gender = gender_; } string GetName(){return name;} }; class CUndergraduateStudent:public CStudent{//本科生类，继承了CStudent类 private: string department;//学生所属系的名称 public: void QualifiedForBaoyan(){//给予保研资格 cout \u0026lt;\u0026lt; \u0026#34;qualified for baoyan\u0026#34; \u0026lt;\u0026lt; endl; } void PrintInfo(){ CStudent::PrintInfo();//调用基类的PrintInfo cout \u0026lt;\u0026lt; \u0026#34;Department:\u0026#34; \u0026lt;\u0026lt; department \u0026lt;\u0026lt; endl; } void SetInfo(const string\u0026amp; name_,const string\u0026amp; id_, int age_,char gender_,const string\u0026amp; department_){ CStudent::SetInfo(name_,id_,age_,gender_);//调用基类的SetInfo department=department_; } }; int main(){ CUndergraduateStudent s2; s2.SetInfo(\u0026#34;Harry Potter\u0026#34;,\u0026#34;118829212\u0026#34;,19,\u0026#39;M\u0026#39;,\u0026#34;Computer Science\u0026#34;); cout \u0026lt;\u0026lt; s2.GetName() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; s2.QualifiedForBaoyan(); s2.PrintInfo(); return 0; } 输出结果\nHarry Potter qualified for baoyan Name:Harry Potter ID:118829212 Age:19 Gender:M Department:Computer Science 2.继承关系和复合关系 类的两种关系 继承：“是”关系。 对于基类 A，B 是基类 A 的派生类。 逻辑上要求：“一个 B 对象也是一个 A 对象”。 复合：“有”关系。 类 C 中有成员变量 k，k 是类 D 的对象，则 C 和 D 是复合关系。 一般逻辑上要求：“D 对象是 C 对象的固有属性或组成部分”。 继承关系的使用 考虑以下情景：\n当我们写了一个 CMan 类来代表男人，后来发现还需要一个 CWoman 类来代表女人，CWoman 类和 CMan 类有共同之处，所以我们就让 CWoman 类从 CWoman 类从 CMan 类派生而来，是否合适？\n这显然是不合理的！因为“一个女人也是一个男人”从逻辑上不成立！\n好的做法是概括男人和女人的共同特点，写一个 CHuman 类，代表“人”，然后 CMan 和 CWoman 都从 CHuman 派生。\n复合关系的使用 几何体程序中，需要写“点”类，也需要写“圆”类，两者的关系就是复合关系——每一个“圆”对象里都包含（有）一个“点”对象，也就是圆心。 class CPoint{ double x,y; friend class CCircle;//便于CCircle类操作其圆心 }; class CCircle{ double r; CPoint center; }; 再考虑以下情景：\n如果要写一个小区养狗管理程序，需要写一个“业主”类，还需要写一个“狗”类。 而狗是有“主人”的，主人也就是业主（假定狗只有一个主人，但一个业主可以最多拥有 10 条狗） class CDog; classCMaster{ CDog dogs[10]; }; class CDog{ CMaster m; }; 上面这种写法是完完全全的错误（用视频中老师的说法就是你的 C++ 是保安教的吗 hhhh），在编译的时候就无法通过，因为它进行了循环定义，也就是“人中有狗，狗中有人”。可以注意到，上述写法中，一个 CMaster 的体积，是 10 倍的 CDog，而一个 CDog 的体积，又等同于一个 CMaster。\n另一种写法:\n为“狗”类设一个“业主”类的成员对象； 为“业主”类设一个“狗”类的对象指针数组。 class CDog; class CMaster{ CDog* dogs[10]; }; class CDog{ CMaster m; }; 这种写法实际上也是错误的，因为这样定义类实际上还是导致“狗中有人”的局面，那么在维护相同主人的多条狗里面包含的多个主人对象的信息一致性上会非常繁琐。\n一种凑合的写法：\n为“狗”类设一个“业主”类的对象指针； 为“业主”类设一个“狗”类的对象数组。 class CMaster;//CMaster必须提前声明，不能先写CMaster类后写CDog类 class CDog{ CMaster* pm; }; class CMaster{ CDog dogs[10]; }; 这样的写法实际上是导致“人中有狗”，而每一条狗拥有一个指向主人的指针。并且这种写法会造成如果要对狗对象进行操作，都需要通过它的主人来进行，因为每一个狗对象都被包含在主人对象中。\n正确的写法：\n为“狗”类设一个“业主”类的对象指针； 为“业主”类设一个“狗”类的对象指针数组。 class CMaster;//CMaster必须提前声明，不能先写CMaster类后写CDog类 class CDog{ CMaster* pm; }; class CMaster{ CDog* dogs[10]; }; 3.覆盖和保护成员 覆盖 派生类可以定义一个和基类成员同名的成员，这叫覆盖。在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号 ::。\nclass base{ int j; public: int i; void func(); }; class derived:public base{ public: int i;//这里只是为了说明，实际上一般不会在基类和派生类中写同名变量 void access(); void func();//但写同名函数是很常见的 }; void derived::access(){ j=5;//error，这是基类的私有成员 i=5;//引用的是派生类的i base::i=5;//引用的是基类的i func();//派生类 base::func();//基类 } derived obj; obj.i=1; obj.base::i=1; 一般来说，基类和派生类不定义同名成员变量。\n类的保护成员 存取权限说明符：protected\n基类的 private 成员可以被下列函数访问 基类的成员函数 基类的友元函数 基类的 public 成员可以被下列函数访问 基类的成员函数 基类的友元函数 派生类的成员函数 派生类的友元函数 其他函数 基类的 protected 成员可以被下列函数访问 基类的成员函数 基类的友元函数 派生类的成员函数可以访问当前对象（也就是派生类成员函数当前作用的对象）的基类的保护成员 class Father{ private: int nPrivate;//私有成员 public: int nPublic;//共有成员 protected: int nProtected;//保护成员 }; class Son:public Father{ void AccessFather(){ nPublic=1;//ok nPrivate=1;//wrong nProtected=1;//ok，访问从基类继承的protected成员 Son f; f.nProtected=1;//ok } }; int main(){ Father f; Son s; f.nPublic=1;//ok s.nPublic=1;//ok f.nProtected=1;//error f.nPrivate=1;//error s.nProtected=1;//error s.nPrivate=1;//error return 0; } 一点补充：针对 protected 的详细解释 为什么在上述代码中，派生类的成员函数 AccessFather 中 f.nProtected=1 是可以的，但是主函数 main 中 f.nProtected=1 和 s.nProtected=1 都不行？\n​1.派生类成员函数中的 f.nProtected = 1 为什么合法？​​\n​上下文​：Son::AccessFather() 是派生类 Son 的成员函数。 ​规则​：\n在派生类的成员函数中，​可以通过「派生类对象」访问其直接基类的 protected 成员​（无论该对象是否是当前 this 对象）。 ​代码分析​： Son f; // 创建一个 Son 对象 f f.nProtected = 1; // ✔️ 合法：通过 Son 对象访问 Father 的 protected 成员 这里的 f 是 Son 类型的对象，AccessFather() 作为 Son 的成员函数，允许通过任何 Son 对象访问其基类 Father 的 protected 成员。\n2.主函数中的 f.nProtected = 1 和 s.nProtected = 1 为什么非法？​​\n​上下文​：main() 是外部函数，不属于 Father 或 Son 的成员函数或友元。 ​规则​：protected 成员只能被以下角色访问： 基类自身的成员函数和友元 派生类的成员函数（通过「派生类对象」或「当前 this 对象」） 派生类的友元（通过派生类对象） ​代码分析​： Father f; // 基类对象 f.nProtected = 1; // ❌ 非法：外部函数无法访问基类的 protected 成员 Son s; // 派生类对象 s.nProtected = 1; // ❌ 非法：外部函数无法通过派生类对象间接访问基类的 protected 成员 尽管 s 是 Son 对象，但 main() 作为外部函数，无法直接访问任何类的 protected 成员。\n3.关键区别总结​\n​场景​ ​是否合法​ ​原因​ Son::AccessFather() 中的 f.nProtected ✔️ 合法 派生类成员函数可以通过「派生类对象」访问基类的 protected 成员 main() 中的 f.nProtected ❌ 非法 外部函数无法访问基类的 protected 成员 main() 中的 s.nProtected ❌ 非法 外部函数无法通过派生类对象间接访问基类的 protected 成员（即使该对象属于派生类） 4.进一步验证​\n如果尝试在 Son::AccessFather() 中通过 ​基类对象​ 访问 protected 成员，也会失败：\nvoid Son::AccessFather() { Father base; // 创建一个基类对象 base.nProtected = 1; // ❌ 非法：派生类无法通过基类对象访问 protected 成员 } 因为此处 base 是基类对象，而非派生类对象。\n​5.语言设计逻辑​\nprotected 的访问规则旨在实现以下目标：\n允许派生类扩展基类的功能​：派生类可以访问基类的 protected 成员，用于实现继承相关的逻辑。 保持封装性​：外部代码（包括派生类的用户）无法直接访问 protected 成员，避免破坏基类的内部状态。 通过这种设计，C++ 在「代码复用」和「封装性」之间取得了平衡。\n4.派生类的构造函数 class Bug{ private: int nLegs; int nColor; public: int nType; Bug(int legs,int color); void PrintBug(){}; }; class FlyBug:public Bug{ int nWings; Public: FlyBug(int legs,int color,int wings); }; Bug::Bug(int legs,int color){ nLegs=legs; nColor=color; } //错误的FlyBug构造函数 FlyBug::FlyBug(int legs,int color,int wings){ nLegs=legs;//error nColor=color;//error nType=1;//ok nWings=wings;//ok } //正确的FlyBug构造函数 FlyBug::FlyBug(int legs,int color,int wings):Bug(legs,color){ //直接在初始化列表里面对基类的私有成员进行初始化 nWings=wings;//这里也可以同样在初始化列表中进行初始化 } int main(){ FlyBug fb(2,3,4); fb.PrintBug(); fb.nType=1; fb.nLegs=2;//error，nLegs是私有成员 return 0; } 在创建派生类的对象时，需要调用基类的构造函数来初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。 调用基类构造函数的两种方式 显示方式：在派生类的构造函数中，为基类的构造函数提供参数 。derived::derived(arg_derived-list):base(arg_base-list) 隐式方式：在派生类的构造函数中，省略基类构造函数，派生类的构造函数则自动调用基类的默认构造函数。 派生类的析构函数被执行时，执行完派生类的析构函数后，会自动调用基类的析构函数。 #include \u0026lt;iostream\u0026gt; using namespace std; class Base{ public: int n; Base(int i):n(i){cout \u0026lt;\u0026lt; \u0026#34;Base \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; constructed\u0026#34; \u0026lt;\u0026lt; endl;} ~Base(){cout \u0026lt;\u0026lt; \u0026#34;Base \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; destructed\u0026#34; \u0026lt;\u0026lt; endl;} }; class Derived:public Base{ public: Derived(int i):Base(i){cout \u0026lt;\u0026lt; \u0026#34;Derived constructed\u0026#34; \u0026lt;\u0026lt; endl;} ~Derived(){cout \u0026lt;\u0026lt; \u0026#34;Derived destructed\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ Derived Obj(3); return 0; } 输出内容为\nBase 3 constructed Derived constructed Derived destructed Base 3 destructed 封闭派生类对象的构造函数执行顺序\n先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员； 在执行成员对象类的构造函数，用以初始化派生类对象中的成员对象； 最后执行派生类自己的构造函数。 封闭派生类对象的析构函数执行顺序\n先执行派生类自己的析构函数； 再依次执行各成员对象类的析构函数； 最后执行基类的析构函数。 析构函数的调用顺序与构造函数的调用顺序相反。\n5.public 继承的赋值兼容规则 公有继承的赋值兼容规则 class base{}; class derived:public base{};//实际上还可以写protected、private //当写public时称为公有继承 base b; derived d; 派生类对象可以赋值给基类对象 b=d;(反过来写 d=b; 是不行的)； 派生类对象可以初始化基类引用 `base\u0026amp; br=d; 派生类对象的地址可以赋值给基类指针 base* pb=\u0026amp;d; 需要注意的是，如果派生方式是 private 或 protected，则上述三条不可行。\n直接基类与间接基类 假定有类 A 派生类 B，类 B 派生类 C，类 C 派生类 D，……\n类 A 是类 B 的直接基类 类 B 是类 C 的直接基类，类 A 是类 C 的间接基类 类 C 是类 D 的直接基类，类 A、B 是类 D 的间接基类 在声明派生类时，只需要列出它的直接基类\n派生类沿着类的层次自动向上继承它的间接基类 派生类的成员包括 派生类自己定义的成员 直接基类中的所有成员 所有间接基类的全部成员 下面是一个多层派生的例子\n#include \u0026lt;iostream\u0026gt; using namespace std; class Base{ public: int n; Base(int i):n(i){cout \u0026lt;\u0026lt; \u0026#34;Base \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; constructed\u0026#34; \u0026lt;\u0026lt; endl;} ~Base(){cout \u0026lt;\u0026lt; \u0026#34;Base \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; destructed\u0026#34; \u0026lt;\u0026lt; endl;} }; class Derived:public Base{ public: Derived(int i):Base(i){cout \u0026lt;\u0026lt; \u0026#34;Derived constructed\u0026#34; \u0026lt;\u0026lt; endl;} ~Derived(){cout \u0026lt;\u0026lt; \u0026#34;Derived destructed\u0026#34; \u0026lt;\u0026lt; endl;} }; class MoreDerived:public Derived{ public: MoreDerived():Derived(4){cout \u0026lt;\u0026lt; \u0026#34;MoreDerived constructed\u0026#34; \u0026lt;\u0026lt; endl;} ~MoreDerived(){cout \u0026lt;\u0026lt; \u0026#34;MoreDerived destructed\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ MoreDerived Obj; return 0; } 输出内容为\nBase 4 constructed Derived constructed MoreDerived constructed MoreDerived destructed Derived destructed Base 4 destructed ","permalink":"http://localhost:1313/posts/c++5/","summary":"\u003cp\u003e课程链接：\u003ca href=\"https://www.icourse163.org/course/PKU-1002029030\"\u003e程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"1继承和派生的基本概念\"\u003e1.继承和派生的基本概念\u003c/h2\u003e\n\u003ch3 id=\"继承和派生的概念\"\u003e继承和派生的概念\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承：\u003c/strong\u003e 在定义一个新的类 B 时，如果该类与某个已有的类 A 相似（\u003cstrong\u003e指的是 B 拥有 A 的全部特点\u003c/strong\u003e），那么就可以把 A 作为一个\u003cstrong\u003e基类\u003c/strong\u003e，而把 B 作为基类的一个\u003cstrong\u003e派生类（也称子类）\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。\u003c/li\u003e\n\u003cli\u003e派生类一经定义后，可以独立使用，不依赖于基类。\u003c/li\u003e\n\u003cli\u003e派生类拥有基类的全部成员函数和成员变量，不论是 private、protected、public。\n\u003cul\u003e\n\u003cli\u003e在派生类的各个成员函数中，不能访问基类中的 private 成员。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"派生类的写法\"\u003e派生类的写法\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"err\"\u003e派生类名:\u003c/span\u003e\u003cspan class=\"nc\"\u003epublic\u003c/span\u003e \u003cspan class=\"err\"\u003e基类名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e......\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e举例如下\u003c/p\u003e","title":"面向对象的程序设计学习笔记 5"},{"content":"课程链接：程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\n1.运算符重载的基本概念 运算符重载的需求 在数学上，两个复数可以直接进行 +、- 等运算。但是在 C++ 中，直接将 + 或 - 用于复数对象是不允许的。\n但有时我们会希望，让对象也能够通过运算符进行计算。这样代码更简洁也更容易理解。\n例如：complex_a 和 complex_b 是两个复数对象，那求这两个复数的和，我们希望能直接写 complex_a + complex_b\n运算符重载，就是对已有的运算符（C++ 中预定义的运算符）赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为。\n运算符重载的目的是：扩展 C++ 中提供的运算符的适用范围，使之能作用于对象。 同一个运算符，对不同类型的操作数，所发生的行为不同。 运算符重载的形式 运算符重载的实质是函数重载 可以重载为普通函数，也可以重载为成员函数 把含运算符的表达式转换成运算符函数的调用 把运算符的操作数转换成运算符函数的参数 运算符被多次重载时，根据实参的类型决定调用哪个运算符参数 返回值类型 operator 运算符(形参表) { …… } 运算符重载示例 #include \u0026lt;iostream\u0026gt; using namespace std; class Complex{ public: double real,imag; Complex(double r=0.0,double i=0.0):real(r),imag(i){} Complex operator-(const Complex\u0026amp; c); }; Complex operator+(const Complex\u0026amp; a,const Complex\u0026amp; b){ return Complex(a.real+b.real,a.imag+b.imag);//返回一个临时对象 } Complex Complex::operator-(const Complex\u0026amp; c){ return Complex(real-c.real,imag-c.imag);//返回一个临时对象 } int main(){ Complex a(4,4),b(1,1),c; c=a+b;//等价于c=operator+(a,b); cout \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; c.imag \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (a-b).real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; (a-b).imag \u0026lt;\u0026lt; endl; //a-b等价于a.operator-(b); return 0; } 重载为成员函数时，参数个数为运算符目数减一 重载为普通函数时，参数个数为运算符目数 上述示例输出为\n5,5 3,3 2.赋值运算符的重载 有时候希望赋值运算符两边的类型可以不匹配，比如，把一个 int 类型变量赋值给一个 Complex 对象，或把一个 char* 类型的字符串赋值给一个字符串对象，此时就需要重载赋值运算符 =。\n赋值运算符 = 只能重载为成员函数。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; class String{ private: char* str; public: String():str(new char[1]){str[0]=0;} const char* c_str(){return str;}; String\u0026amp; operator=(const char* s); ~String(){delete []str;} }; String\u0026amp; String::operator=(const char* s){ //重载\u0026#34;=\u0026#34;以使得obj=\u0026#34;hello\u0026#34;能够成立 delete []str; str=new char [strlen(s)+1]; strcpy(str,s); return* this; } int main(){ String s; s=\u0026#34;Good Luck,\u0026#34;;//等价于s.operator=(\u0026#34;Good Luck\u0026#34;); cout \u0026lt;\u0026lt; s.c_str() \u0026lt;\u0026lt; endl; //String s2=\u0026#34;hello\u0026#34;; //上面这条语句要是不注释就会报错 s=\u0026#34;Shenzhou 8!\u0026#34;;//等价于s.operator=(\u0026#34;Shenzhou 8!\u0026#34;); cout \u0026lt;\u0026lt; s.c_str() \u0026lt;\u0026lt; endl; return 0; } 浅拷贝和深拷贝 这里仍然使用上述示例进行演示\nclass String{ private: char* str; public: String():str(new char[1]){str[0]=0;} const char* c_str(){return str;}; String\u0026amp; operator=(const char* s){ delete []str; str=new char [strlen(s)+1]; strcpy(str,s); return* this; }; ~String(){delete []str;} }; 在按照上述方法定义类之后，进行如下操作\nString S1,S2; S1=\u0026#34;this\u0026#34;;//ok S2=\u0026#34;that\u0026#34;;//ok S1=S2;//这是有严重问题的 如不定义自己的赋值运算符，那么 S1=S2 实际上会导致 S1.str 和 S2.str 指向同一地方。 如果 S1 对象消亡，析构函数将会释放 S1.str 指向的空间，则 S2 消亡时还要释放一次，不妥。 另外，如果执行 S1=\u0026quot;other\u0026quot;;，会导致 S2.str 指向的地方被 delete。 因此要在 class String 里添加成员函数 String\u0026amp; operator=(const String\u0026amp; s){ if(this==\u0026amp;s) return* this; delete []str; str=new char[strlen(s.str)+1]; strcpy(str,s.str); return* this; } 一点补充：关于 C++ 中赋值运算符 = 的行为 基本数据类型（如 int, double, char）\n当对基本数据类型使用 = 时，赋值操作会直接将右侧变量的值复制给左侧变量。例如： int a = 10; int b = 20; a = b; // 将 b 的值（20）复制到 a 中 此时，a 和 b 是两个完全独立的变量。修改 a 的值不会影响 b，反之亦然。\n关键点：这里没有指针或内存共享，只是简单的值拷贝。\n对象（类或结构体实例）\n如果赋值的是对象（例如自定义的类或结构体），默认行为是逐个复制对象的成员变量。这种行为称为“浅拷贝”。例如： class Student { public: int age; std::string name; }; Student s1{20, \u0026#34;Alice\u0026#34;}; Student s2; s2 = s1; // 复制 s1 的 age 和 name 到 s2 此时，s2.age 和 s2.name 的值与 s1 完全相同。但如果类中包含指针成员，浅拷贝会导致问题：\nclass ShallowCopyExample { public: int* data; // 假设 data 指向堆内存 }; ShallowCopyExample obj1; obj1.data = new int(100); ShallowCopyExample obj2; obj2 = obj1; // 浅拷贝：obj2.data 和 obj1.data 指向同一块内存 此时，修改 *obj1.data 会影响 *obj2.data，因为它们共享同一内存。如果释放其中一个对象的 data，另一个对象的指针将指向无效内存（悬空指针）。\n关键点：对象默认赋值是浅拷贝，需手动实现深拷贝来复制指针指向的内容。\n指针类型\n指针变量存储的是内存地址。使用 = 赋值指针时，只会复制地址值，不会复制指针指向的内容。例如： int* a = new int(100); int* b = new int(200); a = b; // a 现在指向 b 的地址（即 200 所在的内存） 赋值后，a 和 b 指向同一块内存。修改 *a 会影响 *b，因为它们操作的是同一地址。此外，原 a 指向的内存（值为 100）会因未释放而导致内存泄漏。\n关键点：指针赋值是地址的复制，不涉及内容拷贝；操作同一内存需谨慎。\nSTL 容器（如 std::string, std::vector）\nSTL 容器（如字符串、动态数组）的 = 运算符已经被设计为执行“深拷贝”。例如： std::vector\u0026lt;int\u0026gt; v1{1, 2, 3}; std::vector\u0026lt;int\u0026gt; v2; v2 = v1; // 深拷贝：v2 复制了 v1 的所有元素到独立内存中 此时，修改 v1[0] = 100 不会影响 v2[0]，因为两者存储在不同的内存区域。\n关键点：STL 容器默认支持深拷贝，赋值后内容完全独立。\n赋值与指针指向的内容\n当被赋值的变量是指针时，a = b 仅让 a 指向 b 的地址，而不是复制 b 指向的内容。若需要复制内容，必须显式操作： int* b = new int(200); int* a = new int(*b); // 显式复制 b 指向的内容到新内存 此时，a 和 b 指向不同的内存，但内容相同。\n关键点：指针赋值不复制内容，需手动分配新内存并复制。\n总结\n• 基本类型：直接复制值。\n• 对象：默认浅拷贝（复制成员变量，共享指针成员的内存）。\n• 指针：复制地址，共享同一内存。\n• STL 容器：深拷贝，内容完全独立。\n核心原则：= 是否复制内容取决于操作数的类型。指针和对象可能共享内存，而基本类型和 STL 容器默认不共享。\n注意 对运算符进行重载的时候，好的风格是应该尽量保留运算符原本的特性。\n为 String 类编写复制构造函数的时候会面临和 = 同样的问题，用同样的方法处理。\nString(String\u0026amp; s){ //这里不用判断是否和原对象一致 //因为对象是刚刚复制出来的不可能是同一个 str=new char[strlen(s.str)+1]; strcpy(str,s.str); } 3.运算符重载为友元函数 一般情况下，将运算符重载为类的成员函数是较好的选择。 但有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。 举例如下\nclass Complex{ double real,imag; public: Complex(double r,double i):real(r),imag(i){}; Complex operator+(double r); }; Complex Complex::operator+(double r){//能解释c+5 return Complex(real+r,imag); } 经过上述重载\nComplex c; c=c+5;//有定义，相当于c=c.operator+5; 但是\nc=5+c;//编译出错 所以，为了使上述的表达式能成立，需要将 + 重载为普通函数。\nComplex operator+(double r,const Complex\u0026amp; c){//能解释5+c return Complex(c.real+r,c.imag); } 但是普通函数又不能访问私有成员，所以，需要将运算符 + 重载为友元。\nclass Complex{ double real,imag; public: Complex(double r,double i):real(r),imag(i){}; Complex operator+(double r); friend Complex operator+(double r,const Complex\u0026amp; c); }; 4.运算符重载实例：可变长整型数组 为了实现上述图片中描述的功能，创建如下的类\nclass CArray{ int size;//数组元素的个数 int* ptr;//指向动态分配的数组 public: CArray(int s=0);//s代表数组元素的个数 CArray(CArray\u0026amp; a); ~CArray(); void push_back(int v);//用于在数组尾部添加一个元素v CArray\u0026amp; operator=(const CArray\u0026amp; a);//用于数组对象间的赋值 int length(){return size;}//返回数组元素个数 int\u0026amp; CArray::operator[](int i){ //返回值为int不行！不支持a[i]=4 //因为非引用的函数返回值不可以作为左值使用 //这里的重载用以支持根据下标访问数组元素，如n=a[i];和a[i]=4;这样的语句 return ptr[i]; } }; 构造函数与复制构造函数如下\nCArray::CArray(int s):size(s){ if(s==0) ptr=NULL; else ptr=new int[s]; } CArray::CArray(CArray\u0026amp; a){ if(!a.ptr){ ptr=NULL; size=0; return; } ptr=new int[a.size]; memcpy(ptr,a.ptr,sizeof(int)*a.size); size=a.size; } 析构函数与 = 的运算符重载如下\nCArray::~CArray(){ if(ptr) delete []ptr; } CArray\u0026amp; CArray::operator=(const CArray\u0026amp; a){ //赋值号的作用手机是使=左边的对象里存放的数组，大小和内容都和右边的对象一样 if(ptr==a.ptr)//防止a=a这样的赋值导致出错 return* this; if(a.ptr==NULL){//如果a里面的数组是空的 if(ptr) delete []ptr; ptr=NULL; size=0; return* this; } if(size\u0026lt;a.size){//如果原有空间够大，就不用分配新的空间 if(ptr) delete []ptr; ptr=new int[a.size]; } memcpy(ptr,a.ptr,sizeof(int)*a.size); size=a.size; return* this; }//CArray\u0026amp; CArray::operator=(const CArray\u0026amp; a) 最后是 push_back 函数，下面的写法实际上是比较低效的，因为每一次添加元素都会需要重新分配空间，造成大量的时间开销，比较好的做法有事先分配一片较大空间，并且在扩容时不使用逐一递增可以采用翻倍等方式\nvoid CArray::push_back(int v){//在数组尾部添加一个元素 if(ptr){ int* tmpPtr=new int[size+1];//重新分配空间 memcpy(tmpPtr,ptr,sizeof(int)*size);//拷贝原数组内容 delete []ptr; ptr=tmpPtr; } else//如果数组本来是空的 ptr=new int[1]; ptr[size++]=v;//加入新的数组元素 } 5.流插入运算符和流提取运算符的重载 本小节中提到的流插入运算符和流提取运算符本质上是左移运算符和右移运算符进行重载。\n问题引入 cout \u0026lt;\u0026lt; 5 \u0026lt;\u0026lt; \u0026quot;this\u0026quot; 为什么能够成立？\ncout 是什么？\n\u0026lt;\u0026lt; 为什么能用在 cout 上？\n流插入运算符的重载 cout 是在头文件 iostream 中定义的，ostream 类的对象 \u0026lt;\u0026lt; 能用在 cout 上是因为在 iostream 里对其进行了重载 ostream\u0026amp; ostream::operator\u0026lt;\u0026lt;(int n){ ......//输出n的代码 return* this; } ostream\u0026amp; ostream::operator\u0026lt;\u0026lt;(const char* s){ ......//输出s的代码 return* this; } 在上述的重载过程当中，将返回值类型设置为 ostream\u0026amp; 以及返回 * this 的目的是使 \u0026lt;\u0026lt; 作用之后的返回值类型不变，这样就可以继续被 \u0026lt;\u0026lt; 作用。\ncout \u0026lt;\u0026lt; 5 \u0026lt;\u0026lt; \u0026quot;this\u0026quot; 本质上的函数调用形式是\ncout.operator \u0026lt;\u0026lt; (5).operator \u0026lt;\u0026lt; (\u0026#34;this\u0026#34;) 举例如下\n假定下面程序输出为 5hello，应该补写什么？\nclass CStudent{ public: int nAge; }; int main(){ CStudent s; s.nAge=5; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;hello\u0026#34;; return 0; } 答案如下\nostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; o,const CStudent\u0026amp; s){ o\u0026lt;\u0026lt;s.nAge; return o; } 一个复杂举例 假定 c 是 Complex 复数类的对象，现在希望写 cout \u0026lt;\u0026lt; c;，就能以 a+bi 的形式输出 c 的值，写 cin \u0026gt;\u0026gt; c;，就能从键盘接受 a+bi 形式的输入，并且使得 c.real=a,c,imag=b。\nint main(){ Complex c; int n; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; n; return 0; } 程序运行结果可以如下\n13.2+133i 87↓ 13.2+133i,87 完整程序如下\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; class Complex{ double real,imag; public: Complex(double r=0,double i=0):real(r),imag(i){}; friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os,const Complex\u0026amp; c); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is,Complex\u0026amp; c); }; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os,const Complex\u0026amp; c){ os \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; c.imag \u0026lt;\u0026lt; \u0026#34;i\u0026#34;;//以\u0026#34;a+bi\u0026#34;的形式输出 return os; } istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is,Complex\u0026amp; c){ string s; is \u0026gt;\u0026gt; s;//将\u0026#34;a+bi\u0026#34;作为字符串读入，\u0026#34;a+bi\u0026#34;中间不能有空格 int pos=s.find(\u0026#34;+\u0026#34;,0); string sTmp=s.substr(0,pos);//分离出代表实部的字符串 c.real=atof(sTmp.c_str());//atof函数能将const char*指针指向的内容转换成float sTmp=s.substr(pos+1,s.length()-pos-2);//分离出代表虚部的字符串 c.imag=atof(sTmp.c_str()); return is; } int main(){ Complex c; int n; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; n; return 0; } 事实上以上程序可以进行优化，优化内容如下：\n支持负数虚部​ 使用 find_last_of(\u0026quot;+-\u0026quot;) 替代 find(\u0026quot;+\u0026quot;)，兼容虚部为负的情况（如 3-4i）。 ​格式校验​​ 检查输入字符串是否以 i 结尾 检查分隔符位置有效性（避免首字符为分隔符） 错误处理​​ 通过 is.setstate(ios::failbit) 设置流错误状态，使程序能处理无效输入。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; class Complex { double real, imag; public: Complex(double r = 0, double i = 0) : real(r), imag(i) {} friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Complex\u0026amp; c); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Complex\u0026amp; c); // 修正1：移除const }; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Complex\u0026amp; c) { os \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; c.imag \u0026lt;\u0026lt; \u0026#34;i\u0026#34;; return os; } istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Complex\u0026amp; c) { string s; is \u0026gt;\u0026gt; s; // 检查字符串以i结尾 if (s.empty() || s.back() != \u0026#39;i\u0026#39;) { is.setstate(ios::failbit); return is; } // 查找最后一个+或-作为分隔符 size_t pos = s.find_last_of(\u0026#34;+-\u0026#34;); if (pos == string::npos || pos == 0) { is.setstate(ios::failbit); return is; } // 分割实部和虚部 string realPart = s.substr(0, pos); string imagPart = s.substr(pos, s.size() - pos - 1); // 去掉i c.real = atof(realPart.c_str()); c.imag = atof(imagPart.c_str()); return is; } int main() { Complex c; int n; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; n; return 0; } 6.类型转换运算符和自增、自减运算符的重载 重载类型转换运算符 #include \u0026lt;iostream\u0026gt; using namespace std; class Complex{ double real,imag; public: Complex(double r=0,double i=0):real(r),imag(i){}; operator double(){return real;}//重载强制类型转换运算符double }; int main(){ Complex c(1.2,3.4); cout \u0026lt;\u0026lt; (double)c \u0026lt;\u0026lt; endl;//输出1.2 double n=2+c;//等价于double n=2+c.operator double() cout \u0026lt;\u0026lt; n;//输出3.2 } 自增、自减运算符的重载 自增运算符 ++、自减运算符 -- 有前置/后置之分，为了区分所重载的是前置运算符还是后置运算符，C++ 规定\n前置运算符作为一元运算符重载\n重载为成员函数 T\u0026amp; operator++(); T\u0026amp; operator--(); 重载为全局函数 T1\u0026amp; operator++(T2); T1\u0026amp; operator--(T2); 后置运算符作为二元运算符重载，多写一个没用的参数 重载为成员函数 T operator++(int); T operator--(int); 重载为全局函数 T1 operator++(T2,int); T1 operator--(T2,int); 在没有后置运算符重载而有前置运算符重载的情况下，在 Visual Studio 中，obj++ 也调用前置重载，而 DEV C++ 则令 obj++ 编译出错。\n举例说明，如下是希望实现的功能\nint main(){ CDemo d(5); cout \u0026lt;\u0026lt; (d++) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;;//等价于d.operator++(0); cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; (++d) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;;//等价于d.operator++(); cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (d--) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;;//等价于d.operator--(d,0); cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; (--d) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;;//等价于d.operator--(d); cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } 预期的输出结果为\n5,6,7,7 7,6,5,5 那么应该如何编写 CDemo？\nclass CDemo{ private: int n; public: CDemo(int i=0):n(i){} CDemo\u0026amp; operator++();//用于前置形式 CDemo operator++(int);//用于后置形式 operator int(){return n;}; friend CDemo\u0026amp; operator--(CDemo\u0026amp;); friend CDemo operator--(CDemo\u0026amp;,int); }; CDemo\u0026amp; CDemo::operator++(){//前置++ ++n; return* this; }//++s即为s.operator++(); CDemo CDemo::operator++(int k){//后置++ CDemo tmp(*this);//记录修改前的对象 n++; return tmp;//返回修改前的对象 }//s++即为s.operator(0); CDemo\u0026amp; operator--(CDemo\u0026amp; d){//前置-- d.n--; return d; }//--s即为operator--(s); CDemo operator--(CDemo\u0026amp; d,int){//后置-- CDemo tmp(d); d.n--; return tmp; }//s--即为operator--(s,0); 一点补充：前置与后置的不同 自增（++）和自减（--）运算符的前置（如 ++i）与后置（如 i++）的区别在于：\n返回值：前置运算符返回运算后的新值，后置运算符返回运算前的原始值； 执行顺序：前置先增减再使用值，后置先使用值再增减； 性能：前置无需创建临时变量，效率更高；后置需保留原始值的副本，可能产生额外开销； 重载实现：C++ 中通过参数区分，前置无参数（T\u0026amp; operator++()），后置用伪参数（T operator++(int)）。\n例如：int a=5; b=++a 后 a=6, b=6，而 b=a++ 后 a=6, b=5。 运算符重载的注意事项 C++ 不允许定义新的运算符； 重载后运算符的含义应该符合日常习惯； 运算符重载不改变运算符的优先级； 以下运算符不能被重载：. .* :: ?: sizeof； 重载运算符 () [] -\u0026gt; 或者赋值运算符 = 时，运算符重载函数必须声明为类的成员函数。 ","permalink":"http://localhost:1313/posts/c++4/","summary":"\u003cp\u003e课程链接：\u003ca href=\"https://www.icourse163.org/course/PKU-1002029030\"\u003e程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"1运算符重载的基本概念\"\u003e1.运算符重载的基本概念\u003c/h2\u003e\n\u003ch3 id=\"运算符重载的需求\"\u003e运算符重载的需求\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在数学上，两个复数可以直接进行 \u003ccode\u003e+\u003c/code\u003e、\u003ccode\u003e-\u003c/code\u003e 等运算。但是在 C++ 中，直接将 \u003ccode\u003e+\u003c/code\u003e 或 \u003ccode\u003e-\u003c/code\u003e 用于复数对象是不允许的。\u003c/p\u003e\n\u003cp\u003e但有时我们会希望，让对象也能够通过运算符进行计算。这样代码更简洁也更容易理解。\u003c/p\u003e","title":"面向对象的程序设计学习笔记 4"},{"content":"课程链接：程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\n1.this 指针 C++ 到 C 的翻译 以下为一段 C++ 程序\nclass CCar{ public: int price; void SetPrice(int p); }; void CCar::SetPrice(int p){ price=p; } int main(){ CCar car; car.SetPrice(20000); return 0; } 翻译为 C 程序如下\nstruct CCar{ int price; }; void SetPrice(struct CCar* this,int p){ this-\u0026gt;price=p; } int main(){ struct CCar car; SetPrice(\u0026amp;car,20000); return 0; } this 指针的作用就是指向成员函数所作用的对象 #include \u0026lt;iostream\u0026gt; using namespace std; class Complex{ public: double real,imag; void Print(){ cout \u0026lt;\u0026lt; real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; imag; } Complex(double r,double i):real(r),imag(i){} Complex AddOne(){ this-\u0026gt;real++;//等价于real++ this-\u0026gt;Print();//等价于Print return* this; } }; int main(){ Complex c1(1,1),c2(0,0); c2=c1.AddOne(); return 0; } //输出:2,1 非静态成员函数中可以直接使用 this 来代表指向该函数作用的对象的指针 #include \u0026lt;iostream\u0026gt; using namespace std; class A{ int i; public: void Hello(){ cout \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(){ A* p=NULL; p-\u0026gt;Hello(); }//正常输出：hello 以上代码如果进行下面的修改就是错误的\n#include \u0026lt;iostream\u0026gt; using namespace std; class A{ int i; public: void Hello(){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl;//错误 } }; int main(){ A* p=NULL; p-\u0026gt;Hello(); } **静态成员函数中不能使用 this 指针！**因为静态成员函数并不具体作用于某个对象，因此静态成员函数的真实的参数的个数，就是程序中写出的参数个数。 2.静态成员变量 基本概念 静态成员：在说明前面加了 static 关键字的成员。\nclass CRectangle{ private: int w,h; static int nTotalArea;//静态成员变量 static int nTotalNumber; public: CRectangle(int w_,int h_); ~CRectangle(); static void PrintTotal();//静态成员函数 }; 普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。 sizeof 运算符不会计算静态成员变量。 class CMyclass{ int n; static int s; };//则sizeof(CMyclass)等于4 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。 因此静态成员不需要通过对象就能访问。 如何访问静态成员 类名:: 成员名 CRectangle::PrintTotal(); 对象名.成员名 CRectangle r;r.PrintTotal(); 指针 -\u0026gt;成员名 CRectangle* p=\u0026amp;r;p-\u0026gt;PrintTotal(); 引用.成员名 CRectangle\u0026amp; ref=r;int n=ref.nTotalNumber; 静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。 静态成员函数本质上是全局函数。 设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。 考虑一个需要随时知道矩形总数和总面积的图形处理程序\n可以用全局变量来记录总数和总面积\n用静态成员将这两个变量封装进类中，就更容易理解和维护\n仍然使用之前的例子\n#include \u0026lt;iostream\u0026gt; using namespace std; //定义类 class CRectangle{ private: int w,h; static int nTotalArea;//静态成员变量 static int nTotalNumber; public: CRectangle(int w_,int h_); ~CRectangle(); static void PrintTotal();//静态成员函数 }; //利用构造函数和析构函数达到计数的效果 CRectangle::CRectangle(int w_,int h_){ w=w_; h=h_; nTotalNumber++; nTotalArea+=w*h; } CRectangle::~CRectangle(){ nTotalNumber--; nTotalArea-=w*h; } void CRectangle::PrintTotal(){ cout \u0026lt;\u0026lt; nTotalNumber \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; nTotalArea \u0026lt;\u0026lt; endl; } //必须在定义类的文件中对静态成员进行一次说明或初始化 //否则编译能通过，链接不能通过 int CRectangle::nTotalNumber=0; int CRectangle::nTotalArea=0; int main(){ CRectangle r1(3,3),r2(2,2); //cout \u0026lt;\u0026lt; CRectangle::nTotalNumber; //[Error] \u0026#39;int CRectangle::nTotalNumber\u0026#39; is private CRectangle::PrintTotal(); r1.PrintTotal(); return 0; } 输出内容为\n2,13 2,13 **注意：**在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。\nvoid CRectangle::PrintTotal(){ cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; nTotalNumber \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; nTotalArea \u0026lt;\u0026lt; endl; //wrong，解释不通w到底是属于哪个对象的 } 事实上，之前例子中的 CRectangle 类的写法是有严重缺陷的，这是因为\n在使用 CRectangle 类时，有时会调用复制构造函数生成临时的隐藏的 CRectangle 对象，这些对象在生成时并不会使用自定义的构造函数，而是使用编译器自动生成的复制构造函数。这里的有时指的是 调用一个以 CRectangle 类对象作为参数的函数时 调用一个以 CRectangle 类对象作为返回值的函数时 临时对象在消亡时会调用析构函数，减少 nTotalNumber 和 nTotalArea 的值，可是这些临时对象在生成时却没有增加 nTotalNumber 和 nTotalArea 的值。 解决办法：为 CRectangle 类写一个复制构造函数。 CRectangle::CRectangle(CRectangle\u0026amp; r){ w=r.w;h=r.h; nTotalNumber++; nTotalArea+=w*h; } 3.成员对象和封闭类 什么是封闭类 有成员对象的类称为封闭（enclosing）类 什么是成员对象？ 在 C++ 中，​​成员对象​​（Member Object）是指一个类的成员变量是另一个类的对象。 举例如下\n#include \u0026lt;iostream\u0026gt; using namespace std; class CTyre{//轮胎类 private: int radius;//半径 int width;//宽度 public: CTyre(int r,int w):radius(r),width(w){} }; class CEngine{};//引擎类 class CCar{//汽车类 private: int price; CTyre tyre; CEngine engine; public: CCar(int p,int tr,int tw); }; CCar::CCar(int p,int tr,int w):price(p),tyre(tr,w){} int main(){ CCar car(20000,17,225); return 0; } 上例中，如果 CCar 类不定义构造函数，则下面的语句会编译出错：\nCCar car; 因为编译器不明白 car.tyre 该如何初始化。car.engine 的初始化没问题，用默认构造函数即可。\n任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。\n具体的做法就是：通过封闭类的构造函数的初始化列表。\n成员对象初始化列表中的参数可以是任意复杂的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行。\n封闭类构造函数和析构函数的执行顺序 封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。 对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关。 当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反。 封闭类实例 #include \u0026lt;iostream\u0026gt; using namespace std; class CTyre{ public: CTyre(){cout \u0026lt;\u0026lt; \u0026#34;CTyre constructor\u0026#34; \u0026lt;\u0026lt; endl;} ~CTyre(){cout \u0026lt;\u0026lt; \u0026#34;CTyre destructor\u0026#34; \u0026lt;\u0026lt; endl;} }; class CEngine{ public: CEngine(){cout \u0026lt;\u0026lt; \u0026#34;CEngine constructor\u0026#34; \u0026lt;\u0026lt; endl;} ~CEngine(){cout \u0026lt;\u0026lt; \u0026#34;CEngine destructor\u0026#34; \u0026lt;\u0026lt; endl;} }; class CCar{ private: CEngine engine; CTyre tyre; public: CCar(){cout \u0026lt;\u0026lt; \u0026#34;CCar constructor\u0026#34; \u0026lt;\u0026lt; endl;} ~CCar(){cout \u0026lt;\u0026lt; \u0026#34;CCar destructor\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ CCar car; return 0; } 输出内容如下\nCEngine constructor CTyre constructor CCar constructor CCar destructor CTyre destructor CEngine destructor 封闭类的复制构造函数 #include \u0026lt;iostream\u0026gt; using namespace std; class A{ public: A(){cout \u0026lt;\u0026lt; \u0026#34;default\u0026#34; \u0026lt;\u0026lt; endl;} A(A\u0026amp;a){cout \u0026lt;\u0026lt; \u0026#34;copy\u0026#34; \u0026lt;\u0026lt; endl;} }; class B{A a;}; int main(){ B b1,b2(b1); return 0; } 输出如下\ndefault copy 以上输出说明 b2.a 是用类 A 的复制构造函数初始化的。而且调用复制构造函数时的实参就是 b1.a。\n4.常量对象、常量成员函数和常引用 常量对象 如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加 const 关键字。 常量成员函数 在类的成员函数说明后面可以加 const 关键字，则该成员函数成为常量成员函数。 常量成员函数执行期间不应修改其作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。 class Sample{ public: int value; void GetValue() const; void func(){}; Sample(){} }; void Sample::GetValue() const{ value=0;//wrong func();//wrong } int main(){ const Sample o; o.value=100;//error，常量对象不可被修改 o.func();//error，常量对象上面不能执行非常量成员函数 o.GetValue();//ok，常量对象上可以执行常量成员函数 return 0; }//在Dev C++中，要为Sample类编写无参构造函数才可以，Visual Studio 2010中不需要 常量成员函数的重载 两个成员函数，名字和参数表都一样，但是一个是 const，一个不是，算重载。 常引用 引用前面可以加 const 关键字，成为常引用。不能通过常引用，修改其引用的变量。 const int\u0026amp; r=n; r=5;//error n=4;//ok 对象作为函数的参数时，生成该参数需要调用复制构造函数，效率比较低。用指针作参数，代码又不好看，如何解决？\n可以用对象的引用作为参数。但是随之而来的问题是若函数中不小心修改了形参，则实参也跟着变，这又如何避免？\n可以用对象的常引用作为参数。\n5.友元 友元分为友元函数和友元类两种。\n友元函数：一个类的友元函数可以访问该类的私有成员。 #include \u0026lt;iostream\u0026gt; using namespace std; class CCar;//提前声明CCar类，以便后面的CDriver类使用 class CDriver{ public: void ModifyCar(CCar* pCar);//改装汽车 }; class CCar{ private: int price; friend int MostExpensiveCar(CCar cars[],int total);//声明友元 friend void CDriver::ModifyCar(CCar* pCar);//声明友元 }; void CDriver::ModifyCar(CCar* pCar){ pCar-\u0026gt;price+=1000;//汽车改装后价值增加 } int MostExpensiveCar(CCar cars[],int total){//求最贵汽车的价格 int tmpMax=-1; for(int i=0;i\u0026lt;total;++i) if(cars[i].price\u0026gt;tmpMax) tmpMax=cars[i].price; return tmpMax; } int main(){return 0;} 可以把一个类的成员函数（包括构造、析构函数）说明为另一个类的友元。 class B{ public: void function(); }; class A{ friend void B::function(); }; 友元类：如果 A 是 B 的友元类，那么 A 的成员函数可以访问 B 的私有成员。 #include \u0026lt;iostream\u0026gt; using namespace std; class CCar{ private: int price; friend class CDriver;//声明CDriver为友元类 }; class CDriver{ public: CCar myCar; void ModifyCar(){//改装汽车 myCar.price+=1000;//因CDriver是CCar的友元类，姑此处可以访问其私有成员 } }; int main(){return 0;} 友元类之间的关系不能传递，不能继承。\n","permalink":"http://localhost:1313/posts/c++3/","summary":"\u003cp\u003e课程链接：\u003ca href=\"https://www.icourse163.org/course/PKU-1002029030\"\u003e程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"1this-指针\"\u003e1.this 指针\u003c/h2\u003e\n\u003ch3 id=\"c-到-c-的翻译\"\u003eC++ 到 C 的翻译\u003c/h3\u003e\n\u003cp\u003e以下为一段 C++ 程序\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eCCar\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eSetPrice\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCCar\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eSetPrice\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003eCCar\u003c/span\u003e \u003cspan class=\"n\"\u003ecar\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003ecar\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSetPrice\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e20000\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e翻译为 C 程序如下\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eCCar\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eSetPrice\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eCCar\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003ethis\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eCCar\u003c/span\u003e \u003cspan class=\"n\"\u003ecar\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nf\"\u003eSetPrice\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecar\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e20000\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003ethis 指针的作用就是\u003cstrong\u003e指向成员函数所作用的对象\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eComplex\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ereal\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eimag\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ereal\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;,\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eimag\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"n\"\u003eComplex\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003er\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003ereal\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003er\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"n\"\u003eimag\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e){}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"n\"\u003eComplex\u003c/span\u003e \u003cspan class=\"nf\"\u003eAddOne\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ereal\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"c1\"\u003e//等价于real++\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\t\t\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"c1\"\u003e//等价于Print\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\t\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003eComplex\u003c/span\u003e \u003cspan class=\"n\"\u003ec1\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"n\"\u003ec2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003ec2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ec1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAddOne\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e//输出:2,1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e非静态\u003c/strong\u003e成员函数中可以直接使用 this 来代表指向该函数作用的对象的指针\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eHello\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eHello\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"c1\"\u003e//正常输出：hello \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e以上代码如果进行下面的修改就是错误的\u003c/p\u003e","title":"面向对象的程序设计学习笔记 3"},{"content":"课程链接：程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\n1.类和对象的基本概念（补充） 类的成员函数和类的定义分开写 class CRectangle { public: int w,h; int Area(); int Perimeter(); void Init(int w_,int h_);//成员函数仅在此声明 }; int CRectangle::Area(){ return w*h; } int CRectangle::Perimeter(){ return 2*(w+h); } void CRectangle::Init(int w_,int h_){ w=w_;h=h_; } CRectangle:: 说明后面的函数是 CRectangle 类的成员函数，而非普通函数。那么，一定要通过对象或对象的指针或对象的引用才能调用。 类成员的可访问范围 在类的定义中，用下列访问范围关键字来说明类成员可被访问的范围\nprivate: 私有成员，只能在成员函数内访问\npublic: 共有成员，可以在任何地方访问\nprotected: 保护成员，以后再说\n定义一个类\nclass classname{ private: 私有属性和函数 public: 共有属性和函数 protected: 保护属性和函数 }； 如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。\n在类的成员函数内部，能够访问\n当前对象的全部属性、函数 同类其它对象的全部属性、函数\n在类的成员函数以外的地方，只能够访问该类对象的公有成员\n私有成员变量的隐藏 设置私有成员的机制，叫“隐藏”\n“隐藏”的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则，所有直接访问成员变量的语句都需要修改。\n成员函数的重载及参数缺省 成员函数也可以重载 成员函数也可以带缺省参数 #include \u0026lt;iostream\u0026gt; using namespace std; class Location{ private: int x,y; public: void init(int x=0,int y=0); void valueX(int val){x=val;} int valueX(){return x;} }; void Location::init(int X,int Y) { x=X; y=Y; } int main(){ Location A,B; A.init(5); A.valueX(5); cout \u0026lt;\u0026lt; A.valueX();//输出5 return 0; } 2.构造函数 构造函数的基本概念 构造函数是成员函数的一种\n名字与类名相同，可以有参数，不能有返回值（void 也不行） 作用是对对象进行初始化，如给成员变量赋初值 如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数。默认构造函数无参数，不做任何操作 如果定义了构造函数，则编译器不生成默认的无参数的构造函数 对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数 一个类可以有多个构造函数 构造函数的重要性 构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数 有时对象没被初始化就使用，会导致程序出错 构造函数的重载 class Complex{ private: double real,imag; public: void Set(double r,double i); };//编译器自动生成默认构造函数 Complex c1;//默认构造函数被调用 Complex* pc = new Complex;//默认构造函数被调用 class Complex{ private: double real,imag; public: Complex(double r,double i=0); }; Complex::Complex(double r,double i){ real=r,imag=i; } Complex c1;//error，缺少构造函数的参数 Complex* pc = new Complex;//error，没有参数 Complex c1(2);//ok 一个类可以有多个构造函数，只要这多个构造函数的参数个数或者参数类型不同，就形成了重载的关系。 一段话描述“重载”的概念\n在编程中，重载（Overload）可以理解为“同一个名字，多种用法”。就像你家的洗衣机有一个“洗涤”按钮，但根据你放入的衣物类型（毛衣、羽绒服、衬衫），它会自动调整水温、转速和时间。重载也是类似逻辑：程序员可以给同一个函数名写多个版本的实现，而这些版本的参数必须不同（比如参数类型、数量或顺序）。例如，一个叫 加法 的函数，既能处理两个整数相加，也能处理三个小数相加，甚至拼接两个字符串——只要参数不同，编译器就能自动根据你传入的数据匹配对应的版本。这样一来，代码更简洁直观，开发者不用死记硬背 加整数、加小数 等五花八门的名字，只需记住一个 加法 就能应对多种场景。\n3.复制构造函数 复制构造函数的基本概念 只有一个参数，即对同类对象的引用 形如 X::X(X \u0026amp;) 或 X::X(const X \u0026amp;)，二者选一，后者能以常量对象作为参数 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能 class Complex{ private: double real,imag; }; Complex c1;//调用缺省无参构造函数 Complex c2(c1);//调用缺省的复制构造函数，将c2初始化成和c1一样 不允许有形如 X::X(X) 的构造函数\n复制构造函数起作用的三种情况 当用一个对象去初始化同类的另一个对象时 Complex c2(c1); Complex c2=c1;//等价于上一条语句，这是一条初始化语句，不是赋值语句 如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类 A 的复制构造函数将被调用 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: A(){}; A(A\u0026amp;a){ cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called\u0026#34; \u0026lt;\u0026lt; endl; } }; void Func(A a1){} int main(){ A a2; Func(a2); return 0; }//程序输出结果为：Copy constructor called 如果函数的返回值是类 A 的对象时，则函数返回时，A 的复制构造函数将被调用 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: int v; A(int n){v=n;}; A(const A\u0026amp;a){ v=a.v; cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called\u0026#34;; } }; A Func(){ A b(4); return b; } int main(){ cout \u0026lt;\u0026lt; Func().v \u0026lt;\u0026lt; endl; return 0; }//输出结果为4 一点问题 在原视频老师的讲解中，输出的内容为\nCopy constructor called4\n但在 DEV-C++ 5.11 中实际运行以上代码，输出结果为\n4\n原因如下\n根据代码逻辑和 C++ 的拷贝构造函数调用规则，输出结果为：4，而不会打印 \u0026ldquo;Copy constructor called\u0026rdquo;。以下是关键原因分析：\n编译器优化（拷贝省略） C++ 编译器在函数返回局部对象时，会进行返回值优化（RVO, Return Value Optimization），直接将对象构造在调用处的内存中，跳过拷贝构造函数的调用。即使拷贝构造函数显式定义了输出语句，编译器也会优化掉这次拷贝。 在代码中，Func() 返回局部对象 b，理论上会触发拷贝构造函数。但由于 RVO 优化：\n• 实际构造过程：直接在 Func() 的返回值内存区域构造 b，无需拷贝。\n• 结果：cout \u0026lt;\u0026lt; Func().v 直接输出 b.v 的值 4，而不会触发拷贝构造函数的输出。\n若关闭编译器优化 如果强制关闭优化（例如 GCC 使用 -fno-elide-constructors），代码会输出：\nCopy constructor called4 此时：\nFunc() 返回 b 时，会调用拷贝构造函数生成临时对象。 临时对象再被用来访问 v，输出 4。 代码细节验证 拷贝构造函数的触发条件：只有当用已有对象初始化新对象时才会调用拷贝构造函数（例如 A a = b;）。而返回值优化场景下，对象直接在目标内存构造，不满足这一条件。 C++ 标准支持：C++11 及以后版本中，RVO 是编译器必须支持的优化，即使拷贝/移动构造函数有副作用（如输出语句），优化仍然生效。 因此 在默认编译选项下，输出为 4。若需验证拷贝构造函数的行为，需通过编译选项关闭优化。\n注意，对象间赋值并不导致复制构造函数被调用\nclass CMyclass{ public: int n; CMyclass(){}; CMyclass(CMyclass \u0026amp; c){n=2*c.n;}//此处仅为说明问题，并不推荐复制函数这样书写 }; int main(){ CMyclass c1,c2; c1.n=5;c2=c1;CMyclass c3(c1); cout \u0026lt;\u0026lt; \u0026#34;c2.n=\u0026#34; \u0026lt;\u0026lt; c2.n \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;c3.n=\u0026#34; \u0026lt;\u0026lt; c3.n \u0026lt;\u0026lt; endl; return 0; }//输出：c2.n=5,c3.n=10 常量引用参数的使用 void fun(CMyclass obj_){ cout \u0026lt;\u0026lt; \u0026#34;fun\u0026#34; \u0026lt;\u0026lt; endl; } 这样的函数，调用时生成形参会引发复制构造函数调用，开销比较大 所以可以考虑使用 CMyclass \u0026amp;引用类型作为参数 如果希望确保实参的值在函数中不应被改变，那么可以加上 const 关键字 void fun(const CMyclass \u0026amp; obj){ //函数中任何试图改变obj值的语句都变成非法语句 } 4.类型转换构造函数 什么是类型转换构造函数 定义转换构造函数的目的是实现类型的自动转换 只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数 当需要时，编译系统会自动调用转换构造函数，建立一个无名的临时对象（或临时变量） 类型转换构造函数示例 class Complex{ public: double real,imag; Complex(int i){//类型转换构造函数 cout \u0026lt;\u0026lt; \u0026#34;IntConstructor called\u0026#34; \u0026lt;\u0026lt; endl; real=i;imag=0; } Complex(double r,double i){real=r;imag=i;} }; int main(){ Complex c1(7,8); Complex c2=12; c1=9;//9被自动转换成一个临时Complex对象 cout \u0026lt;\u0026lt; c1.real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; c1.imag \u0026lt;\u0026lt; endl; return 0; } 5.析构函数 什么是析构函数 名字与类名相同，在前面加 ~，没有参数和返回值，一个类最多只能有一个析构函数 析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等 如果定义类时没写析构函数，则编译器生成缺省析构函数，缺省析构函数什么也不做 如果定义了析构函数，则编译器不生成缺省析构函数 析构函数示例 class String{ private: char* p; public: String(){ p=new char[10]; } ~String(); }; String::~String(){ delete []p; } 析构函数和数组 对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。 class Ctest{ public: ~Ctest(){cout \u0026lt;\u0026lt; \u0026#34;destructor called\u0026#34; \u0026lt;\u0026lt; endl;} }; int main(){ Ctest array[2]; cout \u0026lt;\u0026lt; \u0026#34;End Main\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 输出\nEnd Main destructor called destructor called 析构函数和运算符 delete delete 运算导致析构函数被调用 Ctest* pTest; pTest=new Ctest;//构造函数调用 delete pTest;//析构函数调用 pTest=new Ctest[3];//构造函数调用3次 delete []pTest;//析构函数调用3次 若 new 一个对象数组，那么用 delete 释放时应该写 []。否则只 delete 一个对象（调用一次析构函数） 6.构造函数析构函数调用时机 #include \u0026lt;iostream\u0026gt; using namespace std; class Demo{ int id; public: Demo(int i){ id=i; cout \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; constructed\u0026#34; \u0026lt;\u0026lt; endl; } ~Demo(){ cout \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; destructed\u0026#34; \u0026lt;\u0026lt; endl; } }; Demo d1(1); void Func(){ static Demo d2(2); Demo d3(3); cout \u0026lt;\u0026lt; \u0026#34;func\u0026#34; \u0026lt;\u0026lt; endl; } int main(){ Demo d4(4); d4=6; cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; endl; { Demo d5(5); } Func(); cout \u0026lt;\u0026lt; \u0026#34;main ends\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 输出内容\nid=1 constructed id=4 constructed id=6 constructed id=6 destructed main id=5 constructed id=5 destructed id=2 constructed id=3 constructed func id=3 destructed main ends id=6 destructed id=2 destructed id=1 destructed ","permalink":"http://localhost:1313/posts/c++2/","summary":"\u003cp\u003e课程链接：\u003ca href=\"https://www.icourse163.org/course/PKU-1002029030\"\u003e程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"1类和对象的基本概念补充\"\u003e1.类和对象的基本概念（补充）\u003c/h2\u003e\n\u003ch3 id=\"类的成员函数和类的定义分开写\"\u003e类的成员函数和类的定义分开写\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eCRectangle\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eArea\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ePerimeter\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eInit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ew_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eh_\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"c1\"\u003e//成员函数仅在此声明\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eCRectangle\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eArea\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eCRectangle\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ePerimeter\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCRectangle\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eInit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ew_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eh_\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ew_\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eh_\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eCRectangle:: 说明后面的函数是 CRectangle 类的成员函数，而非普通函数。那么，一定要通过对象或对象的指针或对象的引用才能调用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"类成员的可访问范围\"\u003e类成员的可访问范围\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在类的定义中，用下列访问范围关键字来说明类成员可被访问的范围\u003c/p\u003e","title":"面向对象的程序设计学习笔记 2"},{"content":"课程链接：程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\n1.引用 引用写法 类型名 \u0026amp; 引用名 = 某变量名 定义引用是一定要将其初始化成引用某个变量 初始化后，它就一直引用该变量，不会再引用别的变量了 引用只能引用变量，不能引用常量和表达式 引用应用的简单举例：两数交换\nvoid swap(int \u0026amp; a,int \u0026amp; b) { int tmp; tmp=a;a=b;b=tmp; } int n1,n2; swap(n1,n2);//n1,n2的值被交换 常引用 const int \u0026amp;\n不能通过常引用去修改其引用的内容 int n=100; const int \u0026amp; r=n; r=200;//编译错 n=300;//没问题 const T \u0026amp; 和 T \u0026amp; 是不同的类型！\nT \u0026amp; 类型的引用或 T 类型的变量可以用来初始化 const T \u0026amp; 类型的引用 const T 类型的常变量和 const T \u0026amp; 类型的引用则不能用来初始化 T \u0026amp; 类型的引用，除非进行强制类型转换。 2.const 关键字 常量指针 const int *\n不可通过常量指针修改其指向的内容 int n,m; const int* p = \u0026amp;n; *p=5;//编译出错 n=4;//ok p=\u0026amp;m;//ok，常量指针的指向可以变化 不能把常量指针赋值给非常量指针，反过来可以 const int* p1;int* p2; p1=p2;//ok p2=p1;//error p2=(int*)p1;//ok，强制类型转换 函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容 void MyPrintf(const char* p) { strcpy(p,\u0026#34;this\u0026#34;);//编译出错 printf(\u0026#34;%s\u0026#34;,p);//ok } 3.动态内存分配 用 new 运算符实现动态内存分配 第一种用法 分配一个变量 P = new T; T 是任意类型名，P 是类型为 T * 的指针，动态分配出一片大小为 sizeof(T) 字节的内存空间，并且将该内存空间的起始地址复制给 P。\nint* pn; pn=new int; * pn=5; 第二种用法 分配一个数组 P = new T[N]; T 是任意类型名，P 是类型为 T * 的指针，N 是要分配的数组元素的个数，可以是整形表达式，动态分配出一片大小为 N*sizeof(T) 字节的内存空间，并且将该内存空间的起始地址赋值给 P。\nint* pn; int i=5; pn=new int[i*20]; pn[0]=20; pn[100]=30;//编译没问题，运行时数组越界 用 delete 运算符释放动态分配的内存 用“new”动态分配的内存空间，一定要用“delete”运算符进行释放\ndelete 指针;//该指针必须指向new出来的空间 int* p=new int; * p=5; delete p; delete p;//导致异常，一片空间不能多次被delete 用 delete 运算符释放动态分配的数组 用“delete”释放动态分配的数组，要加“[]”\ndelete [] 指针;//该指针必须指向new出来的数组 int* p=new int[20]; p[0]=1; delete []p; 4.内联函数、函数重载、函数缺省参数 内联函数 在函数定义前面加“inline”关键字，即可定义内联函数\ninline int Max(int a,int b) { if(a\u0026gt;b)return a; return b; } 函数重载 一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。\n以下三个函数是重载关系\nint Max(double f1,double f2){} int Max(int n1,int n2){} int Max(int n1,int n2,int n3){} 函数重载使得函数命名变得简单 编译器根据调用语句中的实参的个数和类型判断应该调用哪个函数 函数的缺省参数 C++ 中，定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。\nvoid func(int x1,int x2=2,int x3=3){} func(10);//等效于func(10,2,3) func(10,8);//等效于func(10,8,3) func(10,,8);//不行，只能最右边的连续若干个参数缺省 函数参数可缺省的目的在于提高程序的可扩充性，即如果某个写好的函数想要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，那么为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。\n5.类和对象的基本概念 面向对象的程序设计具有抽象、封装、继承、多态四个基本特点。\n从客观事物中抽象出类 举例\n写一个程序，输入矩形的长和宽，输出面积和周长\n比如对于“矩形”这种东西，要用一个类表示，该如何做抽象？\n矩形的属性就是长和宽。因此需要两个变量，分别代表长和宽。\n一个矩形，可以有哪些行为呢？\n矩形可以设置长和宽，算面积以及算周长这三种行为（当然也可以设置其他行为） 这三种行为，可以各用一个函数来实现，他们都需要用到长和宽这两个变量。\n将长、宽变量和设置长、宽，求面积，以及求周长的三个函数封装在一起，就能形成一个矩形类。 长、宽变量成为该“矩形类”的成员变量，三个函数成为该类的成员函数。成员变量和成员函数统称为类的成员。 class CRectangle { public: int w,h; int Area(){ return w*h; } int Perimeter(){ return 2*(w+h); } void Init(int w_,int h_){ w=w_; h=h_; } };//必须有分号 如何使用类？\nint main() { int w,h; CRectangle r;//r是一个对象 cin \u0026gt;\u0026gt; w \u0026gt;\u0026gt; h; r.Init(w,h); cout \u0026lt;\u0026lt; r.Area() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r.Perimeter(); return 0; } 通过类，可以定义变量。类定义出来的变量，也称为类的实例，就是我们所说的“对象”。 C++ 中，类的名字就是用户自定义的类型的名字，可以像使用基本类型那样来使用它。 和结构变量一样，对象之间可以用“=”进行赋值，但是不能进行比较，除非这些运算符经过了“重载”。\n这句话的意思是：对象之间可以直接用等号 = 互相赋值（比如 obj2 = obj1），但默认情况下不能用 ==、\u0026gt; 等符号比较大小，除非你专门为这些比较符号 \u0026quot; 写说明书 \u0026ldquo;（即运算符重载）。\n举个生活化的例子：\n赋值（=）：\n就像复印机默认能复印文件（直接 obj2 = obj1），把一份文件的内容完整复制到另一份。\n比较（==、\u0026gt; 等）：\n但如果你想比较两本书哪本更厚，复印机不会自动判断——除非你亲自告诉它规则（重载运算符）。比如：\nbool operator\u0026gt;(Book a, Book b) { return a.page_count \u0026gt; b.page_count; } 这样 book1 \u0026gt; book2 就能比较页数了。\n为什么这样设计？\n• 赋值：对象内部可能有复杂数据，直接复制内存是最简单的默认行为。\n• 比较：不同对象比较规则不同（比如学生按分数比，汽车按价格比），必须由程序员自定义。\n简单说：= 是 \u0026quot; 无脑复制 \u0026ldquo;，而 == 需要你教计算机怎么比。\n使用类的成员变量和成员函数 用法一：对象名.成员名\nCRectangle r1,r2; r1.w=5; r2.Init(5,4);//Init 函数作用在r2上，访问到的w，h是属于r2这个对象的，不会影响到r1 用法二：指针 -\u0026gt;成员名\nCRectangle r1,r2; CRectangle * p1= \u0026amp; r1; CRectangle * p2= \u0026amp; r2; p1-\u0026gt;w=5; p2-\u0026gt;Init(5,4);//Init 作用在 p2 指向的对象上 用法三：引用名.成员名\nCRectangle r2; CRectangle \u0026amp; rr = r2; rr.w=5; rr.Init(5,4);//rr的值变，r2的值也变 ","permalink":"http://localhost:1313/posts/c++1/","summary":"\u003cp\u003e课程链接：\u003ca href=\"https://www.icourse163.org/course/PKU-1002029030\"\u003e程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"1引用\"\u003e1.引用\u003c/h2\u003e\n\u003ch3 id=\"引用写法\"\u003e引用写法\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e类型名 \u0026amp; 引用名 = 某变量名\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e定义引用是一定要将其\u003cstrong\u003e初始化\u003c/strong\u003e成引用某个变量\u003c/li\u003e\n\u003cli\u003e初始化后，它就一直引用该变量，不会再引用别的变量了\u003c/li\u003e\n\u003cli\u003e引用只能引用变量，不能引用常量和表达式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e引用应用的简单举例：两数交换\u003c/p\u003e","title":"面向对象的程序设计学习笔记 1"}]