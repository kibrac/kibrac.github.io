<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>面向对象的程序设计学习笔记 6 - Kibrac&#39;s Blog</title>
  <meta name="description" content="第六章 多态">
  
  
  <link rel="icon" type="image/png" href="https://kibrac.github.io/favicon.png">
  
  
  <link rel="stylesheet" href="https://kibrac.github.io/css/normalize.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/style.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/archives.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/custom.css">
  
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
  
  
  <script>
    
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const storedTheme = localStorage.getItem('theme');
    if (storedTheme === 'dark' || (!storedTheme && prefersDark)) {
      document.documentElement.classList.add('dark-mode');
    }
  </script>
  
  <meta property="og:url" content="https://kibrac.github.io/posts/c&#43;&#43;6/">
  <meta property="og:site_name" content="Kibrac&#39;s Blog">
  <meta property="og:title" content="面向对象的程序设计学习笔记 6">
  <meta property="og:description" content="第六章 多态">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-15T21:57:01+08:00">
    <meta property="article:modified_time" content="2025-05-15T21:57:01+08:00">
    <meta property="article:tag" content="C&#43;&#43;">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="面向对象的程序设计学习笔记 6">
  <meta name="twitter:description" content="第六章 多态">
      <meta name="twitter:site" content="@https://x.com/kibra_chen">

  
  
  
  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
</head>
<body>
  <div class="container">
    <header class="site-header">
      <div class="header-container">
  <div class="site-branding">
    <a href="/" class="site-title">Kibrac&#39;s Blog</a>
    
  </div>
  
  <nav class="main-navigation">
    
    <ul class="menu" id="primary-menu">
      
      
      <li class="menu-item  ">
        <a href="/" class="home-link">首页</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/posts/" >文章</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/archives/" >归档</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/categories/" >分类</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/tags/" >标签</a>
      </li>
      
    </ul>
  </nav>
  
  <div class="header-actions">
    <button class="menu-toggle" aria-controls="primary-menu" aria-expanded="false">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>
    
    
    <button class="theme-toggle" aria-label="切换主题">
      <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
      </svg>
      <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
      </svg>
    </button>
  </div>
</div>


    </header>
    
    <main class="main-content">
      
<div class="post-container">
  <article class="post">
    
    <div class="post-featured-image banner">
      <img src="https://kibrac.github.io/images/cover/c&#43;&#43;.jpg" alt="面向对象的程序设计学习笔记 6">
    </div>
    
    
    <header class="post-header">
      <h1 class="post-title">面向对象的程序设计学习笔记 6</h1>
      
      <div class="post-meta">
        <time datetime="2025-05-15T21:57:01&#43;08:00">
          2025-05-15
        </time>
        
        
        <span class="post-author">
          Kibrac
        </span>
        
        
        
        <div class="post-categories">
          
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
          
        </div>
        
      </div>
    </header>
    
    <div class="post-content">
      <p>课程链接：<a href="https://www.icourse163.org/course/PKU-1002029030">程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)</a></p>
<h2 id="1虚函数和多态的基本概念">1.虚函数和多态的基本概念</h2>
<h3 id="虚函数">虚函数</h3>
<ul>
<li>在类的定义中，前面有 <code>virtual</code> 关键字的成员函数就是虚函数。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">base</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> base<span style="color:#f92672">::</span>get(){}
</span></span></code></pre></div><ul>
<li><code>virtual</code> 关键字只用在类定义里的函数声明中，写函数体时不用。</li>
<li>构造函数和静态成员函数不能是虚函数。（关于静态成员函数参考第三章 类和对象提高）</li>
</ul>
<h3 id="多态的表现形式一">多态的表现形式一</h3>
<ul>
<li>派生类的指针可以赋给基类指针。</li>
<li>通过基类指针调用基类和派生类中的同名<strong>虚函数</strong>时：
<ul>
<li>若该指针指向一个基类的对象，那么被调用的是基类的虚函数；</li>
<li>若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</li>
</ul>
</li>
</ul>
<p>这种机制就叫做“<strong>多态</strong>”。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CBase</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> SomeVirtualFunction(){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDerived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CBase{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> SomeVirtualFunction(){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	CDerived ODerived;
</span></span><span style="display:flex;"><span>	CBase<span style="color:#f92672">*</span> p<span style="color:#f92672">=&amp;</span>ODerived;
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>SomeVirtualFunction();<span style="color:#75715e">//调用哪个虚函数取决于p指向哪种类型的对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="多态的表现形式二">多态的表现形式二</h3>
<ul>
<li>派生类的对象可以赋给基类引用。</li>
<li>通过基类引用来调用基类和派生类中的同名<strong>虚函数</strong>时：
<ul>
<li>若该引用引用的是一个基类的对象，那么被调用的是基类的<strong>虚函数</strong>；</li>
<li>若该引用引用的是一个派生类的对象，那么被调用的是派生类的<strong>虚函数</strong>。</li>
</ul>
</li>
</ul>
<p>这种机制也叫做“<strong>多态</strong>”。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CBase</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> SomeVirtualFunction(){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDerived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CBase{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> SomeVirtualFunction(){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	CDerived ODerived;
</span></span><span style="display:flex;"><span>	CBase<span style="color:#f92672">&amp;</span> r<span style="color:#f92672">=</span>ODerived;
</span></span><span style="display:flex;"><span>	r.SomeVirtualFunction();<span style="color:#75715e">//调用哪个虚函数取决于r引用哪种类型的对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="多态的简单示例">多态的简单示例</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Print(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A::Print&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> A{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Print(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B::Print&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> A{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Print(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;D::Print&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">E</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> B{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Print(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;E::Print&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	A a;B b;D d;E e;
</span></span><span style="display:flex;"><span>	A<span style="color:#f92672">*</span> pa<span style="color:#f92672">=&amp;</span>a;B<span style="color:#f92672">*</span> pb<span style="color:#f92672">=&amp;</span>b;
</span></span><span style="display:flex;"><span>	D<span style="color:#f92672">*</span> pd<span style="color:#f92672">=&amp;</span>d;E<span style="color:#f92672">*</span> pe<span style="color:#f92672">=&amp;</span>e;
</span></span><span style="display:flex;"><span>	pa<span style="color:#f92672">-&gt;</span>Print();
</span></span><span style="display:flex;"><span>	pa<span style="color:#f92672">=</span>pb;
</span></span><span style="display:flex;"><span>	pa<span style="color:#f92672">-&gt;</span>Print();
</span></span><span style="display:flex;"><span>	pa<span style="color:#f92672">=</span>pd;
</span></span><span style="display:flex;"><span>	pa<span style="color:#f92672">-&gt;</span>Print();
</span></span><span style="display:flex;"><span>	pa<span style="color:#f92672">=</span>pe;
</span></span><span style="display:flex;"><span>	pa<span style="color:#f92672">-&gt;</span>Print();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出内容为</p>
<pre tabindex="0"><code>A::Print
B::Print
D::Print
E::Print
</code></pre><p>在面向对象的程序设计中使用多态，能够增强程序的<strong>可扩充性</strong>，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。</p>
<h2 id="2多态实例魔法门之英雄无敌">2.多态实例：魔法门之英雄无敌</h2>
<h3 id="非多态实现方式">非多态实现方式</h3>
<p><strong>基本思路</strong></p>
<ul>
<li>为每个怪物类编写 <code>Attack</code>、<code>FightBack</code> 和 <code>Hurted</code> 成员函数。</li>
<li><code>Attack</code> 函数表现攻击动作，攻击某个怪物，并调用被攻击怪物的 <code>Hurted</code> 函数，以减少被攻击怪物的生命值，同时也调用被攻击怪物的 <code>FightBack</code> 函数，遭受被攻击怪物反击。</li>
<li><code>Hurted</code> 函数减少自身生命值，并表现受伤动作。</li>
<li><code>FightBack</code> 函数表现反击动作，并调用被反击对象的 <code>Hurted</code> 函数，使被反击对象受伤。</li>
<li>设置基类 <code>CCreature</code>，并且使 <code>CDragon</code>、<code>CWolf</code> 等其他类都从 <code>CCreature</code> 派生而来。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CCreature</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nPower;<span style="color:#75715e">//攻击力
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> nLifeValue;<span style="color:#75715e">//生命值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDragon</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CCreature{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> Attack(CWolf<span style="color:#f92672">*</span> pWolf){
</span></span><span style="display:flex;"><span>			......<span style="color:#75715e">//表现攻击动作的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pWolf<span style="color:#f92672">-&gt;</span>Hurted(nPower);
</span></span><span style="display:flex;"><span>			pWolf<span style="color:#f92672">-&gt;</span>FightBack(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Attack</span>(CGhost<span style="color:#f92672">*</span> pGhost){
</span></span><span style="display:flex;"><span>			......<span style="color:#75715e">//表现攻击动作的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pGhost<span style="color:#f92672">-&gt;</span>Hurted(nPower);
</span></span><span style="display:flex;"><span>			pGhost<span style="color:#f92672">-&gt;</span>FightBack(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Hurted</span>(<span style="color:#66d9ef">int</span> nPower){
</span></span><span style="display:flex;"><span>			......<span style="color:#75715e">//表现受伤动作的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			nLifeValue<span style="color:#f92672">-=</span>nPower;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FightBack</span>(CWolf<span style="color:#f92672">*</span> pWolf){
</span></span><span style="display:flex;"><span>			......<span style="color:#75715e">//表现反击动作的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pWolf<span style="color:#f92672">-&gt;</span>Hurted(nPower<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);<span style="color:#75715e">//这里只是象征性地对反击的攻击力进行了调整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FightBack</span>(CGhost<span style="color:#f92672">*</span> pWolf){
</span></span><span style="display:flex;"><span>			......<span style="color:#75715e">//表现反击动作的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pGhost<span style="color:#f92672">-&gt;</span>Hurted(nPower<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>有 n 种怪物，<code>CDragon</code> 类中就会有 n 个 <code>Attack</code> 成员函数，以及 n 个 <code>FightBack</code> 成员函数等。对于其他类也是如此。</li>
<li>那么如果游戏版本升级，增加了新的怪物雷鸟 <code>CThunderBird</code>，则程序改动就会较大，不光要新增怪物类，其他所有的类都需要增加两个成员函数 ```</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Attack</span>(CThunderBird<span style="color:#f92672">*</span> pThunderBird);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FightBack</span>(CThunderBird<span style="color:#f92672">*</span> pThunderBird);
</span></span></code></pre></div><h3 id="多态实现方式">多态实现方式</h3>
<ul>
<li>基类只有一个 <code>Attack</code> 成员函数，也只有一个 <code>FightBack</code> 成员函数；所有 <code>CCreature</code> 的派生类也是这样。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CCreature</span>{<span style="color:#75715e">//基类CCreature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> m_nLifeValue,m_nPower;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Attack(CCreature<span style="color:#f92672">*</span> pCreature){}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Hurted</span>(<span style="color:#66d9ef">int</span> nPower){}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FightBack</span>(CCreature<span style="color:#f92672">*</span> pCreature){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDragon</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CCreature{<span style="color:#75715e">//派生类CDragon
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Attack(CCreature<span style="color:#f92672">*</span> pCreature);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Hurted</span>(<span style="color:#66d9ef">int</span> nPower);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FightBack</span>(CCreature<span style="color:#f92672">*</span> pCreature);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CDragon<span style="color:#f92672">::</span>Attack(CCreature<span style="color:#f92672">*</span> p){
</span></span><span style="display:flex;"><span>	......<span style="color:#75715e">//表现攻击动作的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p<span style="color:#f92672">-&gt;</span>Hurted(m_nPower);<span style="color:#75715e">//多态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p<span style="color:#f92672">-&gt;</span>FightBack(<span style="color:#66d9ef">this</span>);<span style="color:#75715e">//多态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CDragon<span style="color:#f92672">::</span>Hurted(<span style="color:#66d9ef">int</span> nPower){
</span></span><span style="display:flex;"><span>	......<span style="color:#75715e">//表现受伤动作的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	m_nLifeValue<span style="color:#f92672">-=</span>nPower;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CDragon<span style="color:#f92672">::</span>FightBack(CCreature<span style="color:#f92672">*</span> p){
</span></span><span style="display:flex;"><span>	......<span style="color:#75715e">//表现反击动作的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p<span style="color:#f92672">-&gt;</span>Hurted(m_nPower<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);<span style="color:#75715e">//多态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>在多态的写法中，只需要添加新类 <code>CThunderBird</code>，不需要在已有的类里专门为新怪物增加成员函数，<strong>已有的类可以原封不动</strong>。</li>
</ul>
<p><strong>原理</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CDragon Dragon;CWolf Wolf;
</span></span><span style="display:flex;"><span>CGhost Ghost;CThunderBird Bird;
</span></span><span style="display:flex;"><span>Dragon.Attack(<span style="color:#f92672">&amp;</span>Wolf);<span style="color:#75715e">//(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Dragon.Attack(<span style="color:#f92672">&amp;</span>Ghost);<span style="color:#75715e">//(2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Dragon.Attack(<span style="color:#f92672">&amp;</span>Bird);<span style="color:#75715e">//(3)
</span></span></span></code></pre></div><p>根据多态的规则，上面的（1）（2）（3）进入到 <code>CDragon::Attack</code> 函数后，能分别调用 <code>CWolf::Hurted</code>、<code>CGhost::Hurted</code>、<code>CBird::Hurted</code>。</p>
<h2 id="3多态实例几何形体处理程序">3.多态实例：几何形体处理程序</h2>
<h3 id="几何形体处理程序">几何形体处理程序</h3>
<p><strong>情景要求</strong></p>
<p>几何形体处理程序：输入若干个几何形体的参数，要求按面积排序输出，输出时要指明形状。</p>
<pre tabindex="0"><code>Input
第一行是几何形体数目n（不超过100），下面有n行，每行以一个字母开头。
若字母为R，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高；
若字母为C，则代表一个圆，本行后面跟着一个整数代表其半径；
若字母为T，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度。

Output
按面积从小到大依次输出每个几何形体的种类及面积。每行一个几何形体，输出格式为
形体面积:面积
</code></pre><p>样例</p>
<pre tabindex="0"><code>Sample Input
3
R 3 5
C 9
T 3 4 5

Sample Output
Triangle:6
Rectangle:15
Circle:254.34
</code></pre><p>完整代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;math.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CShape</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> Area()<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//纯虚数：连函数体都没有的虚函数 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintInfo</span>()<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CRectangle</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CShape{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> w,h;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">Area</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintInfo</span>();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CCircle</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CShape{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> r;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">Area</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintInfo</span>();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CTriangle</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CShape{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">Area</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintInfo</span>();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> CRectangle<span style="color:#f92672">::</span>Area(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> w<span style="color:#f92672">*</span>h;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CRectangle<span style="color:#f92672">::</span>PrintInfo(){
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Rectangle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> Area() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> CCircle<span style="color:#f92672">::</span>Area(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3.14</span><span style="color:#f92672">*</span>r<span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CCircle<span style="color:#f92672">::</span>PrintInfo(){
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Circle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> Area() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> CTriangle<span style="color:#f92672">::</span>Area(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">double</span> p<span style="color:#f92672">=</span>(a<span style="color:#f92672">+</span>b<span style="color:#f92672">+</span>c)<span style="color:#f92672">/</span><span style="color:#ae81ff">2.0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sqrt</span>(p<span style="color:#f92672">*</span>(p<span style="color:#f92672">-</span>a)<span style="color:#f92672">*</span>(p<span style="color:#f92672">-</span>b)<span style="color:#f92672">*</span>(p<span style="color:#f92672">-</span>c));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CTriangle<span style="color:#f92672">::</span>PrintInfo(){
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Triangle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> Area() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CShape<span style="color:#f92672">*</span> pShapes[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">MyCompare</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> s1,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> s2){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">double</span> a1,a2;
</span></span><span style="display:flex;"><span>	CShape<span style="color:#f92672">**</span>p1;<span style="color:#75715e">//s1、s2是void*，不可写*s1来获取s1指向的内容 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	CShape<span style="color:#f92672">**</span>p2;
</span></span><span style="display:flex;"><span>	p1<span style="color:#f92672">=</span>(CShape<span style="color:#f92672">**</span>)s1;<span style="color:#75715e">//s1、s2指向pShapes数组中的元素，数组元素的类型是CShape* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p2<span style="color:#f92672">=</span>(CShape<span style="color:#f92672">**</span>)s2;<span style="color:#75715e">//故p1、p2都是指向指针的指针，类型为CShape** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	a1<span style="color:#f92672">=</span>(<span style="color:#f92672">*</span>p1)<span style="color:#f92672">-&gt;</span>Area();<span style="color:#75715e">//*p1的类型是CShape*，是基类指针，故此句为多态 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	a2<span style="color:#f92672">=</span>(<span style="color:#f92672">*</span>p2)<span style="color:#f92672">-&gt;</span>Area();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(a1<span style="color:#f92672">&lt;</span>a2)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(a2<span style="color:#f92672">&lt;</span>a1)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i;<span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>	CRectangle<span style="color:#f92672">*</span> pr;CCircle<span style="color:#f92672">*</span> pc;CTriangle<span style="color:#f92672">*</span> pt;
</span></span><span style="display:flex;"><span>	cin <span style="color:#f92672">&gt;&gt;</span> n;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>		cin <span style="color:#f92672">&gt;&gt;</span> c;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">switch</span>(c){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;R&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>				pr<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> CRectangle();
</span></span><span style="display:flex;"><span>				cin <span style="color:#f92672">&gt;&gt;</span> pr<span style="color:#f92672">-&gt;</span>w <span style="color:#f92672">&gt;&gt;</span> pr<span style="color:#f92672">-&gt;</span>h;
</span></span><span style="display:flex;"><span>				pShapes[i]<span style="color:#f92672">=</span>pr;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;C&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>				pc<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> CCircle();
</span></span><span style="display:flex;"><span>				cin <span style="color:#f92672">&gt;&gt;</span> pc<span style="color:#f92672">-&gt;</span>r;
</span></span><span style="display:flex;"><span>				pShapes[i]<span style="color:#f92672">=</span>pc;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;T&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>				pt<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> CTriangle();
</span></span><span style="display:flex;"><span>				cin <span style="color:#f92672">&gt;&gt;</span> pt<span style="color:#f92672">-&gt;</span>a <span style="color:#f92672">&gt;&gt;</span> pt<span style="color:#f92672">-&gt;</span>b <span style="color:#f92672">&gt;&gt;</span> pt<span style="color:#f92672">-&gt;</span>c;
</span></span><span style="display:flex;"><span>				pShapes[i]<span style="color:#f92672">=</span>pt;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	qsort(pShapes,n,<span style="color:#66d9ef">sizeof</span>(CShape<span style="color:#f92672">*</span>),MyCompare);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		pShapes[i]<span style="color:#f92672">-&gt;</span>PrintInfo();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果添加新的几何形体，比如五边形，则只需要从 <code>CShape</code> 派生出 <code>CPentagon</code>，以及在 <code>main</code> 中的 <code>switch</code> 语句中增加一个 <code>case</code>，其余部分都不变，体现了多态在提高程序可扩充性方面具有良好作用。</p>
<ul>
<li>用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组就能对各个派生类对象做各种操作，是很常用的做法。</li>
</ul>
<h3 id="多态的又一例子">多态的又一例子</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> fun1(){fun2();}<span style="color:#75715e">//等价于void fun1(){this-&gt;fun2();}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>							<span style="color:#75715e">//而this是基类指针，fun2是虚函数，所以是多态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun2</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base::fun2()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Base{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> fun2(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived:fun2()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	Derived d;
</span></span><span style="display:flex;"><span>	Base<span style="color:#f92672">*</span> pBase<span style="color:#f92672">=&amp;</span>d;
</span></span><span style="display:flex;"><span>	pBase<span style="color:#f92672">-&gt;</span>fun1();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}<span style="color:#75715e">//输出：Derived:fun2()
</span></span></span></code></pre></div><ul>
<li><strong>在非构造函数，非析构函数的成员函数中调用虚函数，是多态！！！</strong></li>
<li><strong>在构造函数和析构函数中调用虚函数，不是多态。</strong> 编译时即可确定调用的函数是<strong>自己的类或基类</strong>中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。</li>
</ul>
<h3 id="构造函数和析构函数中调用虚函数举例">构造函数和析构函数中调用虚函数举例</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">myclass</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> hello(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello from myclass&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bye</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bye from myclass&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">son</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> myclass{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> hello(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello from son&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>	son(){hello();}
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">~</span>son(){bye();}
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">grandson</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> son{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> hello(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello from grandson&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bye</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bye from grandson&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>		grandson(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;constructing grandson&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>grandson(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destructing grandson&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	grandson gson;
</span></span><span style="display:flex;"><span>	son<span style="color:#f92672">*</span> pson;
</span></span><span style="display:flex;"><span>	pson<span style="color:#f92672">=&amp;</span>gson;
</span></span><span style="display:flex;"><span>	pson<span style="color:#f92672">-&gt;</span>hello();<span style="color:#75715e">//多态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出内容为</p>
<pre tabindex="0"><code>hello from son
constructing grandson
hello from grandson
destructing grandson
bye from myclass
</code></pre><h2 id="4多态的实现原理">4.多态的实现原理</h2>
<h3 id="问题引入">问题引入</h3>
<p>“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫做 <strong>“动态联编”</strong>。这是如何实现的呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Print</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base:Print&#34;</span>;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Base{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Print</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived:Print&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	Derived d;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(Base) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(Derived);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此处的输出内容，在视频中老师的讲解下，理论输出为 <code>4,8</code>，实际输出为 <code>8,12</code>。</p>
<hr>
<p>但事实上在 DEV C++ 5.11 中程序运行得到的结果为 <code>16,16</code> 。该程序的输出取决于编译器的实现和系统位数（32 位或 64 位），但根据常见 64 位系统的行为分析：</p>
<ol>
<li>
<p>​<strong>基类 <code>Base</code> 的大小</strong>​：</p>
<ul>
<li>虚函数表指针（vptr）：<code>8字节</code>（64 位系统指针大小）</li>
<li>成员变量 <code>int i</code>：<code>4字节</code></li>
<li>内存对齐填充：<code>4字节</code>（为了对齐到 8 字节边界）</li>
<li>​<strong>总计</strong>​：<code>8 + 4 + 4 = 16字节</code></li>
</ul>
</li>
<li>
<p>​<strong>派生类 <code>Derived</code> 的大小</strong>​：</p>
<ul>
<li>继承自 <code>Base</code> 的虚函数表指针（vptr）：<code>8字节</code></li>
<li>继承自 <code>Base</code> 的成员变量 <code>int i</code>：<code>4字节</code></li>
<li>新增成员变量 <code>int n</code>：<code>4字节</code></li>
<li>​<strong>总计</strong>​：<code>8 + 4 + 4 = 16字节</code>（无需额外填充，总大小已是 8 的倍数）</li>
</ul>
</li>
</ol>
<p>​<strong>其他可能性</strong>​：</p>
<ul>
<li>​<strong>32 位系统</strong>​：输出 <code>8,12</code>（vptr 占 4 字节，<code>int</code> 占 4 字节，派生类添加的 <code>int</code> 导致总大小 12）。</li>
<li>​<strong>编译器优化</strong>​：某些编译器可能减少填充，但主流通用编译器（如 GCC、Clang、MSVC）在 64 位模式下通常结果为 <code>16,16</code>。</li>
</ul>
<p>​<strong>总结</strong>​：在标准 64 位环境下，程序输出为 <code>16,16</code>。</p>
<hr>
<h3 id="多态实现的关键虚函数表">多态实现的关键——虚函数表</h3>
<p>每一个有虚函数的类（或有虚函数的类的派生类）都有一个<strong>虚函数表</strong>，该类的<strong>任何对象</strong>中都存放了虚函数表的指针。虚函数表中列出了该类的虚函数地址。<strong>多出来的 4 个字节就是用来放虚函数表的地址的。</strong></p>
<p>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。</p>
<p>也正因如此，含有多态的程序在执行的过程中会有额外的时间和空间上的开销。(存表和查表的开销)</p>
<h3 id="虚函数表地址验证">虚函数表地址验证</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Func(){
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A::Func&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> A{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Func(){
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B::Func&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	A a;
</span></span><span style="display:flex;"><span>	A<span style="color:#f92672">*</span> pa<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> B();
</span></span><span style="display:flex;"><span>	pa<span style="color:#f92672">-&gt;</span>Func();<span style="color:#75715e">//64位程序指针为8字节，输出B::Func 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span> p1<span style="color:#f92672">=</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>a;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span> p2<span style="color:#f92672">=</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)pa;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>p2<span style="color:#f92672">=*</span>p1;
</span></span><span style="display:flex;"><span>	pa<span style="color:#f92672">-&gt;</span>Func();<span style="color:#75715e">//输出A::Func 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p>这段代码很好地演示了 C++ 虚函数表的底层实现机制，我们可以分几个层次来理解：</p>
<p>​<strong>类结构分析</strong>​</p>
<ul>
<li>基类 <code>A</code> 定义了一个虚函数 <code>Func()</code>，输出 &ldquo;A::Func&rdquo;</li>
<li>派生类 <code>B</code> 重写了 <code>Func()</code>，输出 &ldquo;B::Func&rdquo;</li>
<li><code>B</code> 继承自 <code>A</code>，形成继承体系</li>
</ul>
<p>​<strong>虚函数表原理</strong>​</p>
<ul>
<li>编译器会为每个包含虚函数的类生成虚函数表（vtable）</li>
<li>每个对象实例化时会包含一个隐藏的虚表指针（vptr），指向对应的虚表</li>
<li><code>A</code> 的虚表存放 <code>A::Func</code> 的地址，<code>B</code> 的虚表存放 <code>B::Func</code> 的地址</li>
</ul>
<p>​<strong>内存操作解析</strong>​</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>a;  <span style="color:#75715e">// 获取A实例的虚表指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)pa;  <span style="color:#75715e">// 获取B实例的虚表指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>p1;  <span style="color:#75715e">// 用A的虚表覆盖B的虚表
</span></span></span></code></pre></div><ul>
<li>这里利用了 64 位系统中指针占 8 字节的特性（<code>long long</code> 也是 8 字节）</li>
<li>通过直接操作内存，修改了 <code>B</code> 实例的虚表指针，使其指向 <code>A</code> 的虚表</li>
</ul>
<p><strong>运行结果解释</strong>​</p>
<ul>
<li>第一次调用 <code>pa-&gt;Func()</code>：正常输出 <code>B::Func</code>，符合多态特性</li>
<li>修改虚表指针后：<code>pa</code> 实际指向的对象虽然还是 <code>B</code> 类型，但虚表已被替换为 <code>A</code> 的，故输出 <code>A::Func</code></li>
</ul>
<p><strong>重要概念验证</strong>​</p>
<ul>
<li>虚函数调用是通过查虚表实现的动态绑定，而非通过对象本身的类型</li>
<li>虚表指针存在于对象实例的内存起始位置</li>
<li>多态的实现依赖于虚表机制，而不是简单的类型继承</li>
</ul>
<p><strong>注意事项</strong>​</p>
<ul>
<li>这种直接操作内存的方式在实际开发中非常危险，会破坏面向对象特性</li>
<li>不同编译器实现可能有差异，此处演示的是典型实现方式</li>
<li>32 位系统需要将 <code>long long</code> 改为 <code>long</code>（4 字节）</li>
</ul>
<p>这个例子深刻揭示了 C++ 多态性的底层实现，帮助我们理解：虚函数调用实际上是通过虚表指针间接跳转的，当修改了虚表指针后，即使对象类型未变，虚函数的行为也会改变。这是实现运行时多态的关键机制。</p>
<hr>
<h2 id="5虚析构函数纯虚函数和抽象类">5.虚析构函数、纯虚函数和抽象类</h2>
<h3 id="虚析构函数">虚析构函数</h3>
<p>通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数。</p>
<ul>
<li>但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。</li>
</ul>
<p>解决办法：把基类的<strong>析构函数声明为 <code>virtual</code></strong>。</p>
<ul>
<li>派生类的析构函数可以 <code>virtual</code> 不进行声明。</li>
<li>通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。</li>
</ul>
<p>一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。</p>
<p>注意：<strong>不允许以虚函数作为构造函数</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">son</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>son(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bye from son&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">grandson</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> son{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>grandson(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bye from grandson&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	son<span style="color:#f92672">*</span> pson;
</span></span><span style="display:flex;"><span>	pson<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> grandson();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span> pson;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}<span style="color:#75715e">//输出：bye from son，没有执行grandson::~grandson()
</span></span></span></code></pre></div><p>如果将基类的析构函数声明为 <code>virtual</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">son</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>son(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bye from son&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">grandson</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> son{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>grandson(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bye from grandson&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	son<span style="color:#f92672">*</span> pson;
</span></span><span style="display:flex;"><span>	pson<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> grandson();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span> pson;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>则会输出</p>
<pre tabindex="0"><code>bye from grandson
bye from son
</code></pre><p>执行 <code>grandson::~grandson()</code>，引起执行 <code>son::~son()</code>。</p>
<h3 id="纯虚函数和抽象类">纯虚函数和抽象类</h3>
<ul>
<li><strong>纯虚函数：没有函数体的虚函数</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Print()<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//纯虚函数，如果不是=0而是{}，也认为是有函数体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><ul>
<li><strong>包含纯虚函数的类叫抽象类</strong>
<ul>
<li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li>
<li>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>A a;<span style="color:#75715e">//错，A是抽象类，不能创建对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>A<span style="color:#f92672">*</span> pa;<span style="color:#75715e">//ok，可以定义抽象类的指针和引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pa<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> A;<span style="color:#75715e">//错误，A是抽象类，不能创建对象
</span></span></span></code></pre></div><ul>
<li><strong>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。</strong></li>
<li><strong>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中所有纯虚函数，它才能成为非抽象类。</strong>（也就是说基类中的所有纯虚函数在派生类中都有了函数体）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> f()<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//纯虚函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">g</span>(){<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>f();}<span style="color:#75715e">//ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//A(){f();}//编译错误，构造函数中不是多态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> A{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> f(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B:f()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	B b;
</span></span><span style="display:flex;"><span>	b.g();<span style="color:#75715e">//输出B:f()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
    
    <div class="post-copyright">
      <div class="copyright-info">
        <p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p>
        <p>本文链接：<a href="https://kibrac.github.io/posts/c&#43;&#43;6/">https://kibrac.github.io/posts/c&#43;&#43;6/</a></p>
      </div>
    </div>
    
    
    <div class="post-tags">
      
      <a href="/tags/c&#43;&#43;/" class="tag">#C&#43;&#43;</a>
      
    </div>
    
    
    <div class="post-navigation">
      
      <a class="prev-post" href="https://kibrac.github.io/posts/c&#43;&#43;5/">&larr; 面向对象的程序设计学习笔记 5</a>
      
      
      
    </div>
    
    
  </article>
</div>

    </main>
    
    <footer class="site-footer">
      <div class="footer-container">
  <div class="footer-content">
    <div class="footer-info">
      <p class="copyright">&copy; 2025 Kibrac&#39;s Blog</p>
      
      
    </div>
    
    
  </div>
  
  <div class="footer-bottom">
    <div class="footer-links">
      
      
      <span class="footer-separator">|</span>
      <span>使用 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> 构建</span>
      <span class="footer-separator">|</span>
      <span>主题 <a href="#" rel="noopener noreferrer">PointFive</a></span>
    </div>
</div>
    </footer>
  </div>
  
  
  <script src="https://kibrac.github.io/js/main.js"></script>
  <script src="https://kibrac.github.io/js/code-block.js"></script>
  
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError: false
      });
    });
  </script>
  
  
  
  
</body>
</html>