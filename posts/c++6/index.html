<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>面向对象的程序设计学习笔记 6 | Kibrac's Blog</title>
<meta name=keywords content="C++"><meta name=description content="第六章 多态"><meta name=author content="Kibrac"><link rel=canonical href=http://localhost:1313/posts/c++6/><link crossorigin=anonymous href=/assets/css/stylesheet.ae3d277e69647c027e65dd7c785748f912a9be2d37da0061b9ff15a5d7fafb7b.css integrity="sha256-rj0nfmlkfAJ+Zd18eFdI+RKpvi032gBhuf8Vpdf6+3s=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:1313/posts/c++6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/c++6/"><meta property="og:site_name" content="Kibrac's Blog"><meta property="og:title" content="面向对象的程序设计学习笔记 6"><meta property="og:description" content="第六章 多态"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-15T21:57:01+08:00"><meta property="article:modified_time" content="2025-05-15T21:57:01+08:00"><meta property="article:tag" content="C++"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="面向对象的程序设计学习笔记 6"><meta name=twitter:description content="第六章 多态"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"面向对象的程序设计学习笔记 6","item":"http://localhost:1313/posts/c++6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"面向对象的程序设计学习笔记 6","name":"面向对象的程序设计学习笔记 6","description":"第六章 多态","keywords":["C++"],"articleBody":"课程链接：程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\n1.虚函数和多态的基本概念 虚函数 在类的定义中，前面有 virtual 关键字的成员函数就是虚函数。 class base{ virtual int get(); }; int base::get(){} virtual 关键字只用在类定义里的函数声明中，写函数体时不用。 构造函数和静态成员函数不能是虚函数。（关于静态成员函数参考第三章 类和对象提高） 多态的表现形式一 派生类的指针可以赋给基类指针。 通过基类指针调用基类和派生类中的同名虚函数时： 若该指针指向一个基类的对象，那么被调用的是基类的虚函数； 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。 这种机制就叫做“多态”。\nclass CBase{ public: virtual void SomeVirtualFunction(){} }; class CDerived:public CBase{ public: virtual void SomeVirtualFunction(){} }; int main(){ CDerived ODerived; CBase* p=\u0026ODerived; p-\u003eSomeVirtualFunction();//调用哪个虚函数取决于p指向哪种类型的对象 return 0; } 多态的表现形式二 派生类的对象可以赋给基类引用。 通过基类引用来调用基类和派生类中的同名虚函数时： 若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数； 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。 这种机制也叫做“多态”。\nclass CBase{ public: virtual void SomeVirtualFunction(){} }; class CDerived:public CBase{ public: virtual void SomeVirtualFunction(){} }; int main(){ CDerived ODerived; CBase\u0026 r=ODerived; r.SomeVirtualFunction();//调用哪个虚函数取决于r引用哪种类型的对象 return 0; } 多态的简单示例 #include using namespace std; class A{ public: virtual void Print(){cout \u003c\u003c \"A::Print\" \u003c\u003c endl;} }; class B:public A{ public: virtual void Print(){cout \u003c\u003c \"B::Print\" \u003c\u003c endl;} }; class D:public A{ public: virtual void Print(){cout \u003c\u003c \"D::Print\" \u003c\u003c endl;} }; class E:public B{ public: virtual void Print(){cout \u003c\u003c \"E::Print\" \u003c\u003c endl;} }; int main(){ A a;B b;D d;E e; A* pa=\u0026a;B* pb=\u0026b; D* pd=\u0026d;E* pe=\u0026e; pa-\u003ePrint(); pa=pb; pa-\u003ePrint(); pa=pd; pa-\u003ePrint(); pa=pe; pa-\u003ePrint(); return 0; } 输出内容为\nA::Print B::Print D::Print E::Print 在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。\n2.多态实例：魔法门之英雄无敌 非多态实现方式 基本思路\n为每个怪物类编写 Attack、FightBack 和 Hurted 成员函数。 Attack 函数表现攻击动作，攻击某个怪物，并调用被攻击怪物的 Hurted 函数，以减少被攻击怪物的生命值，同时也调用被攻击怪物的 FightBack 函数，遭受被攻击怪物反击。 Hurted 函数减少自身生命值，并表现受伤动作。 FightBack 函数表现反击动作，并调用被反击对象的 Hurted 函数，使被反击对象受伤。 设置基类 CCreature，并且使 CDragon、CWolf 等其他类都从 CCreature 派生而来。 class CCreature{ protected: int nPower;//攻击力 int nLifeValue;//生命值 }; class CDragon:public CCreature{ public: void Attack(CWolf* pWolf){ ......//表现攻击动作的代码 pWolf-\u003eHurted(nPower); pWolf-\u003eFightBack(this); } void Attack(CGhost* pGhost){ ......//表现攻击动作的代码 pGhost-\u003eHurted(nPower); pGhost-\u003eFightBack(this); } void Hurted(int nPower){ ......//表现受伤动作的代码 nLifeValue-=nPower; } void FightBack(CWolf* pWolf){ ......//表现反击动作的代码 pWolf-\u003eHurted(nPower/2);//这里只是象征性地对反击的攻击力进行了调整 } void FightBack(CGhost* pWolf){ ......//表现反击动作的代码 pGhost-\u003eHurted(nPower/2); } }; 有 n 种怪物，CDragon 类中就会有 n 个 Attack 成员函数，以及 n 个 FightBack 成员函数等。对于其他类也是如此。 那么如果游戏版本升级，增加了新的怪物雷鸟 CThunderBird，则程序改动就会较大，不光要新增怪物类，其他所有的类都需要增加两个成员函数 ``` void Attack(CThunderBird* pThunderBird); void FightBack(CThunderBird* pThunderBird); 多态实现方式 基类只有一个 Attack 成员函数，也只有一个 FightBack 成员函数；所有 CCreature 的派生类也是这样。 class CCreature{//基类CCreature protected: int m_nLifeValue,m_nPower; public: virtual void Attack(CCreature* pCreature){} virtual void Hurted(int nPower){} virtual void FightBack(CCreature* pCreature){} }; class CDragon:public CCreature{//派生类CDragon public: virtual void Attack(CCreature* pCreature); virtual void Hurted(int nPower); virtual void FightBack(CCreature* pCreature); }; void CDragon::Attack(CCreature* p){ ......//表现攻击动作的代码 p-\u003eHurted(m_nPower);//多态 p-\u003eFightBack(this);//多态 } void CDragon::Hurted(int nPower){ ......//表现受伤动作的代码 m_nLifeValue-=nPower; } void CDragon::FightBack(CCreature* p){ ......//表现反击动作的代码 p-\u003eHurted(m_nPower/2);//多态 } 在多态的写法中，只需要添加新类 CThunderBird，不需要在已有的类里专门为新怪物增加成员函数，已有的类可以原封不动。 原理\nCDragon Dragon;CWolf Wolf; CGhost Ghost;CThunderBird Bird; Dragon.Attack(\u0026Wolf);//(1) Dragon.Attack(\u0026Ghost);//(2) Dragon.Attack(\u0026Bird);//(3) 根据多态的规则，上面的（1）（2）（3）进入到 CDragon::Attack 函数后，能分别调用 CWolf::Hurted、CGhost::Hurted、CBird::Hurted。\n3.多态实例：几何形体处理程序 几何形体处理程序 情景要求\n几何形体处理程序：输入若干个几何形体的参数，要求按面积排序输出，输出时要指明形状。\nInput 第一行是几何形体数目n（不超过100），下面有n行，每行以一个字母开头。 若字母为R，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高； 若字母为C，则代表一个圆，本行后面跟着一个整数代表其半径； 若字母为T，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度。 Output 按面积从小到大依次输出每个几何形体的种类及面积。每行一个几何形体，输出格式为 形体面积:面积 样例\nSample Input 3 R 3 5 C 9 T 3 4 5 Sample Output Triangle:6 Rectangle:15 Circle:254.34 完整代码如下\n#include #include #include using namespace std; class CShape{ public: virtual double Area()=0;//纯虚数：连函数体都没有的虚函数 virtual void PrintInfo()=0; }; class CRectangle:public CShape{ public: int w,h; virtual double Area(); virtual void PrintInfo(); }; class CCircle:public CShape{ public: int r; virtual double Area(); virtual void PrintInfo(); }; class CTriangle:public CShape{ public: int a,b,c; virtual double Area(); virtual void PrintInfo(); }; double CRectangle::Area(){ return w*h; } void CRectangle::PrintInfo(){ cout \u003c\u003c \"Rectangle:\" \u003c\u003c Area() \u003c\u003c endl; } double CCircle::Area(){ return 3.14*r*r; } void CCircle::PrintInfo(){ cout \u003c\u003c \"Circle:\" \u003c\u003c Area() \u003c\u003c endl; } double CTriangle::Area(){ double p=(a+b+c)/2.0; return sqrt(p*(p-a)*(p-b)*(p-c)); } void CTriangle::PrintInfo(){ cout \u003c\u003c \"Triangle:\" \u003c\u003c Area() \u003c\u003c endl; } CShape* pShapes[100]; int MyCompare(const void* s1,const void* s2){ double a1,a2; CShape**p1;//s1、s2是void*，不可写*s1来获取s1指向的内容 CShape**p2; p1=(CShape**)s1;//s1、s2指向pShapes数组中的元素，数组元素的类型是CShape* p2=(CShape**)s2;//故p1、p2都是指向指针的指针，类型为CShape** a1=(*p1)-\u003eArea();//*p1的类型是CShape*，是基类指针，故此句为多态 a2=(*p2)-\u003eArea(); if(a1\u003ca2) return -1; else if(a2\u003ca1) return 1; else return 0; } int main(){ int i;int n; CRectangle* pr;CCircle* pc;CTriangle* pt; cin \u003e\u003e n; for(i=0;i\u003cn;i++){ char c; cin \u003e\u003e c; switch(c){ case 'R': pr=new CRectangle(); cin \u003e\u003e pr-\u003ew \u003e\u003e pr-\u003eh; pShapes[i]=pr; break; case 'C': pc=new CCircle(); cin \u003e\u003e pc-\u003er; pShapes[i]=pc; break; case 'T': pt=new CTriangle(); cin \u003e\u003e pt-\u003ea \u003e\u003e pt-\u003eb \u003e\u003e pt-\u003ec; pShapes[i]=pt; break; } } qsort(pShapes,n,sizeof(CShape*),MyCompare); for(i=0;i\u003cn;i++) pShapes[i]-\u003ePrintInfo(); return 0; } 如果添加新的几何形体，比如五边形，则只需要从 CShape 派生出 CPentagon，以及在 main 中的 switch 语句中增加一个 case，其余部分都不变，体现了多态在提高程序可扩充性方面具有良好作用。\n用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组就能对各个派生类对象做各种操作，是很常用的做法。 多态的又一例子 class Base{ public: void fun1(){fun2();}//等价于void fun1(){this-\u003efun2();} //而this是基类指针，fun2是虚函数，所以是多态 virtual void fun2(){cout \u003c\u003c \"Base::fun2()\" \u003c\u003c endl;} }; class Derived:public Base{ public: virtual void fun2(){cout \u003c\u003c \"Derived:fun2()\" \u003c\u003c endl;} }; int main(){ Derived d; Base* pBase=\u0026d; pBase-\u003efun1(); return 0; }//输出：Derived:fun2() 在非构造函数，非析构函数的成员函数中调用虚函数，是多态！！！ 在构造函数和析构函数中调用虚函数，不是多态。 编译时即可确定调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。 构造函数和析构函数中调用虚函数举例 #include using namespace std; class myclass{ public: virtual void hello(){cout \u003c\u003c \"hello from myclass\" \u003c\u003c endl;} virtual void bye(){cout \u003c\u003c \"bye from myclass\" \u003c\u003c endl;} }; class son:public myclass{ public: void hello(){cout \u003c\u003c \"hello from son\" \u003c\u003c endl;} son(){hello();} ~son(){bye();} };//派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数 class grandson:public son{ public: void hello(){cout \u003c\u003c \"hello from grandson\" \u003c\u003c endl;} void bye(){cout \u003c\u003c \"bye from grandson\" \u003c\u003c endl;} grandson(){cout \u003c\u003c \"constructing grandson\" \u003c\u003c endl;} ~grandson(){cout \u003c\u003c \"destructing grandson\" \u003c\u003c endl;} }; int main(){ grandson gson; son* pson; pson=\u0026gson; pson-\u003ehello();//多态 return 0; } 输出内容为\nhello from son constructing grandson hello from grandson destructing grandson bye from myclass 4.多态的实现原理 问题引入 “多态”的关键在于通过基类指针或引用调用一个虚函数时，编译不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫做 “动态联编”。这是如何实现的呢？\n#include using namespace std; class Base{ public: int i; virtual void Print(){cout \u003c\u003c \"Base:Print\";} }; class Derived:public Base{ public: int n; virtual void Print(){cout \u003c\u003c \"Derived:Print\" \u003c\u003c endl;} }; int main(){ Derived d; cout \u003c\u003c sizeof(Base) \u003c\u003c \",\" \u003c\u003c sizeof(Derived); return 0; } 此处的输出内容，在视频中老师的讲解下，理论输出为 4,8，实际输出为 8,12。\n但事实上在 DEV C++ 5.11 中程序运行得到的结果为 16,16 。该程序的输出取决于编译器的实现和系统位数（32 位或 64 位），但根据常见 64 位系统的行为分析：\n​基类 Base 的大小​：\n虚函数表指针（vptr）：8字节（64 位系统指针大小） 成员变量 int i：4字节 内存对齐填充：4字节（为了对齐到 8 字节边界） ​总计​：8 + 4 + 4 = 16字节 ​派生类 Derived 的大小​：\n继承自 Base 的虚函数表指针（vptr）：8字节 继承自 Base 的成员变量 int i：4字节 新增成员变量 int n：4字节 ​总计​：8 + 4 + 4 = 16字节（无需额外填充，总大小已是 8 的倍数） ​其他可能性​：\n​32 位系统​：输出 8,12（vptr 占 4 字节，int 占 4 字节，派生类添加的 int 导致总大小 12）。 ​编译器优化​：某些编译器可能减少填充，但主流通用编译器（如 GCC、Clang、MSVC）在 64 位模式下通常结果为 16,16。 ​总结​：在标准 64 位环境下，程序输出为 16,16。\n多态实现的关键——虚函数表 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都存放了虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的 4 个字节就是用来放虚函数表的地址的。\n多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。\n也正因如此，含有多态的程序在执行的过程中会有额外的时间和空间上的开销。(存表和查表的开销)\n虚函数表地址验证 #include using namespace std; class A{ public: virtual void Func(){ cout \u003c\u003c \"A::Func\" \u003c\u003c endl; } }; class B:public A{ public: virtual void Func(){ cout \u003c\u003c \"B::Func\" \u003c\u003c endl; } }; int main(){ A a; A* pa=new B(); pa-\u003eFunc();//64位程序指针为8字节，输出B::Func long long* p1=(long long*)\u0026a; long long* p2=(long long*)pa; *p2=*p1; pa-\u003eFunc();//输出A::Func return 0; } 这段代码很好地演示了 C++ 虚函数表的底层实现机制，我们可以分几个层次来理解：\n​类结构分析​\n基类 A 定义了一个虚函数 Func()，输出 “A::Func” 派生类 B 重写了 Func()，输出 “B::Func” B 继承自 A，形成继承体系 ​虚函数表原理​\n编译器会为每个包含虚函数的类生成虚函数表（vtable） 每个对象实例化时会包含一个隐藏的虚表指针（vptr），指向对应的虚表 A 的虚表存放 A::Func 的地址，B 的虚表存放 B::Func 的地址 ​内存操作解析​\nlong long* p1 = (long long*)\u0026a; // 获取A实例的虚表指针 long long* p2 = (long long*)pa; // 获取B实例的虚表指针 *p2 = *p1; // 用A的虚表覆盖B的虚表 这里利用了 64 位系统中指针占 8 字节的特性（long long 也是 8 字节） 通过直接操作内存，修改了 B 实例的虚表指针，使其指向 A 的虚表 运行结果解释​\n第一次调用 pa-\u003eFunc()：正常输出 B::Func，符合多态特性 修改虚表指针后：pa 实际指向的对象虽然还是 B 类型，但虚表已被替换为 A 的，故输出 A::Func 重要概念验证​\n虚函数调用是通过查虚表实现的动态绑定，而非通过对象本身的类型 虚表指针存在于对象实例的内存起始位置 多态的实现依赖于虚表机制，而不是简单的类型继承 注意事项​\n这种直接操作内存的方式在实际开发中非常危险，会破坏面向对象特性 不同编译器实现可能有差异，此处演示的是典型实现方式 32 位系统需要将 long long 改为 long（4 字节） 这个例子深刻揭示了 C++ 多态性的底层实现，帮助我们理解：虚函数调用实际上是通过虚表指针间接跳转的，当修改了虚表指针后，即使对象类型未变，虚函数的行为也会改变。这是实现运行时多态的关键机制。\n5.虚析构函数、纯虚函数和抽象类 虚析构函数 通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数。\n但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。 解决办法：把基类的析构函数声明为 virtual。\n派生类的析构函数可以 virtual 不进行声明。 通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。 一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。\n注意：不允许以虚函数作为构造函数。\n#include using namespace std; class son{ public: ~son(){cout \u003c\u003c \"bye from son\" \u003c\u003c endl;} }; class grandson:public son{ public: ~grandson(){cout \u003c\u003c \"bye from grandson\" \u003c\u003c endl;} }; int main(){ son* pson; pson=new grandson(); delete pson; return 0; }//输出：bye from son，没有执行grandson::~grandson() 如果将基类的析构函数声明为 virtual\nclass son{ public: virtual ~son(){cout \u003c\u003c \"bye from son\" \u003c\u003c endl;} }; class grandson:public son{ public: ~grandson(){cout \u003c\u003c \"bye from grandson\" \u003c\u003c endl;} }; int main(){ son* pson; pson=new grandson(); delete pson; return 0; } 则会输出\nbye from grandson bye from son 执行 grandson::~grandson()，引起执行 son::~son()。\n纯虚函数和抽象类 纯虚函数：没有函数体的虚函数 class A{ private: int a; public: virtual void Print()=0;//纯虚函数，如果不是=0而是{}，也认为是有函数体 }; 包含纯虚函数的类叫抽象类 抽象类只能作为基类来派生新类使用，不能创建抽象类的对象 抽象类的指针和引用可以指向由抽象类派生出来的类的对象 A a;//错，A是抽象类，不能创建对象 A* pa;//ok，可以定义抽象类的指针和引用 pa=new A;//错误，A是抽象类，不能创建对象 在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中所有纯虚函数，它才能成为非抽象类。（也就是说基类中的所有纯虚函数在派生类中都有了函数体） #include using namespace std; class A{ public: virtual void f()=0;//纯虚函数 void g(){this-\u003ef();}//ok //A(){f();}//编译错误，构造函数中不是多态 }; class B:public A{ public: void f(){cout \u003c\u003c \"B:f()\" \u003c\u003c endl;} }; int main(){ B b; b.g();//输出B:f() return 0; } ","wordCount":"5210","inLanguage":"zh","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-05-15T21:57:01+08:00","dateModified":"2025-05-15T21:57:01+08:00","author":{"@type":"Person","name":"Kibrac"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/c++6/"},"publisher":{"@type":"Organization","name":"Kibrac's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Kibrac's Blog (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Kibrac's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=归档><span>归档</span></a></li><li><a href=http://localhost:1313/categories/ title=分类><span>分类</span></a></li><li><a href=http://localhost:1313/tags/ title=标签><span>标签</span></a></li><li><a href=http://localhost:1313/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">面向对象的程序设计学习笔记 6</h1><div class=post-description>第六章 多态</div><div class=post-meta><span title='2025-05-15 21:57:01 +0800 CST'>五月 15, 2025</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;5210 字&nbsp;·&nbsp;Kibrac</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1虚函数和多态的基本概念>1.虚函数和多态的基本概念</a><ul><li><a href=#虚函数>虚函数</a></li><li><a href=#多态的表现形式一>多态的表现形式一</a></li><li><a href=#多态的表现形式二>多态的表现形式二</a></li><li><a href=#多态的简单示例>多态的简单示例</a></li></ul></li><li><a href=#2多态实例魔法门之英雄无敌>2.多态实例：魔法门之英雄无敌</a><ul><li><a href=#非多态实现方式>非多态实现方式</a></li><li><a href=#多态实现方式>多态实现方式</a></li></ul></li><li><a href=#3多态实例几何形体处理程序>3.多态实例：几何形体处理程序</a><ul><li><a href=#几何形体处理程序>几何形体处理程序</a></li><li><a href=#多态的又一例子>多态的又一例子</a></li><li><a href=#构造函数和析构函数中调用虚函数举例>构造函数和析构函数中调用虚函数举例</a></li></ul></li><li><a href=#4多态的实现原理>4.多态的实现原理</a><ul><li><a href=#问题引入>问题引入</a></li><li><a href=#多态实现的关键虚函数表>多态实现的关键——虚函数表</a></li><li><a href=#虚函数表地址验证>虚函数表地址验证</a></li></ul></li><li><a href=#5虚析构函数纯虚函数和抽象类>5.虚析构函数、纯虚函数和抽象类</a><ul><li><a href=#虚析构函数>虚析构函数</a></li><li><a href=#纯虚函数和抽象类>纯虚函数和抽象类</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>课程链接：<a href=https://www.icourse163.org/course/PKU-1002029030>程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)</a></p><h2 id=1虚函数和多态的基本概念>1.虚函数和多态的基本概念<a hidden class=anchor aria-hidden=true href=#1虚函数和多态的基本概念>#</a></h2><h3 id=虚函数>虚函数<a hidden class=anchor aria-hidden=true href=#虚函数>#</a></h3><ul><li>在类的定义中，前面有 <code>virtual</code> 关键字的成员函数就是虚函数。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>int</span> <span class=nf>get</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>base</span><span class=o>::</span><span class=n>get</span><span class=p>(){}</span>
</span></span></code></pre></div><ul><li><code>virtual</code> 关键字只用在类定义里的函数声明中，写函数体时不用。</li><li>构造函数和静态成员函数不能是虚函数。（关于静态成员函数参考第三章 类和对象提高）</li></ul><h3 id=多态的表现形式一>多态的表现形式一<a hidden class=anchor aria-hidden=true href=#多态的表现形式一>#</a></h3><ul><li>派生类的指针可以赋给基类指针。</li><li>通过基类指针调用基类和派生类中的同名<strong>虚函数</strong>时：<ul><li>若该指针指向一个基类的对象，那么被调用的是基类的虚函数；</li><li>若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</li></ul></li></ul><p>这种机制就叫做“<strong>多态</strong>”。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CBase</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>SomeVirtualFunction</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CDerived</span><span class=o>:</span><span class=k>public</span> <span class=n>CBase</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>SomeVirtualFunction</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>CDerived</span> <span class=n>ODerived</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>CBase</span><span class=o>*</span> <span class=n>p</span><span class=o>=&amp;</span><span class=n>ODerived</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>p</span><span class=o>-&gt;</span><span class=n>SomeVirtualFunction</span><span class=p>();</span><span class=c1>//调用哪个虚函数取决于p指向哪种类型的对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=多态的表现形式二>多态的表现形式二<a hidden class=anchor aria-hidden=true href=#多态的表现形式二>#</a></h3><ul><li>派生类的对象可以赋给基类引用。</li><li>通过基类引用来调用基类和派生类中的同名<strong>虚函数</strong>时：<ul><li>若该引用引用的是一个基类的对象，那么被调用的是基类的<strong>虚函数</strong>；</li><li>若该引用引用的是一个派生类的对象，那么被调用的是派生类的<strong>虚函数</strong>。</li></ul></li></ul><p>这种机制也叫做“<strong>多态</strong>”。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CBase</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>SomeVirtualFunction</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CDerived</span><span class=o>:</span><span class=k>public</span> <span class=n>CBase</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>SomeVirtualFunction</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>CDerived</span> <span class=n>ODerived</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>CBase</span><span class=o>&amp;</span> <span class=n>r</span><span class=o>=</span><span class=n>ODerived</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>r</span><span class=p>.</span><span class=n>SomeVirtualFunction</span><span class=p>();</span><span class=c1>//调用哪个虚函数取决于r引用哪种类型的对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=多态的简单示例>多态的简单示例<a hidden class=anchor aria-hidden=true href=#多态的简单示例>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Print</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;A::Print&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=o>:</span><span class=k>public</span> <span class=n>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Print</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;B::Print&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D</span><span class=o>:</span><span class=k>public</span> <span class=n>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Print</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;D::Print&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>E</span><span class=o>:</span><span class=k>public</span> <span class=n>B</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Print</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;E::Print&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span> <span class=n>a</span><span class=p>;</span><span class=n>B</span> <span class=n>b</span><span class=p>;</span><span class=n>D</span> <span class=n>d</span><span class=p>;</span><span class=n>E</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span><span class=o>*</span> <span class=n>pa</span><span class=o>=&amp;</span><span class=n>a</span><span class=p>;</span><span class=n>B</span><span class=o>*</span> <span class=n>pb</span><span class=o>=&amp;</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>D</span><span class=o>*</span> <span class=n>pd</span><span class=o>=&amp;</span><span class=n>d</span><span class=p>;</span><span class=n>E</span><span class=o>*</span> <span class=n>pe</span><span class=o>=&amp;</span><span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pa</span><span class=o>-&gt;</span><span class=n>Print</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>pa</span><span class=o>=</span><span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pa</span><span class=o>-&gt;</span><span class=n>Print</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>pa</span><span class=o>=</span><span class=n>pd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pa</span><span class=o>-&gt;</span><span class=n>Print</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>pa</span><span class=o>=</span><span class=n>pe</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pa</span><span class=o>-&gt;</span><span class=n>Print</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出内容为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>A::Print
</span></span><span class=line><span class=cl>B::Print
</span></span><span class=line><span class=cl>D::Print
</span></span><span class=line><span class=cl>E::Print
</span></span></code></pre></div><p>在面向对象的程序设计中使用多态，能够增强程序的<strong>可扩充性</strong>，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。</p><h2 id=2多态实例魔法门之英雄无敌>2.多态实例：魔法门之英雄无敌<a hidden class=anchor aria-hidden=true href=#2多态实例魔法门之英雄无敌>#</a></h2><h3 id=非多态实现方式>非多态实现方式<a hidden class=anchor aria-hidden=true href=#非多态实现方式>#</a></h3><p><strong>基本思路</strong></p><ul><li>为每个怪物类编写 <code>Attack</code>、<code>FightBack</code> 和 <code>Hurted</code> 成员函数。</li><li><code>Attack</code> 函数表现攻击动作，攻击某个怪物，并调用被攻击怪物的 <code>Hurted</code> 函数，以减少被攻击怪物的生命值，同时也调用被攻击怪物的 <code>FightBack</code> 函数，遭受被攻击怪物反击。</li><li><code>Hurted</code> 函数减少自身生命值，并表现受伤动作。</li><li><code>FightBack</code> 函数表现反击动作，并调用被反击对象的 <code>Hurted</code> 函数，使被反击对象受伤。</li><li>设置基类 <code>CCreature</code>，并且使 <code>CDragon</code>、<code>CWolf</code> 等其他类都从 <code>CCreature</code> 派生而来。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CCreature</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>nPower</span><span class=p>;</span><span class=c1>//攻击力
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kt>int</span> <span class=n>nLifeValue</span><span class=p>;</span><span class=c1>//生命值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CDragon</span><span class=o>:</span><span class=k>public</span> <span class=n>CCreature</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=n>Attack</span><span class=p>(</span><span class=n>CWolf</span><span class=o>*</span> <span class=n>pWolf</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=p>......</span><span class=c1>//表现攻击动作的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>pWolf</span><span class=o>-&gt;</span><span class=n>Hurted</span><span class=p>(</span><span class=n>nPower</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>pWolf</span><span class=o>-&gt;</span><span class=n>FightBack</span><span class=p>(</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=nf>Attack</span><span class=p>(</span><span class=n>CGhost</span><span class=o>*</span> <span class=n>pGhost</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=p>......</span><span class=c1>//表现攻击动作的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>pGhost</span><span class=o>-&gt;</span><span class=n>Hurted</span><span class=p>(</span><span class=n>nPower</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>pGhost</span><span class=o>-&gt;</span><span class=n>FightBack</span><span class=p>(</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=nf>Hurted</span><span class=p>(</span><span class=kt>int</span> <span class=n>nPower</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=p>......</span><span class=c1>//表现受伤动作的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>nLifeValue</span><span class=o>-=</span><span class=n>nPower</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=nf>FightBack</span><span class=p>(</span><span class=n>CWolf</span><span class=o>*</span> <span class=n>pWolf</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=p>......</span><span class=c1>//表现反击动作的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>pWolf</span><span class=o>-&gt;</span><span class=n>Hurted</span><span class=p>(</span><span class=n>nPower</span><span class=o>/</span><span class=mi>2</span><span class=p>);</span><span class=c1>//这里只是象征性地对反击的攻击力进行了调整
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=nf>FightBack</span><span class=p>(</span><span class=n>CGhost</span><span class=o>*</span> <span class=n>pWolf</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=p>......</span><span class=c1>//表现反击动作的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>pGhost</span><span class=o>-&gt;</span><span class=n>Hurted</span><span class=p>(</span><span class=n>nPower</span><span class=o>/</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>有 n 种怪物，<code>CDragon</code> 类中就会有 n 个 <code>Attack</code> 成员函数，以及 n 个 <code>FightBack</code> 成员函数等。对于其他类也是如此。</li><li>那么如果游戏版本升级，增加了新的怪物雷鸟 <code>CThunderBird</code>，则程序改动就会较大，不光要新增怪物类，其他所有的类都需要增加两个成员函数 ```</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Attack</span><span class=p>(</span><span class=n>CThunderBird</span><span class=o>*</span> <span class=n>pThunderBird</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FightBack</span><span class=p>(</span><span class=n>CThunderBird</span><span class=o>*</span> <span class=n>pThunderBird</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=多态实现方式>多态实现方式<a hidden class=anchor aria-hidden=true href=#多态实现方式>#</a></h3><ul><li>基类只有一个 <code>Attack</code> 成员函数，也只有一个 <code>FightBack</code> 成员函数；所有 <code>CCreature</code> 的派生类也是这样。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CCreature</span><span class=p>{</span><span class=c1>//基类CCreature
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>m_nLifeValue</span><span class=p>,</span><span class=n>m_nPower</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Attack</span><span class=p>(</span><span class=n>CCreature</span><span class=o>*</span> <span class=n>pCreature</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Hurted</span><span class=p>(</span><span class=kt>int</span> <span class=n>nPower</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>FightBack</span><span class=p>(</span><span class=n>CCreature</span><span class=o>*</span> <span class=n>pCreature</span><span class=p>){}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CDragon</span><span class=o>:</span><span class=k>public</span> <span class=n>CCreature</span><span class=p>{</span><span class=c1>//派生类CDragon
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Attack</span><span class=p>(</span><span class=n>CCreature</span><span class=o>*</span> <span class=n>pCreature</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Hurted</span><span class=p>(</span><span class=kt>int</span> <span class=n>nPower</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>FightBack</span><span class=p>(</span><span class=n>CCreature</span><span class=o>*</span> <span class=n>pCreature</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>CDragon</span><span class=o>::</span><span class=n>Attack</span><span class=p>(</span><span class=n>CCreature</span><span class=o>*</span> <span class=n>p</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=p>......</span><span class=c1>//表现攻击动作的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>p</span><span class=o>-&gt;</span><span class=n>Hurted</span><span class=p>(</span><span class=n>m_nPower</span><span class=p>);</span><span class=c1>//多态
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>p</span><span class=o>-&gt;</span><span class=n>FightBack</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=c1>//多态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>CDragon</span><span class=o>::</span><span class=n>Hurted</span><span class=p>(</span><span class=kt>int</span> <span class=n>nPower</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=p>......</span><span class=c1>//表现受伤动作的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>m_nLifeValue</span><span class=o>-=</span><span class=n>nPower</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>CDragon</span><span class=o>::</span><span class=n>FightBack</span><span class=p>(</span><span class=n>CCreature</span><span class=o>*</span> <span class=n>p</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=p>......</span><span class=c1>//表现反击动作的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>p</span><span class=o>-&gt;</span><span class=n>Hurted</span><span class=p>(</span><span class=n>m_nPower</span><span class=o>/</span><span class=mi>2</span><span class=p>);</span><span class=c1>//多态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>在多态的写法中，只需要添加新类 <code>CThunderBird</code>，不需要在已有的类里专门为新怪物增加成员函数，<strong>已有的类可以原封不动</strong>。</li></ul><p><strong>原理</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CDragon</span> <span class=n>Dragon</span><span class=p>;</span><span class=n>CWolf</span> <span class=n>Wolf</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>CGhost</span> <span class=n>Ghost</span><span class=p>;</span><span class=n>CThunderBird</span> <span class=n>Bird</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Dragon</span><span class=p>.</span><span class=n>Attack</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Wolf</span><span class=p>);</span><span class=c1>//(1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Dragon</span><span class=p>.</span><span class=n>Attack</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Ghost</span><span class=p>);</span><span class=c1>//(2)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Dragon</span><span class=p>.</span><span class=n>Attack</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Bird</span><span class=p>);</span><span class=c1>//(3)
</span></span></span></code></pre></div><p>根据多态的规则，上面的（1）（2）（3）进入到 <code>CDragon::Attack</code> 函数后，能分别调用 <code>CWolf::Hurted</code>、<code>CGhost::Hurted</code>、<code>CBird::Hurted</code>。</p><h2 id=3多态实例几何形体处理程序>3.多态实例：几何形体处理程序<a hidden class=anchor aria-hidden=true href=#3多态实例几何形体处理程序>#</a></h2><h3 id=几何形体处理程序>几何形体处理程序<a hidden class=anchor aria-hidden=true href=#几何形体处理程序>#</a></h3><p><strong>情景要求</strong></p><p>几何形体处理程序：输入若干个几何形体的参数，要求按面积排序输出，输出时要指明形状。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input
</span></span><span class=line><span class=cl>第一行是几何形体数目n（不超过100），下面有n行，每行以一个字母开头。
</span></span><span class=line><span class=cl>若字母为R，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高；
</span></span><span class=line><span class=cl>若字母为C，则代表一个圆，本行后面跟着一个整数代表其半径；
</span></span><span class=line><span class=cl>若字母为T，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Output
</span></span><span class=line><span class=cl>按面积从小到大依次输出每个几何形体的种类及面积。每行一个几何形体，输出格式为
</span></span><span class=line><span class=cl>形体面积:面积
</span></span></code></pre></div><p>样例</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Sample Input
</span></span><span class=line><span class=cl>3
</span></span><span class=line><span class=cl>R 3 5
</span></span><span class=line><span class=cl>C 9
</span></span><span class=line><span class=cl>T 3 4 5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Sample Output
</span></span><span class=line><span class=cl>Triangle:6
</span></span><span class=line><span class=cl>Rectangle:15
</span></span><span class=line><span class=cl>Circle:254.34
</span></span></code></pre></div><p>完整代码如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;math.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CShape</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>double</span> <span class=n>Area</span><span class=p>()</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=c1>//纯虚数：连函数体都没有的虚函数 
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>PrintInfo</span><span class=p>()</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CRectangle</span><span class=o>:</span><span class=k>public</span> <span class=n>CShape</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>w</span><span class=p>,</span><span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>double</span> <span class=nf>Area</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>PrintInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CCircle</span><span class=o>:</span><span class=k>public</span> <span class=n>CShape</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>double</span> <span class=nf>Area</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>PrintInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CTriangle</span><span class=o>:</span><span class=k>public</span> <span class=n>CShape</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>,</span><span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>double</span> <span class=nf>Area</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>PrintInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>CRectangle</span><span class=o>::</span><span class=n>Area</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>w</span><span class=o>*</span><span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>CRectangle</span><span class=o>::</span><span class=n>PrintInfo</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Rectangle:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Area</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>CCircle</span><span class=o>::</span><span class=n>Area</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mf>3.14</span><span class=o>*</span><span class=n>r</span><span class=o>*</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>CCircle</span><span class=o>::</span><span class=n>PrintInfo</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Circle:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Area</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>CTriangle</span><span class=o>::</span><span class=n>Area</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>p</span><span class=o>=</span><span class=p>(</span><span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=o>+</span><span class=n>c</span><span class=p>)</span><span class=o>/</span><span class=mf>2.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>sqrt</span><span class=p>(</span><span class=n>p</span><span class=o>*</span><span class=p>(</span><span class=n>p</span><span class=o>-</span><span class=n>a</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>p</span><span class=o>-</span><span class=n>b</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>p</span><span class=o>-</span><span class=n>c</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>CTriangle</span><span class=o>::</span><span class=n>PrintInfo</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Triangle:&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Area</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>CShape</span><span class=o>*</span> <span class=n>pShapes</span><span class=p>[</span><span class=mi>100</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>MyCompare</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span><span class=o>*</span> <span class=n>s1</span><span class=p>,</span><span class=k>const</span> <span class=kt>void</span><span class=o>*</span> <span class=n>s2</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>a1</span><span class=p>,</span><span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>CShape</span><span class=o>**</span><span class=n>p1</span><span class=p>;</span><span class=c1>//s1、s2是void*，不可写*s1来获取s1指向的内容 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>CShape</span><span class=o>**</span><span class=n>p2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>p1</span><span class=o>=</span><span class=p>(</span><span class=n>CShape</span><span class=o>**</span><span class=p>)</span><span class=n>s1</span><span class=p>;</span><span class=c1>//s1、s2指向pShapes数组中的元素，数组元素的类型是CShape* 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>p2</span><span class=o>=</span><span class=p>(</span><span class=n>CShape</span><span class=o>**</span><span class=p>)</span><span class=n>s2</span><span class=p>;</span><span class=c1>//故p1、p2都是指向指针的指针，类型为CShape** 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>a1</span><span class=o>=</span><span class=p>(</span><span class=o>*</span><span class=n>p1</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>Area</span><span class=p>();</span><span class=c1>//*p1的类型是CShape*，是基类指针，故此句为多态 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>a2</span><span class=o>=</span><span class=p>(</span><span class=o>*</span><span class=n>p2</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>Area</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>a1</span><span class=o>&lt;</span><span class=n>a2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>a2</span><span class=o>&lt;</span><span class=n>a1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>i</span><span class=p>;</span><span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>CRectangle</span><span class=o>*</span> <span class=n>pr</span><span class=p>;</span><span class=n>CCircle</span><span class=o>*</span> <span class=n>pc</span><span class=p>;</span><span class=n>CTriangle</span><span class=o>*</span> <span class=n>pt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>switch</span><span class=p>(</span><span class=n>c</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=sc>&#39;R&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>				<span class=n>pr</span><span class=o>=</span><span class=k>new</span> <span class=n>CRectangle</span><span class=p>();</span>
</span></span><span class=line><span class=cl>				<span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>pr</span><span class=o>-&gt;</span><span class=n>w</span> <span class=o>&gt;&gt;</span> <span class=n>pr</span><span class=o>-&gt;</span><span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=n>pShapes</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=n>pr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=sc>&#39;C&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>				<span class=n>pc</span><span class=o>=</span><span class=k>new</span> <span class=n>CCircle</span><span class=p>();</span>
</span></span><span class=line><span class=cl>				<span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>pc</span><span class=o>-&gt;</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=n>pShapes</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=n>pc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=sc>&#39;T&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>				<span class=n>pt</span><span class=o>=</span><span class=k>new</span> <span class=n>CTriangle</span><span class=p>();</span>
</span></span><span class=line><span class=cl>				<span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>pt</span><span class=o>-&gt;</span><span class=n>a</span> <span class=o>&gt;&gt;</span> <span class=n>pt</span><span class=o>-&gt;</span><span class=n>b</span> <span class=o>&gt;&gt;</span> <span class=n>pt</span><span class=o>-&gt;</span><span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=n>pShapes</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=n>pt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>qsort</span><span class=p>(</span><span class=n>pShapes</span><span class=p>,</span><span class=n>n</span><span class=p>,</span><span class=k>sizeof</span><span class=p>(</span><span class=n>CShape</span><span class=o>*</span><span class=p>),</span><span class=n>MyCompare</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>pShapes</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>PrintInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果添加新的几何形体，比如五边形，则只需要从 <code>CShape</code> 派生出 <code>CPentagon</code>，以及在 <code>main</code> 中的 <code>switch</code> 语句中增加一个 <code>case</code>，其余部分都不变，体现了多态在提高程序可扩充性方面具有良好作用。</p><ul><li>用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组就能对各个派生类对象做各种操作，是很常用的做法。</li></ul><h3 id=多态的又一例子>多态的又一例子<a hidden class=anchor aria-hidden=true href=#多态的又一例子>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=n>fun1</span><span class=p>(){</span><span class=n>fun2</span><span class=p>();}</span><span class=c1>//等价于void fun1(){this-&gt;fun2();}
</span></span></span><span class=line><span class=cl><span class=c1></span>							<span class=c1>//而this是基类指针，fun2是虚函数，所以是多态
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>fun2</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base::fun2()&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span><span class=k>public</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>fun2</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived:fun2()&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Base</span><span class=o>*</span> <span class=n>pBase</span><span class=o>=&amp;</span><span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pBase</span><span class=o>-&gt;</span><span class=n>fun1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//输出：Derived:fun2()
</span></span></span></code></pre></div><ul><li><strong>在非构造函数，非析构函数的成员函数中调用虚函数，是多态！！！</strong></li><li><strong>在构造函数和析构函数中调用虚函数，不是多态。</strong> 编译时即可确定调用的函数是<strong>自己的类或基类</strong>中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。</li></ul><h3 id=构造函数和析构函数中调用虚函数举例>构造函数和析构函数中调用虚函数举例<a hidden class=anchor aria-hidden=true href=#构造函数和析构函数中调用虚函数举例>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>myclass</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>hello</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hello from myclass&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>bye</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;bye from myclass&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>son</span><span class=o>:</span><span class=k>public</span> <span class=n>myclass</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>hello</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hello from son&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>	<span class=n>son</span><span class=p>(){</span><span class=n>hello</span><span class=p>();}</span>
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>son</span><span class=p>(){</span><span class=n>bye</span><span class=p>();}</span>
</span></span><span class=line><span class=cl><span class=p>};</span><span class=c1>//派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>grandson</span><span class=o>:</span><span class=k>public</span> <span class=n>son</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=n>hello</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hello from grandson&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=nf>bye</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;bye from grandson&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>		<span class=n>grandson</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;constructing grandson&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>grandson</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;destructing grandson&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>grandson</span> <span class=n>gson</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>son</span><span class=o>*</span> <span class=n>pson</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pson</span><span class=o>=&amp;</span><span class=n>gson</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pson</span><span class=o>-&gt;</span><span class=n>hello</span><span class=p>();</span><span class=c1>//多态
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出内容为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>hello</span> <span class=n>from</span> <span class=n>son</span>
</span></span><span class=line><span class=cl><span class=n>constructing</span> <span class=n>grandson</span>
</span></span><span class=line><span class=cl><span class=n>hello</span> <span class=n>from</span> <span class=n>grandson</span>
</span></span><span class=line><span class=cl><span class=n>destructing</span> <span class=n>grandson</span>
</span></span><span class=line><span class=cl><span class=n>bye</span> <span class=n>from</span> <span class=n>myclass</span>
</span></span></code></pre></div><h2 id=4多态的实现原理>4.多态的实现原理<a hidden class=anchor aria-hidden=true href=#4多态的实现原理>#</a></h2><h3 id=问题引入>问题引入<a hidden class=anchor aria-hidden=true href=#问题引入>#</a></h3><p>“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫做 <strong>“动态联编”</strong>。这是如何实现的呢？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Print</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Base:Print&#34;</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span><span class=k>public</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Print</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Derived:Print&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Derived</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Base</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Derived</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>此处的输出内容，在视频中老师的讲解下，理论输出为 <code>4,8</code>，实际输出为 <code>8,12</code>。</p><hr><p>但事实上在 DEV C++ 5.11 中程序运行得到的结果为 <code>16,16</code> 。该程序的输出取决于编译器的实现和系统位数（32 位或 64 位），但根据常见 64 位系统的行为分析：</p><ol><li><p>​<strong>基类 <code>Base</code> 的大小</strong>​：</p><ul><li>虚函数表指针（vptr）：<code>8字节</code>（64 位系统指针大小）</li><li>成员变量 <code>int i</code>：<code>4字节</code></li><li>内存对齐填充：<code>4字节</code>（为了对齐到 8 字节边界）</li><li>​<strong>总计</strong>​：<code>8 + 4 + 4 = 16字节</code></li></ul></li><li><p>​<strong>派生类 <code>Derived</code> 的大小</strong>​：</p><ul><li>继承自 <code>Base</code> 的虚函数表指针（vptr）：<code>8字节</code></li><li>继承自 <code>Base</code> 的成员变量 <code>int i</code>：<code>4字节</code></li><li>新增成员变量 <code>int n</code>：<code>4字节</code></li><li>​<strong>总计</strong>​：<code>8 + 4 + 4 = 16字节</code>（无需额外填充，总大小已是 8 的倍数）</li></ul></li></ol><p>​<strong>其他可能性</strong>​：</p><ul><li>​<strong>32 位系统</strong>​：输出 <code>8,12</code>（vptr 占 4 字节，<code>int</code> 占 4 字节，派生类添加的 <code>int</code> 导致总大小 12）。</li><li>​<strong>编译器优化</strong>​：某些编译器可能减少填充，但主流通用编译器（如 GCC、Clang、MSVC）在 64 位模式下通常结果为 <code>16,16</code>。</li></ul><p>​<strong>总结</strong>​：在标准 64 位环境下，程序输出为 <code>16,16</code>。</p><hr><h3 id=多态实现的关键虚函数表>多态实现的关键——虚函数表<a hidden class=anchor aria-hidden=true href=#多态实现的关键虚函数表>#</a></h3><p>每一个有虚函数的类（或有虚函数的类的派生类）都有一个<strong>虚函数表</strong>，该类的<strong>任何对象</strong>中都存放了虚函数表的指针。虚函数表中列出了该类的虚函数地址。<strong>多出来的 4 个字节就是用来放虚函数表的地址的。</strong></p><p>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。</p><p>也正因如此，含有多态的程序在执行的过程中会有额外的时间和空间上的开销。(存表和查表的开销)</p><h3 id=虚函数表地址验证>虚函数表地址验证<a hidden class=anchor aria-hidden=true href=#虚函数表地址验证>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Func</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>			<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;A::Func&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=o>:</span><span class=k>public</span> <span class=n>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Func</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>			<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;B::Func&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span><span class=o>*</span> <span class=n>pa</span><span class=o>=</span><span class=k>new</span> <span class=n>B</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>pa</span><span class=o>-&gt;</span><span class=n>Func</span><span class=p>();</span><span class=c1>//64位程序指针为8字节，输出B::Func 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>long</span> <span class=kt>long</span><span class=o>*</span> <span class=n>p1</span><span class=o>=</span><span class=p>(</span><span class=kt>long</span> <span class=kt>long</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=kt>long</span><span class=o>*</span> <span class=n>p2</span><span class=o>=</span><span class=p>(</span><span class=kt>long</span> <span class=kt>long</span><span class=o>*</span><span class=p>)</span><span class=n>pa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=n>p2</span><span class=o>=*</span><span class=n>p1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pa</span><span class=o>-&gt;</span><span class=n>Func</span><span class=p>();</span><span class=c1>//输出A::Func 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><p>这段代码很好地演示了 C++ 虚函数表的底层实现机制，我们可以分几个层次来理解：</p><p>​<strong>类结构分析</strong>​</p><ul><li>基类 <code>A</code> 定义了一个虚函数 <code>Func()</code>，输出 &ldquo;A::Func&rdquo;</li><li>派生类 <code>B</code> 重写了 <code>Func()</code>，输出 &ldquo;B::Func&rdquo;</li><li><code>B</code> 继承自 <code>A</code>，形成继承体系</li></ul><p>​<strong>虚函数表原理</strong>​</p><ul><li>编译器会为每个包含虚函数的类生成虚函数表（vtable）</li><li>每个对象实例化时会包含一个隐藏的虚表指针（vptr），指向对应的虚表</li><li><code>A</code> 的虚表存放 <code>A::Func</code> 的地址，<code>B</code> 的虚表存放 <code>B::Func</code> 的地址</li></ul><p>​<strong>内存操作解析</strong>​</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>long</span> <span class=kt>long</span><span class=o>*</span> <span class=n>p1</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span> <span class=kt>long</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>a</span><span class=p>;</span>  <span class=c1>// 获取A实例的虚表指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>long</span> <span class=kt>long</span><span class=o>*</span> <span class=n>p2</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span> <span class=kt>long</span><span class=o>*</span><span class=p>)</span><span class=n>pa</span><span class=p>;</span>  <span class=c1>// 获取B实例的虚表指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>p2</span> <span class=o>=</span> <span class=o>*</span><span class=n>p1</span><span class=p>;</span>  <span class=c1>// 用A的虚表覆盖B的虚表
</span></span></span></code></pre></div><ul><li>这里利用了 64 位系统中指针占 8 字节的特性（<code>long long</code> 也是 8 字节）</li><li>通过直接操作内存，修改了 <code>B</code> 实例的虚表指针，使其指向 <code>A</code> 的虚表</li></ul><p><strong>运行结果解释</strong>​</p><ul><li>第一次调用 <code>pa->Func()</code>：正常输出 <code>B::Func</code>，符合多态特性</li><li>修改虚表指针后：<code>pa</code> 实际指向的对象虽然还是 <code>B</code> 类型，但虚表已被替换为 <code>A</code> 的，故输出 <code>A::Func</code></li></ul><p><strong>重要概念验证</strong>​</p><ul><li>虚函数调用是通过查虚表实现的动态绑定，而非通过对象本身的类型</li><li>虚表指针存在于对象实例的内存起始位置</li><li>多态的实现依赖于虚表机制，而不是简单的类型继承</li></ul><p><strong>注意事项</strong>​</p><ul><li>这种直接操作内存的方式在实际开发中非常危险，会破坏面向对象特性</li><li>不同编译器实现可能有差异，此处演示的是典型实现方式</li><li>32 位系统需要将 <code>long long</code> 改为 <code>long</code>（4 字节）</li></ul><p>这个例子深刻揭示了 C++ 多态性的底层实现，帮助我们理解：虚函数调用实际上是通过虚表指针间接跳转的，当修改了虚表指针后，即使对象类型未变，虚函数的行为也会改变。这是实现运行时多态的关键机制。</p><hr><h2 id=5虚析构函数纯虚函数和抽象类>5.虚析构函数、纯虚函数和抽象类<a hidden class=anchor aria-hidden=true href=#5虚析构函数纯虚函数和抽象类>#</a></h2><h3 id=虚析构函数>虚析构函数<a hidden class=anchor aria-hidden=true href=#虚析构函数>#</a></h3><p>通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数。</p><ul><li>但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。</li></ul><p>解决办法：把基类的<strong>析构函数声明为 <code>virtual</code></strong>。</p><ul><li>派生类的析构函数可以 <code>virtual</code> 不进行声明。</li><li>通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。</li></ul><p>一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。</p><p>注意：<strong>不允许以虚函数作为构造函数</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>son</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>son</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;bye from son&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>grandson</span><span class=o>:</span><span class=k>public</span> <span class=n>son</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>grandson</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;bye from grandson&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>son</span><span class=o>*</span> <span class=n>pson</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pson</span><span class=o>=</span><span class=k>new</span> <span class=n>grandson</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=n>pson</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//输出：bye from son，没有执行grandson::~grandson()
</span></span></span></code></pre></div><p>如果将基类的析构函数声明为 <code>virtual</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>son</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=o>~</span><span class=n>son</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;bye from son&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>grandson</span><span class=o>:</span><span class=k>public</span> <span class=n>son</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>grandson</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;bye from grandson&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>son</span><span class=o>*</span> <span class=n>pson</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pson</span><span class=o>=</span><span class=k>new</span> <span class=n>grandson</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=n>pson</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>则会输出</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>bye from grandson
</span></span><span class=line><span class=cl>bye from son
</span></span></code></pre></div><p>执行 <code>grandson::~grandson()</code>，引起执行 <code>son::~son()</code>。</p><h3 id=纯虚函数和抽象类>纯虚函数和抽象类<a hidden class=anchor aria-hidden=true href=#纯虚函数和抽象类>#</a></h3><ul><li><strong>纯虚函数：没有函数体的虚函数</strong></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Print</span><span class=p>()</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=c1>//纯虚函数，如果不是=0而是{}，也认为是有函数体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><ul><li><strong>包含纯虚函数的类叫抽象类</strong><ul><li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li><li>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span><span class=p>;</span><span class=c1>//错，A是抽象类，不能创建对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span><span class=o>*</span> <span class=n>pa</span><span class=p>;</span><span class=c1>//ok，可以定义抽象类的指针和引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pa</span><span class=o>=</span><span class=k>new</span> <span class=n>A</span><span class=p>;</span><span class=c1>//错误，A是抽象类，不能创建对象
</span></span></span></code></pre></div><ul><li><strong>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。</strong></li><li><strong>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中所有纯虚函数，它才能成为非抽象类。</strong>（也就是说基类中的所有纯虚函数在派生类中都有了函数体）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>f</span><span class=p>()</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=c1>//纯虚函数
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kt>void</span> <span class=nf>g</span><span class=p>(){</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>f</span><span class=p>();}</span><span class=c1>//ok
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//A(){f();}//编译错误，构造函数中不是多态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=o>:</span><span class=k>public</span> <span class=n>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=n>f</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;B:f()&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>B</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>b</span><span class=p>.</span><span class=n>g</span><span class=p>();</span><span class=c1>//输出B:f()
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/c++/>C++</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/c++5/><span class=title>下一页 »</span><br><span>面向对象的程序设计学习笔记 5</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 6 on x" href="https://x.com/intent/tweet/?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%206&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b6%2f&amp;hashtags=C%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 6 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b6%2f&amp;title=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%206&amp;summary=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%206&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 6 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b6%2f&title=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%206"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 6 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 6 on whatsapp" href="https://api.whatsapp.com/send?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%206%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 6 on telegram" href="https://telegram.me/share/url?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%206&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b6%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 6 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%206&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b6%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Kibrac's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>