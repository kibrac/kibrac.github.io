<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>面向对象的程序设计学习笔记 2 - Kibrac&#39;s Blog</title>
  <meta name="description" content="第二章 类和对象基础">
  
  
  <link rel="icon" type="image/png" href="https://kibrac.github.io/favicon.png">
  
  
  <link rel="stylesheet" href="https://kibrac.github.io/css/normalize.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/style.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/archives.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/tag-cloud.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/toc-and-backtop.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/custom.css">
  
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
  
  
  <script>
    
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const storedTheme = localStorage.getItem('theme');
    if (storedTheme === 'dark' || (!storedTheme && prefersDark)) {
      document.documentElement.classList.add('dark-mode');
    }
  </script>
  
  <meta property="og:url" content="https://kibrac.github.io/posts/c&#43;&#43;2/">
  <meta property="og:site_name" content="Kibrac&#39;s Blog">
  <meta property="og:title" content="面向对象的程序设计学习笔记 2">
  <meta property="og:description" content="第二章 类和对象基础">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-04-16T20:27:27+08:00">
    <meta property="article:modified_time" content="2025-04-16T20:27:27+08:00">
    <meta property="article:tag" content="C&#43;&#43;">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="面向对象的程序设计学习笔记 2">
  <meta name="twitter:description" content="第二章 类和对象基础">
      <meta name="twitter:site" content="@https://x.com/kibra_chen">

  
  
  
  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
</head>
<body>
  <div class="container">
    <header class="site-header">
      <div class="header-container">
  <div class="site-branding">
    <a href="/" class="site-title">Kibrac&#39;s Blog</a>
    
  </div>
  
  <nav class="main-navigation">
    
    <ul class="menu" id="primary-menu">
      
      
      <li class="menu-item  ">
        <a href="/" class="home-link">首页</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/posts/" >文章</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/archives/" >归档</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/categories/" >分类</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/tags/" >标签</a>
      </li>
      
    </ul>
  </nav>
  
  <div class="header-actions">
    <button class="menu-toggle" aria-controls="primary-menu" aria-expanded="false">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>
    
    
    <button class="theme-toggle" aria-label="切换主题">
      <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
      </svg>
      <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
      </svg>
    </button>
  </div>
</div>


    </header>
    
    <main class="main-content">
      
<div class="post-container">
  <div class="toc-sidebar" id="toc-sidebar"></div>
  <article class="post">
    
    <div class="post-featured-image post-banner">
      <img src="https://kibrac.github.io/images/cover/c&#43;&#43;.jpg" alt="面向对象的程序设计学习笔记 2">
    </div>
    
    
    <header class="post-header">
      <h1 class="post-title">面向对象的程序设计学习笔记 2</h1>
      
      <div class="post-meta">
        <time datetime="2025-04-16T20:27:27&#43;08:00">
          2025-04-16
        </time>
        
        
        <span class="post-author">
          Kibrac
        </span>
        
        
        
        <div class="post-categories">
          
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
          
        </div>
        
      </div>
    </header>
    
    <div class="post-content">
      <p>课程链接：<a href="https://www.icourse163.org/course/PKU-1002029030">程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)</a></p>
<h2 id="1类和对象的基本概念补充">1.类和对象的基本概念（补充）</h2>
<h3 id="类的成员函数和类的定义分开写">类的成员函数和类的定义分开写</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CRectangle</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> w,h;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Area</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Perimeter</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Init</span>(<span style="color:#66d9ef">int</span> w_,<span style="color:#66d9ef">int</span> h_);<span style="color:#75715e">//成员函数仅在此声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> CRectangle<span style="color:#f92672">::</span>Area(){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> w<span style="color:#f92672">*</span>h;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> CRectangle<span style="color:#f92672">::</span>Perimeter(){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>(w<span style="color:#f92672">+</span>h);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> CRectangle<span style="color:#f92672">::</span>Init(<span style="color:#66d9ef">int</span> w_,<span style="color:#66d9ef">int</span> h_){
</span></span><span style="display:flex;"><span>		w<span style="color:#f92672">=</span>w_;h<span style="color:#f92672">=</span>h_;
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><ul>
<li>CRectangle:: 说明后面的函数是 CRectangle 类的成员函数，而非普通函数。那么，一定要通过对象或对象的指针或对象的引用才能调用。</li>
</ul>
<h3 id="类成员的可访问范围">类成员的可访问范围</h3>
<blockquote>
<p>在类的定义中，用下列访问范围关键字来说明类成员可被访问的范围</p>
<blockquote>
<p>private: 私有成员，只能在成员函数内访问</p>
<p>public: 共有成员，可以在任何地方访问</p>
<p>protected: 保护成员，以后再说</p></blockquote></blockquote>
<p>定义一个类</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">classname</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">私有属性和函数</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">共有属性和函数</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">保护属性和函数</span>
</span></span><span style="display:flex;"><span>}<span style="color:#960050;background-color:#1e0010">；</span>
</span></span></code></pre></div><p><strong>如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。</strong></p>
<blockquote>
<p>在类的成员函数内部，能够访问</p>
<blockquote>
<p>当前对象的全部属性、函数
同类其它对象的全部属性、函数</p></blockquote>
<p>在类的成员函数以外的地方，只能够访问该类对象的公有成员</p></blockquote>
<h3 id="私有成员变量的隐藏">私有成员变量的隐藏</h3>
<p>设置私有成员的机制，叫“<strong>隐藏</strong>”</p>
<p>“<strong>隐藏</strong>”的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则，所有直接访问成员变量的语句都需要修改。</p>
<h3 id="成员函数的重载及参数缺省">成员函数的重载及参数缺省</h3>
<ul>
<li>成员函数也可以重载</li>
<li>成员函数也可以带缺省参数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Location</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> x,y;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> init(<span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">int</span> y<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">valueX</span>(<span style="color:#66d9ef">int</span> val){x<span style="color:#f92672">=</span>val;}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">valueX</span>(){<span style="color:#66d9ef">return</span> x;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Location<span style="color:#f92672">::</span>init(<span style="color:#66d9ef">int</span> X,<span style="color:#66d9ef">int</span> Y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	x<span style="color:#f92672">=</span>X;
</span></span><span style="display:flex;"><span>	y<span style="color:#f92672">=</span>Y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	Location A,B;
</span></span><span style="display:flex;"><span>	A.init(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>	A.valueX(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> A.valueX();<span style="color:#75715e">//输出5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="2构造函数">2.构造函数</h2>
<h3 id="构造函数的基本概念">构造函数的基本概念</h3>
<p>构造函数是成员函数的一种</p>
<ol>
<li>名字与类名相同，可以有参数，不能有返回值（void 也不行）</li>
<li><strong>作用是对对象进行初始化，如给成员变量赋初值</strong></li>
<li>如果定义类时没写构造函数，则编译器生成一个默认的<strong>无参数</strong>的构造函数。默认构造函数无参数，不做任何操作</li>
<li>如果定义了构造函数，则编译器不生成默认的无参数的构造函数</li>
<li><strong>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</strong></li>
<li>一个类可以有多个构造函数</li>
</ol>
<h3 id="构造函数的重要性">构造函数的重要性</h3>
<ul>
<li>构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数</li>
<li>有时对象没被初始化就使用，会导致程序出错</li>
</ul>
<h3 id="构造函数的重载">构造函数的重载</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Complex</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">double</span> real,imag;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> Set(<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i);
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//编译器自动生成默认构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Complex c1;<span style="color:#75715e">//默认构造函数被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Complex<span style="color:#f92672">*</span> pc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Complex;<span style="color:#75715e">//默认构造函数被调用
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Complex</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">double</span> real,imag;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		Complex(<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Complex<span style="color:#f92672">::</span>Complex(<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i){
</span></span><span style="display:flex;"><span>	real<span style="color:#f92672">=</span>r,imag<span style="color:#f92672">=</span>i;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Complex c1;<span style="color:#75715e">//error，缺少构造函数的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Complex<span style="color:#f92672">*</span> pc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Complex;<span style="color:#75715e">//error，没有参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Complex <span style="color:#a6e22e">c1</span>(<span style="color:#ae81ff">2</span>);<span style="color:#75715e">//ok
</span></span></span></code></pre></div><ul>
<li>一个类可以有多个构造函数，只要这多个构造函数的参数个数或者参数类型不同，就形成了重载的关系。</li>
</ul>
<blockquote>
<p>一段话描述“重载”的概念</p>
<p>在编程中，<strong>重载（Overload）<strong>可以理解为“<strong>同一个名字，多种用法</strong>”。就像你家的洗衣机有一个“洗涤”按钮，但根据你放入的衣物类型（毛衣、羽绒服、衬衫），它会自动调整水温、转速和时间。重载也是类似逻辑：程序员可以给</strong>同一个函数名</strong>写多个版本的实现，而这些版本的<strong>参数必须不同</strong>（比如参数类型、数量或顺序）。例如，一个叫 <code>加法</code> 的函数，既能处理两个整数相加，也能处理三个小数相加，甚至拼接两个字符串——只要参数不同，编译器就能自动根据你传入的数据<strong>匹配对应的版本</strong>。这样一来，代码更简洁直观，开发者不用死记硬背 <code>加整数</code>、<code>加小数</code> 等五花八门的名字，只需记住一个 <code>加法</code> 就能应对多种场景。</p></blockquote>
<h2 id="3复制构造函数">3.复制构造函数</h2>
<h3 id="复制构造函数的基本概念">复制构造函数的基本概念</h3>
<ol>
<li>只有一个参数，即对同类对象的引用</li>
<li>形如 <code>X::X(X &amp;)</code> 或 <code>X::X(const X &amp;)</code>，二者选一，后者能以常量对象作为参数</li>
<li>如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Complex</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">double</span> real,imag;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Complex c1;<span style="color:#75715e">//调用缺省无参构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Complex <span style="color:#a6e22e">c2</span>(c1);<span style="color:#75715e">//调用缺省的复制构造函数，将c2初始化成和c1一样
</span></span></span></code></pre></div><p><strong>不允许有形如 <code>X::X(X)</code> 的构造函数</strong></p>
<h3 id="复制构造函数起作用的三种情况">复制构造函数起作用的三种情况</h3>
<ol>
<li>当用一个对象去初始化同类的另一个对象时</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Complex <span style="color:#a6e22e">c2</span>(c1);
</span></span><span style="display:flex;"><span>Complex c2<span style="color:#f92672">=</span>c1;<span style="color:#75715e">//等价于上一条语句，这是一条初始化语句，不是赋值语句
</span></span></span></code></pre></div><ol start="2">
<li>如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类 A 的复制构造函数将被调用</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	A(){};
</span></span><span style="display:flex;"><span>	A(A<span style="color:#f92672">&amp;</span>a){
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Copy constructor called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Func</span>(A a1){}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	A a2;
</span></span><span style="display:flex;"><span>	Func(a2);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}<span style="color:#75715e">//程序输出结果为：Copy constructor called
</span></span></span></code></pre></div><ol start="3">
<li>如果函数的返回值是类 A 的对象时，则函数返回时，A 的复制构造函数将被调用</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> v;
</span></span><span style="display:flex;"><span>	A(<span style="color:#66d9ef">int</span> n){v<span style="color:#f92672">=</span>n;};
</span></span><span style="display:flex;"><span>	A(<span style="color:#66d9ef">const</span> A<span style="color:#f92672">&amp;</span>a){
</span></span><span style="display:flex;"><span>		v<span style="color:#f92672">=</span>a.v;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Copy constructor called&#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>A <span style="color:#a6e22e">Func</span>(){
</span></span><span style="display:flex;"><span>	A b(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> Func().v <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}<span style="color:#75715e">//输出结果为4
</span></span></span></code></pre></div><hr>
<h3 id="一点问题">一点问题</h3>
<blockquote>
<p>在原视频老师的讲解中，输出的内容为</p>
<blockquote>
<p>Copy constructor called4</p></blockquote>
<p>但在 DEV-C++ 5.11 中实际运行以上代码，输出结果为</p>
<blockquote>
<p>4</p></blockquote></blockquote>
<p>原因如下</p>
<p>根据代码逻辑和 C++ 的拷贝构造函数调用规则，输出结果为：<strong>4</strong>，而不会打印 &ldquo;Copy constructor called&rdquo;。以下是关键原因分析：</p>
<ol>
<li><strong>编译器优化（拷贝省略）</strong>
C++ 编译器在函数返回局部对象时，会进行<strong>返回值优化（RVO, Return Value Optimization）</strong>，直接将对象构造在调用处的内存中，<strong>跳过拷贝构造函数的调用</strong>。即使拷贝构造函数显式定义了输出语句，编译器也会优化掉这次拷贝。</li>
</ol>
<p>在代码中，<code>Func()</code> 返回局部对象 <code>b</code>，理论上会触发拷贝构造函数。但由于 RVO 优化：</p>
<p>• <strong>实际构造过程</strong>：直接在 <code>Func()</code> 的返回值内存区域构造 <code>b</code>，无需拷贝。</p>
<p>• <strong>结果</strong>：<code>cout &lt;&lt; Func().v</code> 直接输出 <code>b.v</code> 的值 <code>4</code>，而不会触发拷贝构造函数的输出。</p>
<ol start="2">
<li><strong>若关闭编译器优化</strong></li>
</ol>
<p>如果强制关闭优化（例如 GCC 使用 <code>-fno-elide-constructors</code>），代码会输出：</p>
<pre tabindex="0"><code>Copy constructor called4
</code></pre><p>此时：</p>
<ul>
<li><code>Func()</code> 返回 <code>b</code> 时，会调用拷贝构造函数生成临时对象。</li>
<li>临时对象再被用来访问 <code>v</code>，输出 <code>4</code>。</li>
</ul>
<ol start="3">
<li><strong>代码细节验证</strong></li>
</ol>
<ul>
<li><strong>拷贝构造函数的触发条件</strong>：只有当用<strong>已有对象初始化新对象</strong>时才会调用拷贝构造函数（例如 <code>A a = b;</code>）。而返回值优化场景下，对象直接在目标内存构造，不满足这一条件。</li>
<li><strong>C++ 标准支持</strong>：C++11 及以后版本中，RVO 是编译器必须支持的优化，即使拷贝/移动构造函数有副作用（如输出语句），优化仍然生效。</li>
</ul>
<p>因此 在默认编译选项下，输出为 <strong><code>4</code></strong>。若需验证拷贝构造函数的行为，需通过编译选项关闭优化。</p>
<hr>
<p><strong>注意，对象间赋值并不导致复制构造函数被调用</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CMyclass</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>	CMyclass(){};
</span></span><span style="display:flex;"><span>	CMyclass(CMyclass <span style="color:#f92672">&amp;</span> c){n<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>c.n;}<span style="color:#75715e">//此处仅为说明问题，并不推荐复制函数这样书写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	CMyclass c1,c2;
</span></span><span style="display:flex;"><span>	c1.n<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>;c2<span style="color:#f92672">=</span>c1;CMyclass c3(c1);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c2.n=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> c2.n <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span>;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c3.n=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> c3.n <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}<span style="color:#75715e">//输出：c2.n=5,c3.n=10
</span></span></span></code></pre></div><h3 id="常量引用参数的使用">常量引用参数的使用</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(CMyclass obj_){
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;fun&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>这样的函数，调用时生成形参会引发复制构造函数调用，开销比较大</li>
<li>所以可以考虑使用 CMyclass &amp;引用类型作为参数</li>
<li>如果希望确保实参的值在函数中不应被改变，那么可以加上 const 关键字</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(<span style="color:#66d9ef">const</span> CMyclass <span style="color:#f92672">&amp;</span> obj){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//函数中任何试图改变obj值的语句都变成非法语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="4类型转换构造函数">4.类型转换构造函数</h2>
<h3 id="什么是类型转换构造函数">什么是类型转换构造函数</h3>
<ol>
<li>定义转换构造函数的目的是实现类型的自动转换</li>
<li>只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数</li>
<li>当需要时，编译系统会自动调用转换构造函数，建立一个无名的临时对象（或临时变量）</li>
</ol>
<h3 id="类型转换构造函数示例">类型转换构造函数示例</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Complex</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">double</span> real,imag;
</span></span><span style="display:flex;"><span>		Complex(<span style="color:#66d9ef">int</span> i){<span style="color:#75715e">//类型转换构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;IntConstructor called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>			real<span style="color:#f92672">=</span>i;imag<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		Complex(<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i){real<span style="color:#f92672">=</span>r;imag<span style="color:#f92672">=</span>i;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	Complex c1(<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>	Complex c2<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>	c1<span style="color:#f92672">=</span><span style="color:#ae81ff">9</span>;<span style="color:#75715e">//9被自动转换成一个临时Complex对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> c1.real <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> c1.imag <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="5析构函数">5.析构函数</h2>
<h3 id="什么是析构函数">什么是析构函数</h3>
<ol>
<li>名字与类名相同，在前面加 <code>~</code>，没有参数和返回值，一个类最多只能有一个析构函数</li>
<li>析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等</li>
<li>如果定义类时没写析构函数，则编译器生成缺省析构函数，缺省析构函数什么也不做</li>
<li>如果定义了析构函数，则编译器不生成缺省析构函数</li>
</ol>
<h3 id="析构函数示例">析构函数示例</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		String(){
</span></span><span style="display:flex;"><span>			p<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>String();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>String<span style="color:#f92672">::~</span>String(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span> []p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="析构函数和数组">析构函数和数组</h3>
<ul>
<li>对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Ctest</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">~</span>Ctest(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destructor called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	Ctest array[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;End Main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出</p>
<pre tabindex="0"><code>End Main
destructor called
destructor called
</code></pre><h3 id="析构函数和运算符-delete">析构函数和运算符 delete</h3>
<ul>
<li>delete 运算导致析构函数被调用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Ctest<span style="color:#f92672">*</span> pTest;
</span></span><span style="display:flex;"><span>pTest<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Ctest;<span style="color:#75715e">//构造函数调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> pTest;<span style="color:#75715e">//析构函数调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>pTest<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Ctest[<span style="color:#ae81ff">3</span>];<span style="color:#75715e">//构造函数调用3次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> []pTest;<span style="color:#75715e">//析构函数调用3次
</span></span></span></code></pre></div><ul>
<li>若 new 一个对象数组，那么用 delete 释放时应该写 []。否则只 delete 一个对象（调用一次析构函数）</li>
</ul>
<h2 id="6构造函数析构函数调用时机">6.构造函数析构函数调用时机</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	Demo(<span style="color:#66d9ef">int</span> i){
</span></span><span style="display:flex;"><span>		id<span style="color:#f92672">=</span>i;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; constructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">~</span>Demo(){
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; destructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Demo <span style="color:#a6e22e">d1</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Func</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> Demo d2(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>	Demo d3(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	Demo d4(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>	d4<span style="color:#f92672">=</span><span style="color:#ae81ff">6</span>;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		Demo d5(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	Func();
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main ends&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出内容</p>
<pre tabindex="0"><code>id=1 constructed
id=4 constructed
id=6 constructed
id=6 destructed
main
id=5 constructed
id=5 destructed
id=2 constructed
id=3 constructed
func
id=3 destructed
main ends
id=6 destructed
id=2 destructed
id=1 destructed
</code></pre>
    </div>
    
    <div class="post-copyright">
      <div class="copyright-info">
        <p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p>
        <p>本文链接：<a href="https://kibrac.github.io/posts/c&#43;&#43;2/">https://kibrac.github.io/posts/c&#43;&#43;2/</a></p>
      </div>
    </div>
    
    
    <div class="post-tags">
      
      <a href="/tags/c&#43;&#43;/" class="tag">#C&#43;&#43;</a>
      
    </div>
    
    
    <div class="post-navigation">
      
      <a class="prev-post" href="https://kibrac.github.io/posts/c&#43;&#43;1/">&larr; 面向对象的程序设计学习笔记 1</a>
      
      
      
      <a class="next-post" href="https://kibrac.github.io/posts/c&#43;&#43;3/">面向对象的程序设计学习笔记 3 &rarr;</a>
      
    </div>
    
    
  </article>
  

</div>

    </main>
    
    <footer class="site-footer">
      <div class="footer-container">
  <div class="footer-content">
    <div class="footer-info">
      <p class="copyright">&copy; 2025 Kibrac&#39;s Blog</p>
      
      
    </div>
    
    
  </div>
  
  <div class="footer-bottom">
    <div class="footer-links">
      
      
      <span class="footer-separator">|</span>
      <span>使用 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> 构建</span>
      <span class="footer-separator">|</span>
      <span>主题 <a href="#" rel="noopener noreferrer">PointFive</a></span>
    </div>
</div>
    </footer>
  </div>
  
  
  <script src="https://kibrac.github.io/js/main.js"></script>
  <script src="https://kibrac.github.io/js/code-block.js"></script>
  <script src="https://kibrac.github.io/js/toc-and-backtop.js"></script>
  
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError: false
      });
    });
  </script>
  
  
  
  
</body>
</html>