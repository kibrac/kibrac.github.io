<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>面向对象的程序设计学习笔记 2 | Kibrac's Blog</title>
<meta name=keywords content="C++"><meta name=description content="第二章 类和对象基础"><meta name=author content="Kibrac"><link rel=canonical href=http://localhost:1313/posts/c++2/><link crossorigin=anonymous href=/assets/css/stylesheet.ae3d277e69647c027e65dd7c785748f912a9be2d37da0061b9ff15a5d7fafb7b.css integrity="sha256-rj0nfmlkfAJ+Zd18eFdI+RKpvi032gBhuf8Vpdf6+3s=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:1313/posts/c++2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/c++2/"><meta property="og:site_name" content="Kibrac's Blog"><meta property="og:title" content="面向对象的程序设计学习笔记 2"><meta property="og:description" content="第二章 类和对象基础"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-16T20:27:27+08:00"><meta property="article:modified_time" content="2025-04-16T20:27:27+08:00"><meta property="article:tag" content="C++"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="面向对象的程序设计学习笔记 2"><meta name=twitter:description content="第二章 类和对象基础"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"面向对象的程序设计学习笔记 2","item":"http://localhost:1313/posts/c++2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"面向对象的程序设计学习笔记 2","name":"面向对象的程序设计学习笔记 2","description":"第二章 类和对象基础","keywords":["C++"],"articleBody":"课程链接：程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\n1.类和对象的基本概念（补充） 类的成员函数和类的定义分开写 class CRectangle { public: int w,h; int Area(); int Perimeter(); void Init(int w_,int h_);//成员函数仅在此声明 }; int CRectangle::Area(){ return w*h; } int CRectangle::Perimeter(){ return 2*(w+h); } void CRectangle::Init(int w_,int h_){ w=w_;h=h_; } CRectangle:: 说明后面的函数是 CRectangle 类的成员函数，而非普通函数。那么，一定要通过对象或对象的指针或对象的引用才能调用。 类成员的可访问范围 在类的定义中，用下列访问范围关键字来说明类成员可被访问的范围\nprivate: 私有成员，只能在成员函数内访问\npublic: 共有成员，可以在任何地方访问\nprotected: 保护成员，以后再说\n定义一个类\nclass classname{ private: 私有属性和函数 public: 共有属性和函数 protected: 保护属性和函数 }； 如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。\n在类的成员函数内部，能够访问\n当前对象的全部属性、函数 同类其它对象的全部属性、函数\n在类的成员函数以外的地方，只能够访问该类对象的公有成员\n私有成员变量的隐藏 设置私有成员的机制，叫“隐藏”\n“隐藏”的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则，所有直接访问成员变量的语句都需要修改。\n成员函数的重载及参数缺省 成员函数也可以重载 成员函数也可以带缺省参数 #include using namespace std; class Location{ private: int x,y; public: void init(int x=0,int y=0); void valueX(int val){x=val;} int valueX(){return x;} }; void Location::init(int X,int Y) { x=X; y=Y; } int main(){ Location A,B; A.init(5); A.valueX(5); cout \u003c\u003c A.valueX();//输出5 return 0; } 2.构造函数 构造函数的基本概念 构造函数是成员函数的一种\n名字与类名相同，可以有参数，不能有返回值（void 也不行） 作用是对对象进行初始化，如给成员变量赋初值 如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数。默认构造函数无参数，不做任何操作 如果定义了构造函数，则编译器不生成默认的无参数的构造函数 对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数 一个类可以有多个构造函数 构造函数的重要性 构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数 有时对象没被初始化就使用，会导致程序出错 构造函数的重载 class Complex{ private: double real,imag; public: void Set(double r,double i); };//编译器自动生成默认构造函数 Complex c1;//默认构造函数被调用 Complex* pc = new Complex;//默认构造函数被调用 class Complex{ private: double real,imag; public: Complex(double r,double i=0); }; Complex::Complex(double r,double i){ real=r,imag=i; } Complex c1;//error，缺少构造函数的参数 Complex* pc = new Complex;//error，没有参数 Complex c1(2);//ok 一个类可以有多个构造函数，只要这多个构造函数的参数个数或者参数类型不同，就形成了重载的关系。 一段话描述“重载”的概念\n在编程中，重载（Overload）可以理解为“同一个名字，多种用法”。就像你家的洗衣机有一个“洗涤”按钮，但根据你放入的衣物类型（毛衣、羽绒服、衬衫），它会自动调整水温、转速和时间。重载也是类似逻辑：程序员可以给同一个函数名写多个版本的实现，而这些版本的参数必须不同（比如参数类型、数量或顺序）。例如，一个叫 加法 的函数，既能处理两个整数相加，也能处理三个小数相加，甚至拼接两个字符串——只要参数不同，编译器就能自动根据你传入的数据匹配对应的版本。这样一来，代码更简洁直观，开发者不用死记硬背 加整数、加小数 等五花八门的名字，只需记住一个 加法 就能应对多种场景。\n3.复制构造函数 复制构造函数的基本概念 只有一个参数，即对同类对象的引用 形如 X::X(X \u0026) 或 X::X(const X \u0026)，二者选一，后者能以常量对象作为参数 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能 class Complex{ private: double real,imag; }; Complex c1;//调用缺省无参构造函数 Complex c2(c1);//调用缺省的复制构造函数，将c2初始化成和c1一样 不允许有形如 X::X(X) 的构造函数\n复制构造函数起作用的三种情况 当用一个对象去初始化同类的另一个对象时 Complex c2(c1); Complex c2=c1;//等价于上一条语句，这是一条初始化语句，不是赋值语句 如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类 A 的复制构造函数将被调用 #include using namespace std; class A { public: A(){}; A(A\u0026a){ cout \u003c\u003c \"Copy constructor called\" \u003c\u003c endl; } }; void Func(A a1){} int main(){ A a2; Func(a2); return 0; }//程序输出结果为：Copy constructor called 如果函数的返回值是类 A 的对象时，则函数返回时，A 的复制构造函数将被调用 #include using namespace std; class A { public: int v; A(int n){v=n;}; A(const A\u0026a){ v=a.v; cout \u003c\u003c \"Copy constructor called\"; } }; A Func(){ A b(4); return b; } int main(){ cout \u003c\u003c Func().v \u003c\u003c endl; return 0; }//输出结果为4 一点问题 在原视频老师的讲解中，输出的内容为\nCopy constructor called4\n但在 DEV-C++ 5.11 中实际运行以上代码，输出结果为\n4\n原因如下\n根据代码逻辑和 C++ 的拷贝构造函数调用规则，输出结果为：4，而不会打印 “Copy constructor called”。以下是关键原因分析：\n编译器优化（拷贝省略） C++ 编译器在函数返回局部对象时，会进行返回值优化（RVO, Return Value Optimization），直接将对象构造在调用处的内存中，跳过拷贝构造函数的调用。即使拷贝构造函数显式定义了输出语句，编译器也会优化掉这次拷贝。 在代码中，Func() 返回局部对象 b，理论上会触发拷贝构造函数。但由于 RVO 优化：\n• 实际构造过程：直接在 Func() 的返回值内存区域构造 b，无需拷贝。\n• 结果：cout \u003c\u003c Func().v 直接输出 b.v 的值 4，而不会触发拷贝构造函数的输出。\n若关闭编译器优化 如果强制关闭优化（例如 GCC 使用 -fno-elide-constructors），代码会输出：\nCopy constructor called4 此时：\nFunc() 返回 b 时，会调用拷贝构造函数生成临时对象。 临时对象再被用来访问 v，输出 4。 代码细节验证 拷贝构造函数的触发条件：只有当用已有对象初始化新对象时才会调用拷贝构造函数（例如 A a = b;）。而返回值优化场景下，对象直接在目标内存构造，不满足这一条件。 C++ 标准支持：C++11 及以后版本中，RVO 是编译器必须支持的优化，即使拷贝/移动构造函数有副作用（如输出语句），优化仍然生效。 因此 在默认编译选项下，输出为 4。若需验证拷贝构造函数的行为，需通过编译选项关闭优化。\n注意，对象间赋值并不导致复制构造函数被调用\nclass CMyclass{ public: int n; CMyclass(){}; CMyclass(CMyclass \u0026 c){n=2*c.n;}//此处仅为说明问题，并不推荐复制函数这样书写 }; int main(){ CMyclass c1,c2; c1.n=5;c2=c1;CMyclass c3(c1); cout \u003c\u003c \"c2.n=\" \u003c\u003c c2.n \u003c\u003c \",\"; cout \u003c\u003c \"c3.n=\" \u003c\u003c c3.n \u003c\u003c endl; return 0; }//输出：c2.n=5,c3.n=10 常量引用参数的使用 void fun(CMyclass obj_){ cout \u003c\u003c \"fun\" \u003c\u003c endl; } 这样的函数，调用时生成形参会引发复制构造函数调用，开销比较大 所以可以考虑使用 CMyclass \u0026引用类型作为参数 如果希望确保实参的值在函数中不应被改变，那么可以加上 const 关键字 void fun(const CMyclass \u0026 obj){ //函数中任何试图改变obj值的语句都变成非法语句 } 4.类型转换构造函数 什么是类型转换构造函数 定义转换构造函数的目的是实现类型的自动转换 只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数 当需要时，编译系统会自动调用转换构造函数，建立一个无名的临时对象（或临时变量） 类型转换构造函数示例 class Complex{ public: double real,imag; Complex(int i){//类型转换构造函数 cout \u003c\u003c \"IntConstructor called\" \u003c\u003c endl; real=i;imag=0; } Complex(double r,double i){real=r;imag=i;} }; int main(){ Complex c1(7,8); Complex c2=12; c1=9;//9被自动转换成一个临时Complex对象 cout \u003c\u003c c1.real \u003c\u003c \",\" \u003c\u003c c1.imag \u003c\u003c endl; return 0; } 5.析构函数 什么是析构函数 名字与类名相同，在前面加 ~，没有参数和返回值，一个类最多只能有一个析构函数 析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等 如果定义类时没写析构函数，则编译器生成缺省析构函数，缺省析构函数什么也不做 如果定义了析构函数，则编译器不生成缺省析构函数 析构函数示例 class String{ private: char* p; public: String(){ p=new char[10]; } ~String(); }; String::~String(){ delete []p; } 析构函数和数组 对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。 class Ctest{ public: ~Ctest(){cout \u003c\u003c \"destructor called\" \u003c\u003c endl;} }; int main(){ Ctest array[2]; cout \u003c\u003c \"End Main\" \u003c\u003c endl; return 0; } 输出\nEnd Main destructor called destructor called 析构函数和运算符 delete delete 运算导致析构函数被调用 Ctest* pTest; pTest=new Ctest;//构造函数调用 delete pTest;//析构函数调用 pTest=new Ctest[3];//构造函数调用3次 delete []pTest;//析构函数调用3次 若 new 一个对象数组，那么用 delete 释放时应该写 []。否则只 delete 一个对象（调用一次析构函数） 6.构造函数析构函数调用时机 #include using namespace std; class Demo{ int id; public: Demo(int i){ id=i; cout \u003c\u003c \"id=\" \u003c\u003c id \u003c\u003c \" constructed\" \u003c\u003c endl; } ~Demo(){ cout \u003c\u003c \"id=\" \u003c\u003c id \u003c\u003c \" destructed\" \u003c\u003c endl; } }; Demo d1(1); void Func(){ static Demo d2(2); Demo d3(3); cout \u003c\u003c \"func\" \u003c\u003c endl; } int main(){ Demo d4(4); d4=6; cout \u003c\u003c \"main\" \u003c\u003c endl; { Demo d5(5); } Func(); cout \u003c\u003c \"main ends\" \u003c\u003c endl; return 0; } 输出内容\nid=1 constructed id=4 constructed id=6 constructed id=6 destructed main id=5 constructed id=5 destructed id=2 constructed id=3 constructed func id=3 destructed main ends id=6 destructed id=2 destructed id=1 destructed ","wordCount":"3292","inLanguage":"zh","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-04-16T20:27:27+08:00","dateModified":"2025-04-16T20:27:27+08:00","author":{"@type":"Person","name":"Kibrac"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/c++2/"},"publisher":{"@type":"Organization","name":"Kibrac's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Kibrac's Blog (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Kibrac's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=归档><span>归档</span></a></li><li><a href=http://localhost:1313/categories/ title=分类><span>分类</span></a></li><li><a href=http://localhost:1313/tags/ title=标签><span>标签</span></a></li><li><a href=http://localhost:1313/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">面向对象的程序设计学习笔记 2</h1><div class=post-description>第二章 类和对象基础</div><div class=post-meta><span title='2025-04-16 20:27:27 +0800 CST'>四月 16, 2025</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;3292 字&nbsp;·&nbsp;Kibrac</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1类和对象的基本概念补充>1.类和对象的基本概念（补充）</a><ul><li><a href=#类的成员函数和类的定义分开写>类的成员函数和类的定义分开写</a></li><li><a href=#类成员的可访问范围>类成员的可访问范围</a></li><li><a href=#私有成员变量的隐藏>私有成员变量的隐藏</a></li><li><a href=#成员函数的重载及参数缺省>成员函数的重载及参数缺省</a></li></ul></li><li><a href=#2构造函数>2.构造函数</a><ul><li><a href=#构造函数的基本概念>构造函数的基本概念</a></li><li><a href=#构造函数的重要性>构造函数的重要性</a></li><li><a href=#构造函数的重载>构造函数的重载</a></li></ul></li><li><a href=#3复制构造函数>3.复制构造函数</a><ul><li><a href=#复制构造函数的基本概念>复制构造函数的基本概念</a></li><li><a href=#复制构造函数起作用的三种情况>复制构造函数起作用的三种情况</a></li><li><a href=#一点问题>一点问题</a></li><li><a href=#常量引用参数的使用>常量引用参数的使用</a></li></ul></li><li><a href=#4类型转换构造函数>4.类型转换构造函数</a><ul><li><a href=#什么是类型转换构造函数>什么是类型转换构造函数</a></li><li><a href=#类型转换构造函数示例>类型转换构造函数示例</a></li></ul></li><li><a href=#5析构函数>5.析构函数</a><ul><li><a href=#什么是析构函数>什么是析构函数</a></li><li><a href=#析构函数示例>析构函数示例</a></li><li><a href=#析构函数和数组>析构函数和数组</a></li><li><a href=#析构函数和运算符-delete>析构函数和运算符 delete</a></li></ul></li><li><a href=#6构造函数析构函数调用时机>6.构造函数析构函数调用时机</a></li></ul></nav></div></details></div><div class=post-content><p>课程链接：<a href=https://www.icourse163.org/course/PKU-1002029030>程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)</a></p><h2 id=1类和对象的基本概念补充>1.类和对象的基本概念（补充）<a hidden class=anchor aria-hidden=true href=#1类和对象的基本概念补充>#</a></h2><h3 id=类的成员函数和类的定义分开写>类的成员函数和类的定义分开写<a hidden class=anchor aria-hidden=true href=#类的成员函数和类的定义分开写>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CRectangle</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>w</span><span class=p>,</span><span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=nf>Area</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=nf>Perimeter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=nf>Init</span><span class=p>(</span><span class=kt>int</span> <span class=n>w_</span><span class=p>,</span><span class=kt>int</span> <span class=n>h_</span><span class=p>);</span><span class=c1>//成员函数仅在此声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>CRectangle</span><span class=o>::</span><span class=n>Area</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>w</span><span class=o>*</span><span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>CRectangle</span><span class=o>::</span><span class=n>Perimeter</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>2</span><span class=o>*</span><span class=p>(</span><span class=n>w</span><span class=o>+</span><span class=n>h</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>CRectangle</span><span class=o>::</span><span class=n>Init</span><span class=p>(</span><span class=kt>int</span> <span class=n>w_</span><span class=p>,</span><span class=kt>int</span> <span class=n>h_</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>w</span><span class=o>=</span><span class=n>w_</span><span class=p>;</span><span class=n>h</span><span class=o>=</span><span class=n>h_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><ul><li>CRectangle:: 说明后面的函数是 CRectangle 类的成员函数，而非普通函数。那么，一定要通过对象或对象的指针或对象的引用才能调用。</li></ul><h3 id=类成员的可访问范围>类成员的可访问范围<a hidden class=anchor aria-hidden=true href=#类成员的可访问范围>#</a></h3><blockquote><p>在类的定义中，用下列访问范围关键字来说明类成员可被访问的范围</p><blockquote><p>private: 私有成员，只能在成员函数内访问</p><p>public: 共有成员，可以在任何地方访问</p><p>protected: 保护成员，以后再说</p></blockquote></blockquote><p>定义一个类</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>classname</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=err>私有属性和函数</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=err>共有属性和函数</span>
</span></span><span class=line><span class=cl>	<span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=err>保护属性和函数</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=err>；</span>
</span></span></code></pre></div><p><strong>如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。</strong></p><blockquote><p>在类的成员函数内部，能够访问</p><blockquote><p>当前对象的全部属性、函数
同类其它对象的全部属性、函数</p></blockquote><p>在类的成员函数以外的地方，只能够访问该类对象的公有成员</p></blockquote><h3 id=私有成员变量的隐藏>私有成员变量的隐藏<a hidden class=anchor aria-hidden=true href=#私有成员变量的隐藏>#</a></h3><p>设置私有成员的机制，叫“<strong>隐藏</strong>”</p><p>“<strong>隐藏</strong>”的目的是强制对成员变量的访问一定要通过成员函数进行，那么以后成员变量的类型等属性修改后，只需要更改成员函数即可。否则，所有直接访问成员变量的语句都需要修改。</p><h3 id=成员函数的重载及参数缺省>成员函数的重载及参数缺省<a hidden class=anchor aria-hidden=true href=#成员函数的重载及参数缺省>#</a></h3><ul><li>成员函数也可以重载</li><li>成员函数也可以带缺省参数</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Location</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=n>init</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=kt>int</span> <span class=n>y</span><span class=o>=</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=nf>valueX</span><span class=p>(</span><span class=kt>int</span> <span class=n>val</span><span class=p>){</span><span class=n>x</span><span class=o>=</span><span class=n>val</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=nf>valueX</span><span class=p>(){</span><span class=k>return</span> <span class=n>x</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Location</span><span class=o>::</span><span class=n>init</span><span class=p>(</span><span class=kt>int</span> <span class=n>X</span><span class=p>,</span><span class=kt>int</span> <span class=n>Y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>x</span><span class=o>=</span><span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>y</span><span class=o>=</span><span class=n>Y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Location</span> <span class=n>A</span><span class=p>,</span><span class=n>B</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span><span class=p>.</span><span class=n>init</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span><span class=p>.</span><span class=n>valueX</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>A</span><span class=p>.</span><span class=n>valueX</span><span class=p>();</span><span class=c1>//输出5
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2构造函数>2.构造函数<a hidden class=anchor aria-hidden=true href=#2构造函数>#</a></h2><h3 id=构造函数的基本概念>构造函数的基本概念<a hidden class=anchor aria-hidden=true href=#构造函数的基本概念>#</a></h3><p>构造函数是成员函数的一种</p><ol><li>名字与类名相同，可以有参数，不能有返回值（void 也不行）</li><li><strong>作用是对对象进行初始化，如给成员变量赋初值</strong></li><li>如果定义类时没写构造函数，则编译器生成一个默认的<strong>无参数</strong>的构造函数。默认构造函数无参数，不做任何操作</li><li>如果定义了构造函数，则编译器不生成默认的无参数的构造函数</li><li><strong>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</strong></li><li>一个类可以有多个构造函数</li></ol><h3 id=构造函数的重要性>构造函数的重要性<a hidden class=anchor aria-hidden=true href=#构造函数的重要性>#</a></h3><ul><li>构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数</li><li>有时对象没被初始化就使用，会导致程序出错</li></ul><h3 id=构造函数的重载>构造函数的重载<a hidden class=anchor aria-hidden=true href=#构造函数的重载>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>double</span> <span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=n>Set</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span><span class=kt>double</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span><span class=c1>//编译器自动生成默认构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Complex</span> <span class=n>c1</span><span class=p>;</span><span class=c1>//默认构造函数被调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Complex</span><span class=o>*</span> <span class=n>pc</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Complex</span><span class=p>;</span><span class=c1>//默认构造函数被调用
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>double</span> <span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span><span class=kt>double</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Complex</span><span class=o>::</span><span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span><span class=kt>double</span> <span class=n>i</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>real</span><span class=o>=</span><span class=n>r</span><span class=p>,</span><span class=n>imag</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Complex</span> <span class=n>c1</span><span class=p>;</span><span class=c1>//error，缺少构造函数的参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Complex</span><span class=o>*</span> <span class=n>pc</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Complex</span><span class=p>;</span><span class=c1>//error，没有参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Complex</span> <span class=nf>c1</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span><span class=c1>//ok
</span></span></span></code></pre></div><ul><li>一个类可以有多个构造函数，只要这多个构造函数的参数个数或者参数类型不同，就形成了重载的关系。</li></ul><blockquote><p>一段话描述“重载”的概念</p><p>在编程中，<strong>重载（Overload）<strong>可以理解为“<strong>同一个名字，多种用法</strong>”。就像你家的洗衣机有一个“洗涤”按钮，但根据你放入的衣物类型（毛衣、羽绒服、衬衫），它会自动调整水温、转速和时间。重载也是类似逻辑：程序员可以给</strong>同一个函数名</strong>写多个版本的实现，而这些版本的<strong>参数必须不同</strong>（比如参数类型、数量或顺序）。例如，一个叫 <code>加法</code> 的函数，既能处理两个整数相加，也能处理三个小数相加，甚至拼接两个字符串——只要参数不同，编译器就能自动根据你传入的数据<strong>匹配对应的版本</strong>。这样一来，代码更简洁直观，开发者不用死记硬背 <code>加整数</code>、<code>加小数</code> 等五花八门的名字，只需记住一个 <code>加法</code> 就能应对多种场景。</p></blockquote><h2 id=3复制构造函数>3.复制构造函数<a hidden class=anchor aria-hidden=true href=#3复制构造函数>#</a></h2><h3 id=复制构造函数的基本概念>复制构造函数的基本概念<a hidden class=anchor aria-hidden=true href=#复制构造函数的基本概念>#</a></h3><ol><li>只有一个参数，即对同类对象的引用</li><li>形如 <code>X::X(X &)</code> 或 <code>X::X(const X &)</code>，二者选一，后者能以常量对象作为参数</li><li>如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>double</span> <span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Complex</span> <span class=n>c1</span><span class=p>;</span><span class=c1>//调用缺省无参构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Complex</span> <span class=nf>c2</span><span class=p>(</span><span class=n>c1</span><span class=p>);</span><span class=c1>//调用缺省的复制构造函数，将c2初始化成和c1一样
</span></span></span></code></pre></div><p><strong>不允许有形如 <code>X::X(X)</code> 的构造函数</strong></p><h3 id=复制构造函数起作用的三种情况>复制构造函数起作用的三种情况<a hidden class=anchor aria-hidden=true href=#复制构造函数起作用的三种情况>#</a></h3><ol><li>当用一个对象去初始化同类的另一个对象时</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Complex</span> <span class=nf>c2</span><span class=p>(</span><span class=n>c1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Complex</span> <span class=n>c2</span><span class=o>=</span><span class=n>c1</span><span class=p>;</span><span class=c1>//等价于上一条语句，这是一条初始化语句，不是赋值语句
</span></span></span></code></pre></div><ol start=2><li>如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类 A 的复制构造函数将被调用</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span><span class=p>(</span><span class=n>A</span><span class=o>&amp;</span><span class=n>a</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Copy constructor called&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Func</span><span class=p>(</span><span class=n>A</span> <span class=n>a1</span><span class=p>){}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span> <span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Func</span><span class=p>(</span><span class=n>a2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//程序输出结果为：Copy constructor called
</span></span></span></code></pre></div><ol start=3><li>如果函数的返回值是类 A 的对象时，则函数返回时，A 的复制构造函数将被调用</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>){</span><span class=n>v</span><span class=o>=</span><span class=n>n</span><span class=p>;};</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span><span class=n>a</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>v</span><span class=o>=</span><span class=n>a</span><span class=p>.</span><span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Copy constructor called&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=nf>Func</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>A</span> <span class=n>b</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>Func</span><span class=p>().</span><span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//输出结果为4
</span></span></span></code></pre></div><hr><h3 id=一点问题>一点问题<a hidden class=anchor aria-hidden=true href=#一点问题>#</a></h3><blockquote><p>在原视频老师的讲解中，输出的内容为</p><blockquote><p>Copy constructor called4</p></blockquote><p>但在 DEV-C++ 5.11 中实际运行以上代码，输出结果为</p><blockquote><p>4</p></blockquote></blockquote><p>原因如下</p><p>根据代码逻辑和 C++ 的拷贝构造函数调用规则，输出结果为：<strong>4</strong>，而不会打印 &ldquo;Copy constructor called&rdquo;。以下是关键原因分析：</p><ol><li><strong>编译器优化（拷贝省略）</strong>
C++ 编译器在函数返回局部对象时，会进行<strong>返回值优化（RVO, Return Value Optimization）</strong>，直接将对象构造在调用处的内存中，<strong>跳过拷贝构造函数的调用</strong>。即使拷贝构造函数显式定义了输出语句，编译器也会优化掉这次拷贝。</li></ol><p>在代码中，<code>Func()</code> 返回局部对象 <code>b</code>，理论上会触发拷贝构造函数。但由于 RVO 优化：</p><p>• <strong>实际构造过程</strong>：直接在 <code>Func()</code> 的返回值内存区域构造 <code>b</code>，无需拷贝。</p><p>• <strong>结果</strong>：<code>cout &lt;&lt; Func().v</code> 直接输出 <code>b.v</code> 的值 <code>4</code>，而不会触发拷贝构造函数的输出。</p><ol start=2><li><strong>若关闭编译器优化</strong></li></ol><p>如果强制关闭优化（例如 GCC 使用 <code>-fno-elide-constructors</code>），代码会输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>Copy</span> <span class=n>constructor</span> <span class=n>called4</span>
</span></span></code></pre></div><p>此时：</p><ul><li><code>Func()</code> 返回 <code>b</code> 时，会调用拷贝构造函数生成临时对象。</li><li>临时对象再被用来访问 <code>v</code>，输出 <code>4</code>。</li></ul><ol start=3><li><strong>代码细节验证</strong></li></ol><ul><li><strong>拷贝构造函数的触发条件</strong>：只有当用<strong>已有对象初始化新对象</strong>时才会调用拷贝构造函数（例如 <code>A a = b;</code>）。而返回值优化场景下，对象直接在目标内存构造，不满足这一条件。</li><li><strong>C++ 标准支持</strong>：C++11 及以后版本中，RVO 是编译器必须支持的优化，即使拷贝/移动构造函数有副作用（如输出语句），优化仍然生效。</li></ul><p>因此 在默认编译选项下，输出为 <strong><code>4</code></strong>。若需验证拷贝构造函数的行为，需通过编译选项关闭优化。</p><hr><p><strong>注意，对象间赋值并不导致复制构造函数被调用</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CMyclass</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>CMyclass</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>	<span class=n>CMyclass</span><span class=p>(</span><span class=n>CMyclass</span> <span class=o>&amp;</span> <span class=n>c</span><span class=p>){</span><span class=n>n</span><span class=o>=</span><span class=mi>2</span><span class=o>*</span><span class=n>c</span><span class=p>.</span><span class=n>n</span><span class=p>;}</span><span class=c1>//此处仅为说明问题，并不推荐复制函数这样书写
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>CMyclass</span> <span class=n>c1</span><span class=p>,</span><span class=n>c2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>c1</span><span class=p>.</span><span class=n>n</span><span class=o>=</span><span class=mi>5</span><span class=p>;</span><span class=n>c2</span><span class=o>=</span><span class=n>c1</span><span class=p>;</span><span class=n>CMyclass</span> <span class=n>c3</span><span class=p>(</span><span class=n>c1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;c2.n=&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c2</span><span class=p>.</span><span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;c3.n=&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c3</span><span class=p>.</span><span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//输出：c2.n=5,c3.n=10
</span></span></span></code></pre></div><h3 id=常量引用参数的使用>常量引用参数的使用<a hidden class=anchor aria-hidden=true href=#常量引用参数的使用>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fun</span><span class=p>(</span><span class=n>CMyclass</span> <span class=n>obj_</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;fun&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>这样的函数，调用时生成形参会引发复制构造函数调用，开销比较大</li><li>所以可以考虑使用 CMyclass &引用类型作为参数</li><li>如果希望确保实参的值在函数中不应被改变，那么可以加上 const 关键字</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fun</span><span class=p>(</span><span class=k>const</span> <span class=n>CMyclass</span> <span class=o>&amp;</span> <span class=n>obj</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=c1>//函数中任何试图改变obj值的语句都变成非法语句
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=4类型转换构造函数>4.类型转换构造函数<a hidden class=anchor aria-hidden=true href=#4类型转换构造函数>#</a></h2><h3 id=什么是类型转换构造函数>什么是类型转换构造函数<a hidden class=anchor aria-hidden=true href=#什么是类型转换构造函数>#</a></h3><ol><li>定义转换构造函数的目的是实现类型的自动转换</li><li>只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数</li><li>当需要时，编译系统会自动调用转换构造函数，建立一个无名的临时对象（或临时变量）</li></ol><h3 id=类型转换构造函数示例>类型转换构造函数示例<a hidden class=anchor aria-hidden=true href=#类型转换构造函数示例>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>double</span> <span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>){</span><span class=c1>//类型转换构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;IntConstructor called&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>real</span><span class=o>=</span><span class=n>i</span><span class=p>;</span><span class=n>imag</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span><span class=kt>double</span> <span class=n>i</span><span class=p>){</span><span class=n>real</span><span class=o>=</span><span class=n>r</span><span class=p>;</span><span class=n>imag</span><span class=o>=</span><span class=n>i</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Complex</span> <span class=n>c1</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Complex</span> <span class=n>c2</span><span class=o>=</span><span class=mi>12</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>c1</span><span class=o>=</span><span class=mi>9</span><span class=p>;</span><span class=c1>//9被自动转换成一个临时Complex对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>c1</span><span class=p>.</span><span class=n>real</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c1</span><span class=p>.</span><span class=n>imag</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=5析构函数>5.析构函数<a hidden class=anchor aria-hidden=true href=#5析构函数>#</a></h2><h3 id=什么是析构函数>什么是析构函数<a hidden class=anchor aria-hidden=true href=#什么是析构函数>#</a></h3><ol><li>名字与类名相同，在前面加 <code>~</code>，没有参数和返回值，一个类最多只能有一个析构函数</li><li>析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等</li><li>如果定义类时没写析构函数，则编译器生成缺省析构函数，缺省析构函数什么也不做</li><li>如果定义了析构函数，则编译器不生成缺省析构函数</li></ol><h3 id=析构函数示例>析构函数示例<a hidden class=anchor aria-hidden=true href=#析构函数示例>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>String</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>char</span><span class=o>*</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>String</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>			<span class=n>p</span><span class=o>=</span><span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>String</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>String</span><span class=o>::~</span><span class=n>String</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=p>[]</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=析构函数和数组>析构函数和数组<a hidden class=anchor aria-hidden=true href=#析构函数和数组>#</a></h3><ul><li>对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Ctest</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>Ctest</span><span class=p>(){</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;destructor called&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Ctest</span> <span class=n>array</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;End Main&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>End Main
</span></span><span class=line><span class=cl>destructor called
</span></span><span class=line><span class=cl>destructor called
</span></span></code></pre></div><h3 id=析构函数和运算符-delete>析构函数和运算符 delete<a hidden class=anchor aria-hidden=true href=#析构函数和运算符-delete>#</a></h3><ul><li>delete 运算导致析构函数被调用</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Ctest</span><span class=o>*</span> <span class=n>pTest</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pTest</span><span class=o>=</span><span class=k>new</span> <span class=n>Ctest</span><span class=p>;</span><span class=c1>//构造函数调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>delete</span> <span class=n>pTest</span><span class=p>;</span><span class=c1>//析构函数调用
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>pTest</span><span class=o>=</span><span class=k>new</span> <span class=n>Ctest</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span><span class=c1>//构造函数调用3次
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>delete</span> <span class=p>[]</span><span class=n>pTest</span><span class=p>;</span><span class=c1>//析构函数调用3次
</span></span></span></code></pre></div><ul><li>若 new 一个对象数组，那么用 delete 释放时应该写 []。否则只 delete 一个对象（调用一次析构函数）</li></ul><h2 id=6构造函数析构函数调用时机>6.构造函数析构函数调用时机<a hidden class=anchor aria-hidden=true href=#6构造函数析构函数调用时机>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Demo</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Demo</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>id</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;id=&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; constructed&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>Demo</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;id=&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; destructed&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Demo</span> <span class=nf>d1</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Func</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=n>Demo</span> <span class=n>d2</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Demo</span> <span class=n>d3</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;func&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Demo</span> <span class=n>d4</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>d4</span><span class=o>=</span><span class=mi>6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;main&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>Demo</span> <span class=n>d5</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>Func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;main ends&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>1</span> <span class=n>constructed</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>4</span> <span class=n>constructed</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>6</span> <span class=n>constructed</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>6</span> <span class=n>destructed</span>
</span></span><span class=line><span class=cl><span class=n>main</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>5</span> <span class=n>constructed</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>5</span> <span class=n>destructed</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>2</span> <span class=n>constructed</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>3</span> <span class=n>constructed</span>
</span></span><span class=line><span class=cl><span class=k>func</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>3</span> <span class=n>destructed</span>
</span></span><span class=line><span class=cl><span class=n>main</span> <span class=n>ends</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>6</span> <span class=n>destructed</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>2</span> <span class=n>destructed</span>
</span></span><span class=line><span class=cl><span class=n>id</span><span class=o>=</span><span class=mi>1</span> <span class=n>destructed</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/c++/>C++</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/c++3/><span class=title>« 上一页</span><br><span>面向对象的程序设计学习笔记 3</span>
</a><a class=next href=http://localhost:1313/posts/c++1/><span class=title>下一页 »</span><br><span>面向对象的程序设计学习笔记 1</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 2 on x" href="https://x.com/intent/tweet/?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%202&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b2%2f&amp;hashtags=C%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b2%2f&amp;title=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%202&amp;summary=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%202&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 2 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b2%2f&title=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%202"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 2 on whatsapp" href="https://api.whatsapp.com/send?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%202%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 2 on telegram" href="https://telegram.me/share/url?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%202&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%202&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Kibrac's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>