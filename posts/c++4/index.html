<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>面向对象的程序设计学习笔记 4 | Kibrac's Blog</title>
<meta name=keywords content="C++"><meta name=description content="第四章 运算符重载"><meta name=author content="Kibrac"><link rel=canonical href=http://localhost:1313/posts/c++4/><link crossorigin=anonymous href=/assets/css/stylesheet.ae3d277e69647c027e65dd7c785748f912a9be2d37da0061b9ff15a5d7fafb7b.css integrity="sha256-rj0nfmlkfAJ+Zd18eFdI+RKpvi032gBhuf8Vpdf6+3s=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:1313/posts/c++4/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/c++4/"><meta property="og:site_name" content="Kibrac's Blog"><meta property="og:title" content="面向对象的程序设计学习笔记 4"><meta property="og:description" content="第四章 运算符重载"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-08T18:03:55+08:00"><meta property="article:modified_time" content="2025-05-08T18:03:55+08:00"><meta property="article:tag" content="C++"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="面向对象的程序设计学习笔记 4"><meta name=twitter:description content="第四章 运算符重载"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"面向对象的程序设计学习笔记 4","item":"http://localhost:1313/posts/c++4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"面向对象的程序设计学习笔记 4","name":"面向对象的程序设计学习笔记 4","description":"第四章 运算符重载","keywords":["C++"],"articleBody":"课程链接：程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)\n1.运算符重载的基本概念 运算符重载的需求 在数学上，两个复数可以直接进行 +、- 等运算。但是在 C++ 中，直接将 + 或 - 用于复数对象是不允许的。\n但有时我们会希望，让对象也能够通过运算符进行计算。这样代码更简洁也更容易理解。\n例如：complex_a 和 complex_b 是两个复数对象，那求这两个复数的和，我们希望能直接写 complex_a + complex_b\n运算符重载，就是对已有的运算符（C++ 中预定义的运算符）赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为。\n运算符重载的目的是：扩展 C++ 中提供的运算符的适用范围，使之能作用于对象。 同一个运算符，对不同类型的操作数，所发生的行为不同。 运算符重载的形式 运算符重载的实质是函数重载 可以重载为普通函数，也可以重载为成员函数 把含运算符的表达式转换成运算符函数的调用 把运算符的操作数转换成运算符函数的参数 运算符被多次重载时，根据实参的类型决定调用哪个运算符参数 返回值类型 operator 运算符(形参表) { …… } 运算符重载示例 #include using namespace std; class Complex{ public: double real,imag; Complex(double r=0.0,double i=0.0):real(r),imag(i){} Complex operator-(const Complex\u0026 c); }; Complex operator+(const Complex\u0026 a,const Complex\u0026 b){ return Complex(a.real+b.real,a.imag+b.imag);//返回一个临时对象 } Complex Complex::operator-(const Complex\u0026 c){ return Complex(real-c.real,imag-c.imag);//返回一个临时对象 } int main(){ Complex a(4,4),b(1,1),c; c=a+b;//等价于c=operator+(a,b); cout \u003c\u003c c.real \u003c\u003c \",\" \u003c\u003c c.imag \u003c\u003c endl; cout \u003c\u003c (a-b).real \u003c\u003c \",\" \u003c\u003c (a-b).imag \u003c\u003c endl; //a-b等价于a.operator-(b); return 0; } 重载为成员函数时，参数个数为运算符目数减一 重载为普通函数时，参数个数为运算符目数 上述示例输出为\n5,5 3,3 2.赋值运算符的重载 有时候希望赋值运算符两边的类型可以不匹配，比如，把一个 int 类型变量赋值给一个 Complex 对象，或把一个 char* 类型的字符串赋值给一个字符串对象，此时就需要重载赋值运算符 =。\n赋值运算符 = 只能重载为成员函数。\n#include #include using namespace std; class String{ private: char* str; public: String():str(new char[1]){str[0]=0;} const char* c_str(){return str;}; String\u0026 operator=(const char* s); ~String(){delete []str;} }; String\u0026 String::operator=(const char* s){ //重载\"=\"以使得obj=\"hello\"能够成立 delete []str; str=new char [strlen(s)+1]; strcpy(str,s); return* this; } int main(){ String s; s=\"Good Luck,\";//等价于s.operator=(\"Good Luck\"); cout \u003c\u003c s.c_str() \u003c\u003c endl; //String s2=\"hello\"; //上面这条语句要是不注释就会报错 s=\"Shenzhou 8!\";//等价于s.operator=(\"Shenzhou 8!\"); cout \u003c\u003c s.c_str() \u003c\u003c endl; return 0; } 浅拷贝和深拷贝 这里仍然使用上述示例进行演示\nclass String{ private: char* str; public: String():str(new char[1]){str[0]=0;} const char* c_str(){return str;}; String\u0026 operator=(const char* s){ delete []str; str=new char [strlen(s)+1]; strcpy(str,s); return* this; }; ~String(){delete []str;} }; 在按照上述方法定义类之后，进行如下操作\nString S1,S2; S1=\"this\";//ok S2=\"that\";//ok S1=S2;//这是有严重问题的 如不定义自己的赋值运算符，那么 S1=S2 实际上会导致 S1.str 和 S2.str 指向同一地方。 如果 S1 对象消亡，析构函数将会释放 S1.str 指向的空间，则 S2 消亡时还要释放一次，不妥。 另外，如果执行 S1=\"other\";，会导致 S2.str 指向的地方被 delete。 因此要在 class String 里添加成员函数 String\u0026 operator=(const String\u0026 s){ if(this==\u0026s) return* this; delete []str; str=new char[strlen(s.str)+1]; strcpy(str,s.str); return* this; } 一点补充：关于 C++ 中赋值运算符 = 的行为 基本数据类型（如 int, double, char）\n当对基本数据类型使用 = 时，赋值操作会直接将右侧变量的值复制给左侧变量。例如： int a = 10; int b = 20; a = b; // 将 b 的值（20）复制到 a 中 此时，a 和 b 是两个完全独立的变量。修改 a 的值不会影响 b，反之亦然。\n关键点：这里没有指针或内存共享，只是简单的值拷贝。\n对象（类或结构体实例）\n如果赋值的是对象（例如自定义的类或结构体），默认行为是逐个复制对象的成员变量。这种行为称为“浅拷贝”。例如： class Student { public: int age; std::string name; }; Student s1{20, \"Alice\"}; Student s2; s2 = s1; // 复制 s1 的 age 和 name 到 s2 此时，s2.age 和 s2.name 的值与 s1 完全相同。但如果类中包含指针成员，浅拷贝会导致问题：\nclass ShallowCopyExample { public: int* data; // 假设 data 指向堆内存 }; ShallowCopyExample obj1; obj1.data = new int(100); ShallowCopyExample obj2; obj2 = obj1; // 浅拷贝：obj2.data 和 obj1.data 指向同一块内存 此时，修改 *obj1.data 会影响 *obj2.data，因为它们共享同一内存。如果释放其中一个对象的 data，另一个对象的指针将指向无效内存（悬空指针）。\n关键点：对象默认赋值是浅拷贝，需手动实现深拷贝来复制指针指向的内容。\n指针类型\n指针变量存储的是内存地址。使用 = 赋值指针时，只会复制地址值，不会复制指针指向的内容。例如： int* a = new int(100); int* b = new int(200); a = b; // a 现在指向 b 的地址（即 200 所在的内存） 赋值后，a 和 b 指向同一块内存。修改 *a 会影响 *b，因为它们操作的是同一地址。此外，原 a 指向的内存（值为 100）会因未释放而导致内存泄漏。\n关键点：指针赋值是地址的复制，不涉及内容拷贝；操作同一内存需谨慎。\nSTL 容器（如 std::string, std::vector）\nSTL 容器（如字符串、动态数组）的 = 运算符已经被设计为执行“深拷贝”。例如： std::vector\u003cint\u003e v1{1, 2, 3}; std::vector\u003cint\u003e v2; v2 = v1; // 深拷贝：v2 复制了 v1 的所有元素到独立内存中 此时，修改 v1[0] = 100 不会影响 v2[0]，因为两者存储在不同的内存区域。\n关键点：STL 容器默认支持深拷贝，赋值后内容完全独立。\n赋值与指针指向的内容\n当被赋值的变量是指针时，a = b 仅让 a 指向 b 的地址，而不是复制 b 指向的内容。若需要复制内容，必须显式操作： int* b = new int(200); int* a = new int(*b); // 显式复制 b 指向的内容到新内存 此时，a 和 b 指向不同的内存，但内容相同。\n关键点：指针赋值不复制内容，需手动分配新内存并复制。\n总结\n• 基本类型：直接复制值。\n• 对象：默认浅拷贝（复制成员变量，共享指针成员的内存）。\n• 指针：复制地址，共享同一内存。\n• STL 容器：深拷贝，内容完全独立。\n核心原则：= 是否复制内容取决于操作数的类型。指针和对象可能共享内存，而基本类型和 STL 容器默认不共享。\n注意 对运算符进行重载的时候，好的风格是应该尽量保留运算符原本的特性。\n为 String 类编写复制构造函数的时候会面临和 = 同样的问题，用同样的方法处理。\nString(String\u0026 s){ //这里不用判断是否和原对象一致 //因为对象是刚刚复制出来的不可能是同一个 str=new char[strlen(s.str)+1]; strcpy(str,s.str); } 3.运算符重载为友元函数 一般情况下，将运算符重载为类的成员函数是较好的选择。 但有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。 举例如下\nclass Complex{ double real,imag; public: Complex(double r,double i):real(r),imag(i){}; Complex operator+(double r); }; Complex Complex::operator+(double r){//能解释c+5 return Complex(real+r,imag); } 经过上述重载\nComplex c; c=c+5;//有定义，相当于c=c.operator+5; 但是\nc=5+c;//编译出错 所以，为了使上述的表达式能成立，需要将 + 重载为普通函数。\nComplex operator+(double r,const Complex\u0026 c){//能解释5+c return Complex(c.real+r,c.imag); } 但是普通函数又不能访问私有成员，所以，需要将运算符 + 重载为友元。\nclass Complex{ double real,imag; public: Complex(double r,double i):real(r),imag(i){}; Complex operator+(double r); friend Complex operator+(double r,const Complex\u0026 c); }; 4.运算符重载实例：可变长整型数组 为了实现上述图片中描述的功能，创建如下的类\nclass CArray{ int size;//数组元素的个数 int* ptr;//指向动态分配的数组 public: CArray(int s=0);//s代表数组元素的个数 CArray(CArray\u0026 a); ~CArray(); void push_back(int v);//用于在数组尾部添加一个元素v CArray\u0026 operator=(const CArray\u0026 a);//用于数组对象间的赋值 int length(){return size;}//返回数组元素个数 int\u0026 CArray::operator[](int i){ //返回值为int不行！不支持a[i]=4 //因为非引用的函数返回值不可以作为左值使用 //这里的重载用以支持根据下标访问数组元素，如n=a[i];和a[i]=4;这样的语句 return ptr[i]; } }; 构造函数与复制构造函数如下\nCArray::CArray(int s):size(s){ if(s==0) ptr=NULL; else ptr=new int[s]; } CArray::CArray(CArray\u0026 a){ if(!a.ptr){ ptr=NULL; size=0; return; } ptr=new int[a.size]; memcpy(ptr,a.ptr,sizeof(int)*a.size); size=a.size; } 析构函数与 = 的运算符重载如下\nCArray::~CArray(){ if(ptr) delete []ptr; } CArray\u0026 CArray::operator=(const CArray\u0026 a){ //赋值号的作用手机是使=左边的对象里存放的数组，大小和内容都和右边的对象一样 if(ptr==a.ptr)//防止a=a这样的赋值导致出错 return* this; if(a.ptr==NULL){//如果a里面的数组是空的 if(ptr) delete []ptr; ptr=NULL; size=0; return* this; } if(size\u003ca.size){//如果原有空间够大，就不用分配新的空间 if(ptr) delete []ptr; ptr=new int[a.size]; } memcpy(ptr,a.ptr,sizeof(int)*a.size); size=a.size; return* this; }//CArray\u0026 CArray::operator=(const CArray\u0026 a) 最后是 push_back 函数，下面的写法实际上是比较低效的，因为每一次添加元素都会需要重新分配空间，造成大量的时间开销，比较好的做法有事先分配一片较大空间，并且在扩容时不使用逐一递增可以采用翻倍等方式\nvoid CArray::push_back(int v){//在数组尾部添加一个元素 if(ptr){ int* tmpPtr=new int[size+1];//重新分配空间 memcpy(tmpPtr,ptr,sizeof(int)*size);//拷贝原数组内容 delete []ptr; ptr=tmpPtr; } else//如果数组本来是空的 ptr=new int[1]; ptr[size++]=v;//加入新的数组元素 } 5.流插入运算符和流提取运算符的重载 本小节中提到的流插入运算符和流提取运算符本质上是左移运算符和右移运算符进行重载。\n问题引入 cout \u003c\u003c 5 \u003c\u003c \"this\" 为什么能够成立？\ncout 是什么？\n\u003c\u003c 为什么能用在 cout 上？\n流插入运算符的重载 cout 是在头文件 iostream 中定义的，ostream 类的对象 \u003c\u003c 能用在 cout 上是因为在 iostream 里对其进行了重载 ostream\u0026 ostream::operator\u003c\u003c(int n){ ......//输出n的代码 return* this; } ostream\u0026 ostream::operator\u003c\u003c(const char* s){ ......//输出s的代码 return* this; } 在上述的重载过程当中，将返回值类型设置为 ostream\u0026 以及返回 * this 的目的是使 \u003c\u003c 作用之后的返回值类型不变，这样就可以继续被 \u003c\u003c 作用。\ncout \u003c\u003c 5 \u003c\u003c \"this\" 本质上的函数调用形式是\ncout.operator \u003c\u003c (5).operator \u003c\u003c (\"this\") 举例如下\n假定下面程序输出为 5hello，应该补写什么？\nclass CStudent{ public: int nAge; }; int main(){ CStudent s; s.nAge=5; cout \u003c\u003c s \u003c\u003c \"hello\"; return 0; } 答案如下\nostream\u0026 operator\u003c\u003c(ostream\u0026 o,const CStudent\u0026 s){ o\u003c\u003cs.nAge; return o; } 一个复杂举例 假定 c 是 Complex 复数类的对象，现在希望写 cout \u003c\u003c c;，就能以 a+bi 的形式输出 c 的值，写 cin \u003e\u003e c;，就能从键盘接受 a+bi 形式的输入，并且使得 c.real=a,c,imag=b。\nint main(){ Complex c; int n; cin \u003e\u003e c \u003e\u003e n; cout \u003c\u003c c \u003c\u003c \",\" \u003c\u003c n; return 0; } 程序运行结果可以如下\n13.2+133i 87↓ 13.2+133i,87 完整程序如下\n#include #include #include using namespace std; class Complex{ double real,imag; public: Complex(double r=0,double i=0):real(r),imag(i){}; friend ostream\u0026 operator\u003c\u003c(ostream\u0026 os,const Complex\u0026 c); friend istream\u0026 operator\u003e\u003e(istream\u0026 is,Complex\u0026 c); }; ostream\u0026 operator\u003c\u003c(ostream\u0026 os,const Complex\u0026 c){ os \u003c\u003c c.real \u003c\u003c \"+\" \u003c\u003c c.imag \u003c\u003c \"i\";//以\"a+bi\"的形式输出 return os; } istream\u0026 operator\u003e\u003e(istream\u0026 is,Complex\u0026 c){ string s; is \u003e\u003e s;//将\"a+bi\"作为字符串读入，\"a+bi\"中间不能有空格 int pos=s.find(\"+\",0); string sTmp=s.substr(0,pos);//分离出代表实部的字符串 c.real=atof(sTmp.c_str());//atof函数能将const char*指针指向的内容转换成float sTmp=s.substr(pos+1,s.length()-pos-2);//分离出代表虚部的字符串 c.imag=atof(sTmp.c_str()); return is; } int main(){ Complex c; int n; cin \u003e\u003e c \u003e\u003e n; cout \u003c\u003c c \u003c\u003c \",\" \u003c\u003c n; return 0; } 事实上以上程序可以进行优化，优化内容如下：\n支持负数虚部​ 使用 find_last_of(\"+-\") 替代 find(\"+\")，兼容虚部为负的情况（如 3-4i）。 ​格式校验​​ 检查输入字符串是否以 i 结尾 检查分隔符位置有效性（避免首字符为分隔符） 错误处理​​ 通过 is.setstate(ios::failbit) 设置流错误状态，使程序能处理无效输入。 #include #include #include using namespace std; class Complex { double real, imag; public: Complex(double r = 0, double i = 0) : real(r), imag(i) {} friend ostream\u0026 operator\u003c\u003c(ostream\u0026 os, const Complex\u0026 c); friend istream\u0026 operator\u003e\u003e(istream\u0026 is, Complex\u0026 c); // 修正1：移除const }; ostream\u0026 operator\u003c\u003c(ostream\u0026 os, const Complex\u0026 c) { os \u003c\u003c c.real \u003c\u003c \"+\" \u003c\u003c c.imag \u003c\u003c \"i\"; return os; } istream\u0026 operator\u003e\u003e(istream\u0026 is, Complex\u0026 c) { string s; is \u003e\u003e s; // 检查字符串以i结尾 if (s.empty() || s.back() != 'i') { is.setstate(ios::failbit); return is; } // 查找最后一个+或-作为分隔符 size_t pos = s.find_last_of(\"+-\"); if (pos == string::npos || pos == 0) { is.setstate(ios::failbit); return is; } // 分割实部和虚部 string realPart = s.substr(0, pos); string imagPart = s.substr(pos, s.size() - pos - 1); // 去掉i c.real = atof(realPart.c_str()); c.imag = atof(imagPart.c_str()); return is; } int main() { Complex c; int n; cin \u003e\u003e c \u003e\u003e n; cout \u003c\u003c c \u003c\u003c \",\" \u003c\u003c n; return 0; } 6.类型转换运算符和自增、自减运算符的重载 重载类型转换运算符 #include using namespace std; class Complex{ double real,imag; public: Complex(double r=0,double i=0):real(r),imag(i){}; operator double(){return real;}//重载强制类型转换运算符double }; int main(){ Complex c(1.2,3.4); cout \u003c\u003c (double)c \u003c\u003c endl;//输出1.2 double n=2+c;//等价于double n=2+c.operator double() cout \u003c\u003c n;//输出3.2 } 自增、自减运算符的重载 自增运算符 ++、自减运算符 -- 有前置/后置之分，为了区分所重载的是前置运算符还是后置运算符，C++ 规定\n前置运算符作为一元运算符重载\n重载为成员函数 T\u0026 operator++(); T\u0026 operator--(); 重载为全局函数 T1\u0026 operator++(T2); T1\u0026 operator--(T2); 后置运算符作为二元运算符重载，多写一个没用的参数 重载为成员函数 T operator++(int); T operator--(int); 重载为全局函数 T1 operator++(T2,int); T1 operator--(T2,int); 在没有后置运算符重载而有前置运算符重载的情况下，在 Visual Studio 中，obj++ 也调用前置重载，而 DEV C++ 则令 obj++ 编译出错。\n举例说明，如下是希望实现的功能\nint main(){ CDemo d(5); cout \u003c\u003c (d++) \u003c\u003c \",\";//等价于d.operator++(0); cout \u003c\u003c d \u003c\u003c \",\"; cout \u003c\u003c (++d) \u003c\u003c \",\";//等价于d.operator++(); cout \u003c\u003c d \u003c\u003c endl; cout \u003c\u003c (d--) \u003c\u003c \",\";//等价于d.operator--(d,0); cout \u003c\u003c d \u003c\u003c \",\"; cout \u003c\u003c (--d) \u003c\u003c \",\";//等价于d.operator--(d); cout \u003c\u003c d \u003c\u003c endl; return 0; } 预期的输出结果为\n5,6,7,7 7,6,5,5 那么应该如何编写 CDemo？\nclass CDemo{ private: int n; public: CDemo(int i=0):n(i){} CDemo\u0026 operator++();//用于前置形式 CDemo operator++(int);//用于后置形式 operator int(){return n;}; friend CDemo\u0026 operator--(CDemo\u0026); friend CDemo operator--(CDemo\u0026,int); }; CDemo\u0026 CDemo::operator++(){//前置++ ++n; return* this; }//++s即为s.operator++(); CDemo CDemo::operator++(int k){//后置++ CDemo tmp(*this);//记录修改前的对象 n++; return tmp;//返回修改前的对象 }//s++即为s.operator(0); CDemo\u0026 operator--(CDemo\u0026 d){//前置-- d.n--; return d; }//--s即为operator--(s); CDemo operator--(CDemo\u0026 d,int){//后置-- CDemo tmp(d); d.n--; return tmp; }//s--即为operator--(s,0); 一点补充：前置与后置的不同 自增（++）和自减（--）运算符的前置（如 ++i）与后置（如 i++）的区别在于：\n返回值：前置运算符返回运算后的新值，后置运算符返回运算前的原始值； 执行顺序：前置先增减再使用值，后置先使用值再增减； 性能：前置无需创建临时变量，效率更高；后置需保留原始值的副本，可能产生额外开销； 重载实现：C++ 中通过参数区分，前置无参数（T\u0026 operator++()），后置用伪参数（T operator++(int)）。\n例如：int a=5; b=++a 后 a=6, b=6，而 b=a++ 后 a=6, b=5。 运算符重载的注意事项 C++ 不允许定义新的运算符； 重载后运算符的含义应该符合日常习惯； 运算符重载不改变运算符的优先级； 以下运算符不能被重载：. .* :: ?: sizeof； 重载运算符 () [] -\u003e 或者赋值运算符 = 时，运算符重载函数必须声明为类的成员函数。 ","wordCount":"5560","inLanguage":"zh","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-05-08T18:03:55+08:00","dateModified":"2025-05-08T18:03:55+08:00","author":{"@type":"Person","name":"Kibrac"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/c++4/"},"publisher":{"@type":"Organization","name":"Kibrac's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Kibrac's Blog (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Kibrac's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=归档><span>归档</span></a></li><li><a href=http://localhost:1313/categories/ title=分类><span>分类</span></a></li><li><a href=http://localhost:1313/tags/ title=标签><span>标签</span></a></li><li><a href=http://localhost:1313/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">面向对象的程序设计学习笔记 4</h1><div class=post-description>第四章 运算符重载</div><div class=post-meta><span title='2025-05-08 18:03:55 +0800 CST'>五月 8, 2025</span>&nbsp;·&nbsp;12 分钟&nbsp;·&nbsp;5560 字&nbsp;·&nbsp;Kibrac</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1运算符重载的基本概念>1.运算符重载的基本概念</a><ul><li><a href=#运算符重载的需求>运算符重载的需求</a></li><li><a href=#运算符重载的形式>运算符重载的形式</a></li><li><a href=#运算符重载示例>运算符重载示例</a></li></ul></li><li><a href=#2赋值运算符的重载>2.赋值运算符的重载</a><ul><li><a href=#浅拷贝和深拷贝>浅拷贝和深拷贝</a></li><li><a href=#一点补充关于-c-中赋值运算符--的行为>一点补充：关于 C++ 中赋值运算符 <code>=</code> 的行为</a></li><li><a href=#注意>注意</a></li></ul></li><li><a href=#3运算符重载为友元函数>3.运算符重载为友元函数</a></li><li><a href=#4运算符重载实例可变长整型数组>4.运算符重载实例：可变长整型数组</a></li><li><a href=#5流插入运算符和流提取运算符的重载>5.流插入运算符和流提取运算符的重载</a><ul><li><a href=#问题引入>问题引入</a></li><li><a href=#流插入运算符的重载>流插入运算符的重载</a></li><li><a href=#一个复杂举例>一个复杂举例</a></li></ul></li><li><a href=#6类型转换运算符和自增自减运算符的重载>6.类型转换运算符和自增、自减运算符的重载</a><ul><li><a href=#重载类型转换运算符>重载类型转换运算符</a></li><li><a href=#自增自减运算符的重载>自增、自减运算符的重载</a></li><li><a href=#一点补充前置与后置的不同>一点补充：前置与后置的不同</a></li><li><a href=#运算符重载的注意事项>运算符重载的注意事项</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>课程链接：<a href=https://www.icourse163.org/course/PKU-1002029030>程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)</a></p><h2 id=1运算符重载的基本概念>1.运算符重载的基本概念<a hidden class=anchor aria-hidden=true href=#1运算符重载的基本概念>#</a></h2><h3 id=运算符重载的需求>运算符重载的需求<a hidden class=anchor aria-hidden=true href=#运算符重载的需求>#</a></h3><blockquote><p>在数学上，两个复数可以直接进行 <code>+</code>、<code>-</code> 等运算。但是在 C++ 中，直接将 <code>+</code> 或 <code>-</code> 用于复数对象是不允许的。</p><p>但有时我们会希望，让对象也能够通过运算符进行计算。这样代码更简洁也更容易理解。</p><p>例如：<code>complex_a</code> 和 <code>complex_b</code> 是两个复数对象，那求这两个复数的和，我们希望能直接写 <code>complex_a + complex_b</code></p></blockquote><p><strong>运算符重载</strong>，就是对已有的运算符（C++ 中预定义的运算符）赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为。</p><ul><li>运算符重载的目的是：扩展 C++ 中提供的运算符的适用范围，使之能作用于对象。</li><li>同一个运算符，对不同类型的操作数，所发生的行为不同。</li></ul><h3 id=运算符重载的形式>运算符重载的形式<a hidden class=anchor aria-hidden=true href=#运算符重载的形式>#</a></h3><ul><li>运算符重载的实质是函数重载</li><li>可以重载为普通函数，也可以重载为成员函数</li><li>把含运算符的表达式转换成运算符函数的调用</li><li>把运算符的操作数转换成运算符函数的参数</li><li>运算符被多次重载时，根据实参的类型决定调用哪个运算符参数</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=err>返回值类型</span> <span class=k>operator</span> <span class=err>运算符</span><span class=p>(</span><span class=err>形参表</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=err>……</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=运算符重载示例>运算符重载示例<a hidden class=anchor aria-hidden=true href=#运算符重载示例>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>double</span> <span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=o>=</span><span class=mf>0.0</span><span class=p>,</span><span class=kt>double</span> <span class=n>i</span><span class=o>=</span><span class=mf>0.0</span><span class=p>)</span><span class=o>:</span><span class=n>real</span><span class=p>(</span><span class=n>r</span><span class=p>),</span><span class=n>imag</span><span class=p>(</span><span class=n>i</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span> <span class=k>operator</span><span class=o>-</span><span class=p>(</span><span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Complex</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span><span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>Complex</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>real</span><span class=o>+</span><span class=n>b</span><span class=p>.</span><span class=n>real</span><span class=p>,</span><span class=n>a</span><span class=p>.</span><span class=n>imag</span><span class=o>+</span><span class=n>b</span><span class=p>.</span><span class=n>imag</span><span class=p>);</span><span class=c1>//返回一个临时对象 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Complex</span> <span class=n>Complex</span><span class=o>::</span><span class=k>operator</span><span class=o>-</span><span class=p>(</span><span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>Complex</span><span class=p>(</span><span class=n>real</span><span class=o>-</span><span class=n>c</span><span class=p>.</span><span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=o>-</span><span class=n>c</span><span class=p>.</span><span class=n>imag</span><span class=p>);</span><span class=c1>//返回一个临时对象 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Complex</span> <span class=n>a</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=mi>4</span><span class=p>),</span><span class=n>b</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span><span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>c</span><span class=o>=</span><span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=p>;</span><span class=c1>//等价于c=operator+(a,b);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>c</span><span class=p>.</span><span class=n>real</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c</span><span class=p>.</span><span class=n>imag</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>a</span><span class=o>-</span><span class=n>b</span><span class=p>).</span><span class=n>real</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>a</span><span class=o>-</span><span class=n>b</span><span class=p>).</span><span class=n>imag</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//a-b等价于a.operator-(b);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></div><ul><li>重载为成员函数时，参数个数为运算符目数减一</li><li>重载为普通函数时，参数个数为运算符目数</li></ul><p>上述示例输出为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>5,5
</span></span><span class=line><span class=cl>3,3
</span></span></code></pre></div><h2 id=2赋值运算符的重载>2.赋值运算符的重载<a hidden class=anchor aria-hidden=true href=#2赋值运算符的重载>#</a></h2><p>有时候希望赋值运算符两边的类型可以不匹配，比如，把一个 <code>int</code> 类型变量赋值给一个 <code>Complex</code> 对象，或把一个 <code>char*</code> 类型的字符串赋值给一个字符串对象，此时就需要重载赋值运算符 <code>=</code>。</p><p><strong>赋值运算符 <code>=</code> 只能重载为成员函数。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstring&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>String</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>String</span><span class=p>()</span><span class=o>:</span><span class=n>str</span><span class=p>(</span><span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=mi>1</span><span class=p>]){</span><span class=n>str</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>c_str</span><span class=p>(){</span><span class=k>return</span> <span class=n>str</span><span class=p>;};</span>
</span></span><span class=line><span class=cl>		<span class=n>String</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>String</span><span class=p>(){</span><span class=k>delete</span> <span class=p>[]</span><span class=n>str</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>String</span><span class=o>&amp;</span> <span class=n>String</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=c1>//重载&#34;=&#34;以使得obj=&#34;hello&#34;能够成立
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>delete</span> <span class=p>[]</span><span class=n>str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>str</span><span class=o>=</span><span class=k>new</span> <span class=kt>char</span> <span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>String</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>s</span><span class=o>=</span><span class=s>&#34;Good Luck,&#34;</span><span class=p>;</span><span class=c1>//等价于s.operator=(&#34;Good Luck&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>s</span><span class=p>.</span><span class=n>c_str</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//String s2=&#34;hello&#34;;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//上面这条语句要是不注释就会报错
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>s</span><span class=o>=</span><span class=s>&#34;Shenzhou 8!&#34;</span><span class=p>;</span><span class=c1>//等价于s.operator=(&#34;Shenzhou 8!&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>s</span><span class=p>.</span><span class=n>c_str</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></div><h3 id=浅拷贝和深拷贝>浅拷贝和深拷贝<a hidden class=anchor aria-hidden=true href=#浅拷贝和深拷贝>#</a></h3><p>这里仍然使用上述示例进行演示</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>String</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>String</span><span class=p>()</span><span class=o>:</span><span class=n>str</span><span class=p>(</span><span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=mi>1</span><span class=p>]){</span><span class=n>str</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>c_str</span><span class=p>(){</span><span class=k>return</span> <span class=n>str</span><span class=p>;};</span>
</span></span><span class=line><span class=cl>		<span class=n>String</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=k>delete</span> <span class=p>[]</span><span class=n>str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>str</span><span class=o>=</span><span class=k>new</span> <span class=kt>char</span> <span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>			<span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>		<span class=p>};</span>
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>String</span><span class=p>(){</span><span class=k>delete</span> <span class=p>[]</span><span class=n>str</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在按照上述方法定义类之后，进行如下操作</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>String</span> <span class=n>S1</span><span class=p>,</span><span class=n>S2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>S1</span><span class=o>=</span><span class=s>&#34;this&#34;</span><span class=p>;</span><span class=c1>//ok
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>S2</span><span class=o>=</span><span class=s>&#34;that&#34;</span><span class=p>;</span><span class=c1>//ok
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>S1</span><span class=o>=</span><span class=n>S2</span><span class=p>;</span><span class=c1>//这是有严重问题的
</span></span></span></code></pre></div><ul><li>如不定义自己的赋值运算符，那么 <code>S1=S2</code> 实际上会导致 <code>S1.str</code> 和 <code>S2.str</code> 指向同一地方。</li><li>如果 <code>S1</code> 对象消亡，析构函数将会释放 <code>S1.str</code> 指向的空间，则 <code>S2</code> 消亡时还要释放一次，不妥。</li><li>另外，如果执行 <code>S1="other";</code>，会导致 <code>S2.str</code> 指向的地方被 delete。</li><li>因此要在 <code>class String</code> 里添加成员函数</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>String</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>String</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=k>this</span><span class=o>==&amp;</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=p>[]</span><span class=n>str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>str</span><span class=o>=</span><span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>str</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>s</span><span class=p>.</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h3 id=一点补充关于-c-中赋值运算符--的行为>一点补充：关于 C++ 中赋值运算符 <code>=</code> 的行为<a hidden class=anchor aria-hidden=true href=#一点补充关于-c-中赋值运算符--的行为>#</a></h3><ol><li>基本数据类型（如 int, double, char）<br>当对基本数据类型使用 <code>=</code> 时，赋值操作会直接将右侧变量的值复制给左侧变量。例如：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>  <span class=c1>// 将 b 的值（20）复制到 a 中
</span></span></span></code></pre></div><p>此时，<code>a</code> 和 <code>b</code> 是两个完全独立的变量。修改 <code>a</code> 的值不会影响 <code>b</code>，反之亦然。<br>关键点：这里没有指针或内存共享，只是简单的值拷贝。</p><ol start=2><li>对象（类或结构体实例）<br>如果赋值的是对象（例如自定义的类或结构体），默认行为是逐个复制对象的成员变量。这种行为称为“浅拷贝”。例如：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Student</span> <span class=n>s1</span><span class=p>{</span><span class=mi>20</span><span class=p>,</span> <span class=s>&#34;Alice&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Student</span> <span class=n>s2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>s2</span> <span class=o>=</span> <span class=n>s1</span><span class=p>;</span>  <span class=c1>// 复制 s1 的 age 和 name 到 s2
</span></span></span></code></pre></div><p>此时，<code>s2.age</code> 和 <code>s2.name</code> 的值与 <code>s1</code> 完全相同。但如果类中包含指针成员，浅拷贝会导致问题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ShallowCopyExample</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 假设 data 指向堆内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ShallowCopyExample</span> <span class=n>obj1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>obj1</span><span class=p>.</span><span class=n>data</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ShallowCopyExample</span> <span class=n>obj2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>obj2</span> <span class=o>=</span> <span class=n>obj1</span><span class=p>;</span>  <span class=c1>// 浅拷贝：obj2.data 和 obj1.data 指向同一块内存
</span></span></span></code></pre></div><p>此时，修改 <code>*obj1.data</code> 会影响 <code>*obj2.data</code>，因为它们共享同一内存。如果释放其中一个对象的 <code>data</code>，另一个对象的指针将指向无效内存（悬空指针）。<br>关键点：对象默认赋值是浅拷贝，需手动实现深拷贝来复制指针指向的内容。</p><ol start=3><li>指针类型<br>指针变量存储的是内存地址。使用 <code>=</code> 赋值指针时，只会复制地址值，不会复制指针指向的内容。例如：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>200</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>  <span class=c1>// a 现在指向 b 的地址（即 200 所在的内存）
</span></span></span></code></pre></div><p>赋值后，<code>a</code> 和 <code>b</code> 指向同一块内存。修改 <code>*a</code> 会影响 <code>*b</code>，因为它们操作的是同一地址。此外，原 <code>a</code> 指向的内存（值为 100）会因未释放而导致内存泄漏。<br>关键点：指针赋值是地址的复制，不涉及内容拷贝；操作同一内存需谨慎。</p><ol start=4><li>STL 容器（如 std::string, std::vector）<br>STL 容器（如字符串、动态数组）的 <code>=</code> 运算符已经被设计为执行“深拷贝”。例如：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v1</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>v2</span> <span class=o>=</span> <span class=n>v1</span><span class=p>;</span>  <span class=c1>// 深拷贝：v2 复制了 v1 的所有元素到独立内存中
</span></span></span></code></pre></div><p>此时，修改 <code>v1[0] = 100</code> 不会影响 <code>v2[0]</code>，因为两者存储在不同的内存区域。<br>关键点：STL 容器默认支持深拷贝，赋值后内容完全独立。</p><ol start=5><li>赋值与指针指向的内容<br>当被赋值的变量是指针时，<code>a = b</code> 仅让 <code>a</code> 指向 <code>b</code> 的地址，而不是复制 <code>b</code> 指向的内容。若需要复制内容，必须显式操作：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>200</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>b</span><span class=p>);</span>  <span class=c1>// 显式复制 b 指向的内容到新内存
</span></span></span></code></pre></div><p>此时，<code>a</code> 和 <code>b</code> 指向不同的内存，但内容相同。<br>关键点：指针赋值不复制内容，需手动分配新内存并复制。</p><p>总结<br>• 基本类型：直接复制值。</p><p>• 对象：默认浅拷贝（复制成员变量，共享指针成员的内存）。</p><p>• 指针：复制地址，共享同一内存。</p><p>• STL 容器：深拷贝，内容完全独立。</p><p>核心原则：<code>=</code> 是否复制内容取决于操作数的类型。指针和对象可能共享内存，而基本类型和 STL 容器默认不共享。</p><hr><h3 id=注意>注意<a hidden class=anchor aria-hidden=true href=#注意>#</a></h3><p><strong>对运算符进行重载的时候，好的风格是应该尽量保留运算符原本的特性。</strong></p><blockquote><p>为 <code>String</code> 类编写复制构造函数的时候会面临和 <code>=</code> 同样的问题，用同样的方法处理。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>String</span><span class=p>(</span><span class=n>String</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=c1>//这里不用判断是否和原对象一致
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//因为对象是刚刚复制出来的不可能是同一个
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>str</span><span class=o>=</span><span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>str</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>s</span><span class=p>.</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=3运算符重载为友元函数>3.运算符重载为友元函数<a hidden class=anchor aria-hidden=true href=#3运算符重载为友元函数>#</a></h2><ul><li>一般情况下，将运算符重载为类的成员函数是较好的选择。</li><li>但有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。</li></ul><p>举例如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span><span class=kt>double</span> <span class=n>i</span><span class=p>)</span><span class=o>:</span><span class=n>real</span><span class=p>(</span><span class=n>r</span><span class=p>),</span><span class=n>imag</span><span class=p>(</span><span class=n>i</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Complex</span> <span class=n>Complex</span><span class=o>::</span><span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>){</span><span class=c1>//能解释c+5
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nf>Complex</span><span class=p>(</span><span class=n>real</span><span class=o>+</span><span class=n>r</span><span class=p>,</span><span class=n>imag</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>经过上述重载</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Complex</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>c</span><span class=o>=</span><span class=n>c</span><span class=o>+</span><span class=mi>5</span><span class=p>;</span><span class=c1>//有定义，相当于c=c.operator+5;
</span></span></span></code></pre></div><p>但是</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>c</span><span class=o>=</span><span class=mi>5</span><span class=o>+</span><span class=n>c</span><span class=p>;</span><span class=c1>//编译出错
</span></span></span></code></pre></div><p>所以，为了使上述的表达式能成立，需要将 <code>+</code> 重载为普通函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Complex</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span><span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>){</span><span class=c1>//能解释5+c
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nf>Complex</span><span class=p>(</span><span class=n>c</span><span class=p>.</span><span class=n>real</span><span class=o>+</span><span class=n>r</span><span class=p>,</span><span class=n>c</span><span class=p>.</span><span class=n>imag</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>但是普通函数又不能访问私有成员，所以，需要将运算符 <code>+</code> 重载为友元。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span><span class=kt>double</span> <span class=n>i</span><span class=p>)</span><span class=o>:</span><span class=n>real</span><span class=p>(</span><span class=n>r</span><span class=p>),</span><span class=n>imag</span><span class=p>(</span><span class=n>i</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>friend</span> <span class=n>Complex</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span><span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=4运算符重载实例可变长整型数组>4.运算符重载实例：可变长整型数组<a hidden class=anchor aria-hidden=true href=#4运算符重载实例可变长整型数组>#</a></h2><p><img alt=image.png loading=lazy src=https://raw.githubusercontent.com/kibrac/img_vault/main/Obsidian_img/20250504230001435.png></p><p>为了实现上述图片中描述的功能，创建如下的类</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CArray</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>size</span><span class=p>;</span><span class=c1>//数组元素的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span><span class=o>*</span> <span class=n>ptr</span><span class=p>;</span><span class=c1>//指向动态分配的数组
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>CArray</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=o>=</span><span class=mi>0</span><span class=p>);</span><span class=c1>//s代表数组元素的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>CArray</span><span class=p>(</span><span class=n>CArray</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>CArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=nf>push_back</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>);</span><span class=c1>//用于在数组尾部添加一个元素v
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>CArray</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>CArray</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>);</span><span class=c1>//用于数组对象间的赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kt>int</span> <span class=nf>length</span><span class=p>(){</span><span class=k>return</span> <span class=n>size</span><span class=p>;}</span><span class=c1>//返回数组元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kt>int</span><span class=o>&amp;</span> <span class=n>CArray</span><span class=o>::</span><span class=k>operator</span><span class=p>[](</span><span class=kt>int</span> <span class=n>i</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=c1>//返回值为int不行！不支持a[i]=4
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//因为非引用的函数返回值不可以作为左值使用
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//这里的重载用以支持根据下标访问数组元素，如n=a[i];和a[i]=4;这样的语句
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>return</span> <span class=n>ptr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>构造函数与复制构造函数如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CArray</span><span class=o>::</span><span class=n>CArray</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>)</span><span class=o>:</span><span class=n>size</span><span class=p>(</span><span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>ptr</span><span class=o>=</span><span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>
</span></span><span class=line><span class=cl>		<span class=n>ptr</span><span class=o>=</span><span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>s</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>CArray</span><span class=o>::</span><span class=n>CArray</span><span class=p>(</span><span class=n>CArray</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>a</span><span class=p>.</span><span class=n>ptr</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>ptr</span><span class=o>=</span><span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>size</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>ptr</span><span class=o>=</span><span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>memcpy</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span><span class=n>a</span><span class=p>.</span><span class=n>ptr</span><span class=p>,</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=o>*</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>size</span><span class=o>=</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>析构函数与 <code>=</code> 的运算符重载如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CArray</span><span class=o>::~</span><span class=n>CArray</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>delete</span> <span class=p>[]</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>CArray</span><span class=o>&amp;</span> <span class=n>CArray</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>CArray</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=c1>//赋值号的作用手机是使=左边的对象里存放的数组，大小和内容都和右边的对象一样
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span><span class=p>(</span><span class=n>ptr</span><span class=o>==</span><span class=n>a</span><span class=p>.</span><span class=n>ptr</span><span class=p>)</span><span class=c1>//防止a=a这样的赋值导致出错
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>ptr</span><span class=o>==</span><span class=nb>NULL</span><span class=p>){</span><span class=c1>//如果a里面的数组是空的
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>delete</span> <span class=p>[]</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>ptr</span><span class=o>=</span><span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>size</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>size</span><span class=o>&lt;</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>){</span><span class=c1>//如果原有空间够大，就不用分配新的空间
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>delete</span> <span class=p>[]</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>ptr</span><span class=o>=</span><span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>memcpy</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span><span class=n>a</span><span class=p>.</span><span class=n>ptr</span><span class=p>,</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=o>*</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>size</span><span class=o>=</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//CArray&amp; CArray::operator=(const CArray&amp; a)
</span></span></span></code></pre></div><p>最后是 <code>push_back</code> 函数，下面的写法实际上是比较低效的，因为每一次添加元素都会需要重新分配空间，造成大量的时间开销，比较好的做法有事先分配一片较大空间，并且在扩容时不使用逐一递增可以采用翻倍等方式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>CArray</span><span class=o>::</span><span class=n>push_back</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>){</span><span class=c1>//在数组尾部添加一个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span><span class=p>(</span><span class=n>ptr</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span><span class=o>*</span> <span class=n>tmpPtr</span><span class=o>=</span><span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>size</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span><span class=c1>//重新分配空间
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>memcpy</span><span class=p>(</span><span class=n>tmpPtr</span><span class=p>,</span><span class=n>ptr</span><span class=p>,</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=o>*</span><span class=n>size</span><span class=p>);</span><span class=c1>//拷贝原数组内容
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>delete</span> <span class=p>[]</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>ptr</span><span class=o>=</span><span class=n>tmpPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span><span class=c1>//如果数组本来是空的
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>ptr</span><span class=o>=</span><span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>ptr</span><span class=p>[</span><span class=n>size</span><span class=o>++</span><span class=p>]</span><span class=o>=</span><span class=n>v</span><span class=p>;</span><span class=c1>//加入新的数组元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=5流插入运算符和流提取运算符的重载>5.流插入运算符和流提取运算符的重载<a hidden class=anchor aria-hidden=true href=#5流插入运算符和流提取运算符的重载>#</a></h2><blockquote><p>本小节中提到的流插入运算符和流提取运算符本质上是左移运算符和右移运算符进行重载。</p></blockquote><h3 id=问题引入>问题引入<a hidden class=anchor aria-hidden=true href=#问题引入>#</a></h3><blockquote><p><code>cout &lt;&lt; 5 &lt;&lt; "this"</code> 为什么能够成立？</p><p><code>cout</code> 是什么？</p><p><code>&lt;&lt;</code> 为什么能用在 <code>cout</code> 上？</p></blockquote><h3 id=流插入运算符的重载>流插入运算符的重载<a hidden class=anchor aria-hidden=true href=#流插入运算符的重载>#</a></h3><ul><li><code>cout</code> 是在头文件 iostream 中定义的，<strong>ostream</strong> 类的对象</li><li><code>&lt;&lt;</code> 能用在 <code>cout</code> 上是因为在 iostream 里对其进行了重载</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>ostream</span><span class=o>::</span><span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=p>......</span><span class=c1>//输出n的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>ostream</span><span class=o>::</span><span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=p>......</span><span class=c1>//输出s的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上述的重载过程当中，将返回值类型设置为 <code>ostream&</code> 以及返回 <code>* this</code> 的目的是使 <code>&lt;&lt;</code> 作用之后的返回值类型不变，这样就可以继续被 <code>&lt;&lt;</code> 作用。</p><p><code>cout &lt;&lt; 5 &lt;&lt; "this"</code> 本质上的函数调用形式是</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span><span class=p>.</span><span class=k>operator</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>5</span><span class=p>).</span><span class=k>operator</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=s>&#34;this&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>举例如下</p><blockquote><p>假定下面程序输出为 <code>5hello</code>，应该补写什么？</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CStudent</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>nAge</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>CStudent</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>s</span><span class=p>.</span><span class=n>nAge</span><span class=o>=</span><span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>s</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>答案如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>o</span><span class=p>,</span><span class=k>const</span> <span class=n>CStudent</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>o</span><span class=o>&lt;&lt;</span><span class=n>s</span><span class=p>.</span><span class=n>nAge</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>o</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=一个复杂举例>一个复杂举例<a hidden class=anchor aria-hidden=true href=#一个复杂举例>#</a></h3><p>假定 <code>c</code> 是 <code>Complex</code> 复数类的对象，现在希望写 <code>cout &lt;&lt; c;</code>，就能以 <code>a+bi</code> 的形式输出 <code>c</code> 的值，写 <code>cin >> c;</code>，就能从键盘接受 <code>a+bi</code> 形式的输入，并且使得 <code>c.real=a,c,imag=b</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Complex</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>c</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>程序运行结果可以如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>13.2+133i 87↓
</span></span><span class=line><span class=cl>13.2+133i,87
</span></span></code></pre></div><p>完整程序如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdlib&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=kt>double</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span><span class=o>:</span><span class=n>real</span><span class=p>(</span><span class=n>r</span><span class=p>),</span><span class=n>imag</span><span class=p>(</span><span class=n>i</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>		<span class=k>friend</span> <span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span><span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>friend</span> <span class=n>istream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>is</span><span class=p>,</span><span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span><span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>c</span><span class=p>.</span><span class=n>real</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;+&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c</span><span class=p>.</span><span class=n>imag</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;i&#34;</span><span class=p>;</span><span class=c1>//以&#34;a+bi&#34;的形式输出 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>istream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>is</span><span class=p>,</span><span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>string</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>is</span> <span class=o>&gt;&gt;</span> <span class=n>s</span><span class=p>;</span><span class=c1>//将&#34;a+bi&#34;作为字符串读入，&#34;a+bi&#34;中间不能有空格 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=n>pos</span><span class=o>=</span><span class=n>s</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=s>&#34;+&#34;</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>string</span> <span class=n>sTmp</span><span class=o>=</span><span class=n>s</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=n>pos</span><span class=p>);</span><span class=c1>//分离出代表实部的字符串 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>c</span><span class=p>.</span><span class=n>real</span><span class=o>=</span><span class=n>atof</span><span class=p>(</span><span class=n>sTmp</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span><span class=c1>//atof函数能将const char*指针指向的内容转换成float 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>sTmp</span><span class=o>=</span><span class=n>s</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>pos</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>s</span><span class=p>.</span><span class=n>length</span><span class=p>()</span><span class=o>-</span><span class=n>pos</span><span class=o>-</span><span class=mi>2</span><span class=p>);</span><span class=c1>//分离出代表虚部的字符串 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>c</span><span class=p>.</span><span class=n>imag</span><span class=o>=</span><span class=n>atof</span><span class=p>(</span><span class=n>sTmp</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>is</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Complex</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>c</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>事实上以上程序可以进行优化，优化内容如下：</p><ol><li>支持负数虚部​<ul><li>使用 <code>find_last_of("+-")</code> 替代 <code>find("+")</code>，兼容虚部为负的情况（如 <code>3-4i</code>）。</li></ul></li><li>​格式校验​​<ul><li>检查输入字符串是否以 <code>i</code> 结尾</li><li>检查分隔符位置有效性（避免首字符为分隔符）</li></ul></li><li>错误处理​​<ul><li>通过 <code>is.setstate(ios::failbit)</code> 设置流错误状态，使程序能处理无效输入。</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdlib&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>real</span><span class=p>,</span> <span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>double</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>:</span> <span class=n>real</span><span class=p>(</span><span class=n>r</span><span class=p>),</span> <span class=n>imag</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>istream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>is</span><span class=p>,</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>);</span> <span class=c1>// 修正1：移除const
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>c</span><span class=p>.</span><span class=n>real</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;+&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c</span><span class=p>.</span><span class=n>imag</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;i&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>istream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>is</span><span class=p>,</span> <span class=n>Complex</span><span class=o>&amp;</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>is</span> <span class=o>&gt;&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 检查字符串以i结尾
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>||</span> <span class=n>s</span><span class=p>.</span><span class=n>back</span><span class=p>()</span> <span class=o>!=</span> <span class=sc>&#39;i&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>is</span><span class=p>.</span><span class=n>setstate</span><span class=p>(</span><span class=n>ios</span><span class=o>::</span><span class=n>failbit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>is</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 查找最后一个+或-作为分隔符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>pos</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>find_last_of</span><span class=p>(</span><span class=s>&#34;+-&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pos</span> <span class=o>==</span> <span class=n>string</span><span class=o>::</span><span class=n>npos</span> <span class=o>||</span> <span class=n>pos</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>is</span><span class=p>.</span><span class=n>setstate</span><span class=p>(</span><span class=n>ios</span><span class=o>::</span><span class=n>failbit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>is</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 分割实部和虚部
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>string</span> <span class=n>realPart</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>imagPart</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>pos</span><span class=p>,</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=n>pos</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// 去掉i
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=p>.</span><span class=n>real</span> <span class=o>=</span> <span class=n>atof</span><span class=p>(</span><span class=n>realPart</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=p>.</span><span class=n>imag</span> <span class=o>=</span> <span class=n>atof</span><span class=p>(</span><span class=n>imagPart</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>is</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Complex</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>c</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=6类型转换运算符和自增自减运算符的重载>6.类型转换运算符和自增、自减运算符的重载<a hidden class=anchor aria-hidden=true href=#6类型转换运算符和自增自减运算符的重载>#</a></h2><h3 id=重载类型转换运算符>重载类型转换运算符<a hidden class=anchor aria-hidden=true href=#重载类型转换运算符>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Complex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>real</span><span class=p>,</span><span class=n>imag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=kt>double</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span><span class=o>:</span><span class=n>real</span><span class=p>(</span><span class=n>r</span><span class=p>),</span><span class=n>imag</span><span class=p>(</span><span class=n>i</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>		<span class=k>operator</span> <span class=nf>double</span><span class=p>(){</span><span class=k>return</span> <span class=n>real</span><span class=p>;}</span><span class=c1>//重载强制类型转换运算符double 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Complex</span> <span class=n>c</span><span class=p>(</span><span class=mf>1.2</span><span class=p>,</span><span class=mf>3.4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>c</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span><span class=c1>//输出1.2 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>double</span> <span class=n>n</span><span class=o>=</span><span class=mi>2</span><span class=o>+</span><span class=n>c</span><span class=p>;</span><span class=c1>//等价于double n=2+c.operator double() 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>;</span><span class=c1>//输出3.2 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=自增自减运算符的重载>自增、自减运算符的重载<a hidden class=anchor aria-hidden=true href=#自增自减运算符的重载>#</a></h3><p>自增运算符 <code>++</code>、自减运算符 <code>--</code> 有前置/后置之分，为了区分所重载的是前置运算符还是后置运算符，C++ 规定</p><p><strong>前置运算符作为一元运算符重载</strong></p><ul><li>重载为成员函数 <code>T& operator++();</code> <code>T& operator--();</code></li><li>重载为全局函数 <code>T1& operator++(T2);</code> <code>T1& operator--(T2);</code>
<strong>后置运算符作为二元运算符重载，多写一个没用的参数</strong></li><li>重载为成员函数 <code>T operator++(int);</code> <code>T operator--(int);</code></li><li>重载为全局函数 <code>T1 operator++(T2,int);</code> <code>T1 operator--(T2,int);</code></li></ul><blockquote><p>在没有后置运算符重载而有前置运算符重载的情况下，在 Visual Studio 中，<code>obj++</code> 也调用前置重载，而 DEV C++ 则令 <code>obj++</code> 编译出错。</p></blockquote><p>举例说明，如下是希望实现的功能</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>CDemo</span> <span class=n>d</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>d</span><span class=o>++</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=p>;</span><span class=c1>//等价于d.operator++(0);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>d</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=o>++</span><span class=n>d</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=p>;</span><span class=c1>//等价于d.operator++();
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>d</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>d</span><span class=o>--</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=p>;</span><span class=c1>//等价于d.operator--(d,0);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>d</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=o>--</span><span class=n>d</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=p>;</span><span class=c1>//等价于d.operator--(d);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>d</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>预期的输出结果为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>5,6,7,7
</span></span><span class=line><span class=cl>7,6,5,5
</span></span></code></pre></div><p>那么应该如何编写 <code>CDemo</code>？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CDemo</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>CDemo</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span><span class=o>:</span><span class=n>n</span><span class=p>(</span><span class=n>i</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>		<span class=n>CDemo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>++</span><span class=p>();</span><span class=c1>//用于前置形式
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>CDemo</span> <span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span><span class=c1>//用于后置形式
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>operator</span> <span class=nf>int</span><span class=p>(){</span><span class=k>return</span> <span class=n>n</span><span class=p>;};</span>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>CDemo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>--</span><span class=p>(</span><span class=n>CDemo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>CDemo</span> <span class=k>operator</span><span class=o>--</span><span class=p>(</span><span class=n>CDemo</span><span class=o>&amp;</span><span class=p>,</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>CDemo</span><span class=o>&amp;</span> <span class=n>CDemo</span><span class=o>::</span><span class=k>operator</span><span class=o>++</span><span class=p>(){</span><span class=c1>//前置++
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>++</span><span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span><span class=o>*</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//++s即为s.operator++();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>CDemo</span> <span class=n>CDemo</span><span class=o>::</span><span class=k>operator</span><span class=o>++</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>){</span><span class=c1>//后置++
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>CDemo</span> <span class=nf>tmp</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span><span class=c1>//记录修改前的对象
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>n</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>tmp</span><span class=p>;</span><span class=c1>//返回修改前的对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=c1>//s++即为s.operator(0);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>CDemo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>--</span><span class=p>(</span><span class=n>CDemo</span><span class=o>&amp;</span> <span class=n>d</span><span class=p>){</span><span class=c1>//前置--
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>d</span><span class=p>.</span><span class=n>n</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//--s即为operator--(s);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>CDemo</span> <span class=k>operator</span><span class=o>--</span><span class=p>(</span><span class=n>CDemo</span><span class=o>&amp;</span> <span class=n>d</span><span class=p>,</span><span class=kt>int</span><span class=p>){</span><span class=c1>//后置--
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>CDemo</span> <span class=nf>tmp</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>d</span><span class=p>.</span><span class=n>n</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>//s--即为operator--(s,0);
</span></span></span></code></pre></div><hr><h3 id=一点补充前置与后置的不同>一点补充：前置与后置的不同<a hidden class=anchor aria-hidden=true href=#一点补充前置与后置的不同>#</a></h3><p>自增（<code>++</code>）和自减（<code>--</code>）运算符的前置（如 <code>++i</code>）与后置（如 <code>i++</code>）的区别在于：</p><ol><li>返回值：前置运算符返回运算后的新值，后置运算符返回运算前的原始值；</li><li>执行顺序：前置先增减再使用值，后置先使用值再增减；</li><li>性能：前置无需创建临时变量，效率更高；后置需保留原始值的副本，可能产生额外开销；</li><li>重载实现：C++ 中通过参数区分，前置无参数（<code>T& operator++()</code>），后置用伪参数（<code>T operator++(int)</code>）。<br>例如：<code>int a=5; b=++a</code> 后 <code>a=6, b=6</code>，而 <code>b=a++</code> 后 <code>a=6, b=5</code>。</li></ol><h3 id=运算符重载的注意事项>运算符重载的注意事项<a hidden class=anchor aria-hidden=true href=#运算符重载的注意事项>#</a></h3><ol><li>C++ 不允许定义新的运算符；</li><li>重载后运算符的含义应该符合日常习惯；</li><li>运算符重载不改变运算符的优先级；</li><li>以下运算符不能被重载：<code>.</code> <code>.*</code> <code>::</code> <code>?:</code> <code>sizeof</code>；</li><li>重载运算符 <code>()</code> <code>[]</code> <code>-></code> 或者赋值运算符 <code>=</code> 时，运算符重载函数必须声明为类的成员函数。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/c++/>C++</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/c++5/><span class=title>« 上一页</span><br><span>面向对象的程序设计学习笔记 5</span>
</a><a class=next href=http://localhost:1313/posts/c++3/><span class=title>下一页 »</span><br><span>面向对象的程序设计学习笔记 3</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 4 on x" href="https://x.com/intent/tweet/?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%204&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b4%2f&amp;hashtags=C%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 4 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b4%2f&amp;title=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%204&amp;summary=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%204&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 4 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b4%2f&title=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%204"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 4 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 4 on whatsapp" href="https://api.whatsapp.com/send?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%204%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 4 on telegram" href="https://telegram.me/share/url?text=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%204&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b4%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 面向对象的程序设计学习笔记 4 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%204&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fc%2b%2b4%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Kibrac's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>