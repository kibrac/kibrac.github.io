<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>面向对象的程序设计学习笔记 5 - Kibrac&#39;s Blog</title>
  <meta name="description" content="第五章 继承">
  
  
  <link rel="icon" type="image/png" href="https://kibrac.github.io/favicon.png">
  
  
  <link rel="stylesheet" href="https://kibrac.github.io/css/normalize.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/style.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/archives.css">
  <link rel="stylesheet" href="https://kibrac.github.io/css/custom.css">
  
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
  
  
  <script>
    
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const storedTheme = localStorage.getItem('theme');
    if (storedTheme === 'dark' || (!storedTheme && prefersDark)) {
      document.documentElement.classList.add('dark-mode');
    }
  </script>
  
  <meta property="og:url" content="https://kibrac.github.io/posts/c&#43;&#43;5/">
  <meta property="og:site_name" content="Kibrac&#39;s Blog">
  <meta property="og:title" content="面向对象的程序设计学习笔记 5">
  <meta property="og:description" content="第五章 继承">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-13T11:52:51+08:00">
    <meta property="article:modified_time" content="2025-05-13T11:52:51+08:00">
    <meta property="article:tag" content="C&#43;&#43;">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="面向对象的程序设计学习笔记 5">
  <meta name="twitter:description" content="第五章 继承">
      <meta name="twitter:site" content="@https://x.com/kibra_chen">

  
  
  
  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
</head>
<body>
  <div class="container">
    <header class="site-header">
      <div class="header-container">
  <div class="site-branding">
    <a href="/" class="site-title">Kibrac&#39;s Blog</a>
    
  </div>
  
  <nav class="main-navigation">
    
    <ul class="menu" id="primary-menu">
      
      
      <li class="menu-item  ">
        <a href="/" class="home-link">首页</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/posts/" >文章</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/archives/" >归档</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/categories/" >分类</a>
      </li>
      
      <li class="menu-item  ">
        <a href="/tags/" >标签</a>
      </li>
      
    </ul>
  </nav>
  
  <div class="header-actions">
    <button class="menu-toggle" aria-controls="primary-menu" aria-expanded="false">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>
    
    
    <button class="theme-toggle" aria-label="切换主题">
      <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
      </svg>
      <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
      </svg>
    </button>
  </div>
</div>


    </header>
    
    <main class="main-content">
      
<div class="post-container">
  
  <div class="post-featured-image post-banner">
    <img src="https://kibrac.github.io/images/cover/c&#43;&#43;.jpg" alt="面向对象的程序设计学习笔记 5">
  </div>
  
  
  <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">面向对象的程序设计学习笔记 5</h1>
      
      <div class="post-meta">
        <time datetime="2025-05-13T11:52:51&#43;08:00">
          2025-05-13
        </time>
        
        
        <span class="post-author">
          Kibrac
        </span>
        
        
        
        <div class="post-categories">
          
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
          
        </div>
        
      </div>
    </header>
    
    <div class="post-content">
      <p>课程链接：<a href="https://www.icourse163.org/course/PKU-1002029030">程序设计与算法（三）C++面向对象程序设计_北京大学_中国大学MOOC(慕课)</a></p>
<h2 id="1继承和派生的基本概念">1.继承和派生的基本概念</h2>
<h3 id="继承和派生的概念">继承和派生的概念</h3>
<ul>
<li><strong>继承：</strong> 在定义一个新的类 B 时，如果该类与某个已有的类 A 相似（<strong>指的是 B 拥有 A 的全部特点</strong>），那么就可以把 A 作为一个<strong>基类</strong>，而把 B 作为基类的一个<strong>派生类（也称子类）</strong>。</li>
<li>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。</li>
<li>派生类一经定义后，可以独立使用，不依赖于基类。</li>
<li>派生类拥有基类的全部成员函数和成员变量，不论是 private、protected、public。
<ul>
<li>在派生类的各个成员函数中，不能访问基类中的 private 成员。</li>
</ul>
</li>
</ul>
<h3 id="派生类的写法">派生类的写法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">派生类名:</span><span style="color:#a6e22e">public</span> <span style="color:#960050;background-color:#1e0010">基类名</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	......
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>举例如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CStudent</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		string sName;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nAge;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">bool</span> IsThreeGood(){};
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SetName</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> name){sName<span style="color:#f92672">=</span>name;}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//......
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CUndergraduateStudent</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CStudent{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nDepartment;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">bool</span> IsThreeGood(){...};<span style="color:#75715e">//覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">CanBaoYan</span>(){...};
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//派生类写法-类名:public 基类名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CGraduatedStudent</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CStudent{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nDepartment;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">char</span> szMentorName[<span style="color:#ae81ff">20</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> CountSalary(){...};
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="派生类对象的内存空间">派生类对象的内存空间</h3>
<p>派生类对象的体积，等于基类对象的体积再加上派生类对象自己的成员变量的体积。<strong>在派生类对象中，包含着基类对象</strong>，而且基类对象的存储位置位于派生类对象新增的成员变量<strong>之前</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CBase</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> v1,v2;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDerived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CBase{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> v3;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//CDerived对象：v1,v2,v3;CBase对象：v1,v2
</span></span></span></code></pre></div><h3 id="继承实例程序学籍管理">继承实例程序：学籍管理</h3>
<blockquote>
<p>在原视频中展示的代码，缺少了对基类 <code>CStudent</code> 中 <code>PrintInfo</code> 和 <code>SetInfo</code> 的实现代码，此处进行了补齐。</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e"> 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CStudent</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		string name;
</span></span><span style="display:flex;"><span>		string id;<span style="color:#75715e">//学号 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">char</span> gender;<span style="color:#75715e">//性别，F代表女，M代表男 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> age;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">void</span> PrintInfo() {
</span></span><span style="display:flex;"><span>	        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Name:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> name <span style="color:#f92672">&lt;&lt;</span> endl
</span></span><span style="display:flex;"><span>	             <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ID:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> id <span style="color:#f92672">&lt;&lt;</span> endl
</span></span><span style="display:flex;"><span>	             <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Age:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> age <span style="color:#f92672">&lt;&lt;</span> endl
</span></span><span style="display:flex;"><span>	             <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Gender:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> gender <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	    }
</span></span><span style="display:flex;"><span>	    
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SetInfo</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> name_, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> id_, 
</span></span><span style="display:flex;"><span>	                <span style="color:#66d9ef">int</span> age_, <span style="color:#66d9ef">char</span> gender_) {
</span></span><span style="display:flex;"><span>	        name <span style="color:#f92672">=</span> name_;
</span></span><span style="display:flex;"><span>	        id <span style="color:#f92672">=</span> id_;
</span></span><span style="display:flex;"><span>	        age <span style="color:#f92672">=</span> age_;
</span></span><span style="display:flex;"><span>	        gender <span style="color:#f92672">=</span> gender_;
</span></span><span style="display:flex;"><span>	    }
</span></span><span style="display:flex;"><span>		string <span style="color:#a6e22e">GetName</span>(){<span style="color:#66d9ef">return</span> name;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CUndergraduateStudent</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CStudent{<span style="color:#75715e">//本科生类，继承了CStudent类 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		string department;<span style="color:#75715e">//学生所属系的名称 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> QualifiedForBaoyan(){<span style="color:#75715e">//给予保研资格 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;qualified for baoyan&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		} 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintInfo</span>(){
</span></span><span style="display:flex;"><span>			CStudent<span style="color:#f92672">::</span>PrintInfo();<span style="color:#75715e">//调用基类的PrintInfo 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Department:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> department <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SetInfo</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> name_,<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> id_,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> age_,<span style="color:#66d9ef">char</span> gender_,<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> department_){
</span></span><span style="display:flex;"><span>			CStudent<span style="color:#f92672">::</span>SetInfo(name_,id_,age_,gender_);<span style="color:#75715e">//调用基类的SetInfo 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			department<span style="color:#f92672">=</span>department_;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	CUndergraduateStudent s2;
</span></span><span style="display:flex;"><span>	s2.SetInfo(<span style="color:#e6db74">&#34;Harry Potter&#34;</span>,<span style="color:#e6db74">&#34;118829212&#34;</span>,<span style="color:#ae81ff">19</span>,<span style="color:#e6db74">&#39;M&#39;</span>,<span style="color:#e6db74">&#34;Computer Science&#34;</span>);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> s2.GetName() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	s2.QualifiedForBaoyan();
</span></span><span style="display:flex;"><span>	s2.PrintInfo();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出结果</p>
<pre tabindex="0"><code>Harry Potter qualified for baoyan
Name:Harry Potter
ID:118829212
Age:19
Gender:M
Department:Computer Science
</code></pre><h2 id="2继承关系和复合关系">2.继承关系和复合关系</h2>
<h3 id="类的两种关系">类的两种关系</h3>
<ul>
<li><strong>继承：</strong>“<strong>是</strong>”关系。
<ul>
<li>对于基类 A，B 是基类 A 的派生类。</li>
<li>逻辑上要求：“一个 B 对象也<strong>是</strong>一个 A 对象”。</li>
</ul>
</li>
<li><strong>复合：</strong>“<strong>有</strong>”关系。
<ul>
<li>类 C 中<strong>有</strong>成员变量 k，k 是类 D 的对象，则 C 和 D 是复合关系。</li>
<li>一般逻辑上要求：“D 对象是 C 对象的固有属性或组成部分”。</li>
</ul>
</li>
</ul>
<h3 id="继承关系的使用">继承关系的使用</h3>
<p>考虑以下情景：</p>
<p>当我们写了一个 <code>CMan</code> 类来代表男人，后来发现还需要一个 <code>CWoman</code> 类来代表女人，<code>CWoman</code> 类和 <code>CMan</code> 类有共同之处，所以我们就让 <code>CWoman</code> 类从 <code>CWoman</code> 类从 <code>CMan</code> 类派生而来，是否合适？</p>
<p>这显然是<strong>不合理</strong>的！因为“一个女人也是一个男人”从逻辑上不成立！</p>
<p>好的做法是概括男人和女人的共同特点，写一个 <code>CHuman</code> 类，代表“人”，然后 <code>CMan</code> 和 <code>CWoman</code> 都从 <code>CHuman</code> 派生。</p>
<h3 id="复合关系的使用">复合关系的使用</h3>
<ul>
<li>几何体程序中，需要写“点”类，也需要写“圆”类，两者的关系就是复合关系——每一个“圆”对象里都包含（<strong>有</strong>）一个“点”对象，也就是圆心。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CPoint</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">double</span> x,y;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CCircle</span>;<span style="color:#75715e">//便于CCircle类操作其圆心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CCircle</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">double</span> r;
</span></span><span style="display:flex;"><span>	CPoint center;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>再考虑以下情景：</p>
<ul>
<li>如果要写一个小区养狗管理程序，需要写一个“<strong>业主</strong>”类，还需要写一个“<strong>狗</strong>”类。</li>
<li>而狗是有“主人”的，主人也就是业主（假定狗只有一个主人，但一个业主可以最多拥有 10 条狗）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDog</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>classCMaster{
</span></span><span style="display:flex;"><span>	CDog dogs[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDog</span>{
</span></span><span style="display:flex;"><span>	CMaster m;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面这种写法是<strong>完完全全的错误</strong>（用视频中老师的说法就是你的 C++ 是保安教的吗 hhhh），在编译的时候就无法通过，因为它进行了循环定义，也就是“人中有狗，狗中有人”。可以注意到，上述写法中，一个 <code>CMaster</code> 的体积，是 10 倍的 <code>CDog</code>，而一个 <code>CDog</code> 的体积，又等同于一个 <code>CMaster</code>。</p>
<p>另一种写法:</p>
<ul>
<li>为“狗”类设一个“业主”类的成员对象；</li>
<li>为“业主”类设一个“狗”类的对象指针数组。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDog</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CMaster</span>{
</span></span><span style="display:flex;"><span>	CDog<span style="color:#f92672">*</span> dogs[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDog</span>{
</span></span><span style="display:flex;"><span>	CMaster m;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>这种写法实际上也是错误的，因为这样定义类实际上还是导致“狗中有人”的局面，那么在维护相同主人的多条狗里面包含的多个主人对象的信息一致性上会非常繁琐。</p>
<p>一种凑合的写法：</p>
<ul>
<li>为“狗”类设一个“业主”类的对象指针；</li>
<li>为“业主”类设一个“狗”类的对象数组。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CMaster</span>;<span style="color:#75715e">//CMaster必须提前声明，不能先写CMaster类后写CDog类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDog</span>{
</span></span><span style="display:flex;"><span>	CMaster<span style="color:#f92672">*</span> pm;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CMaster</span>{
</span></span><span style="display:flex;"><span>	CDog dogs[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>这样的写法实际上是导致“人中有狗”，而每一条狗拥有一个指向主人的指针。并且这种写法会造成如果要对狗对象进行操作，都需要通过它的主人来进行，因为每一个狗对象都被包含在主人对象中。</p>
<p><strong>正确的写法：</strong></p>
<ul>
<li>为“狗”类设一个“业主”类的对象指针；</li>
<li>为“业主”类设一个“狗”类的对象指针数组。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CMaster</span>;<span style="color:#75715e">//CMaster必须提前声明，不能先写CMaster类后写CDog类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDog</span>{
</span></span><span style="display:flex;"><span>	CMaster<span style="color:#f92672">*</span> pm;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CMaster</span>{
</span></span><span style="display:flex;"><span>	CDog<span style="color:#f92672">*</span> dogs[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="3覆盖和保护成员">3.覆盖和保护成员</h2>
<h3 id="覆盖">覆盖</h3>
<p>派生类可以定义一个和基类成员同名的成员，这叫<strong>覆盖</strong>。在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的<strong>同名</strong>成员时，要使用作用域符号 <code>::</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">base</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> j;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">derived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> base{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> i;<span style="color:#75715e">//这里只是为了说明，实际上一般不会在基类和派生类中写同名变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">access</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>();<span style="color:#75715e">//但写同名函数是很常见的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> derived<span style="color:#f92672">::</span>access(){
</span></span><span style="display:flex;"><span>	j<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>;<span style="color:#75715e">//error，这是基类的私有成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	i<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>;<span style="color:#75715e">//引用的是派生类的i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	base<span style="color:#f92672">::</span>i<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>;<span style="color:#75715e">//引用的是基类的i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	func();<span style="color:#75715e">//派生类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	base<span style="color:#f92672">::</span>func();<span style="color:#75715e">//基类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>derived obj;
</span></span><span style="display:flex;"><span>obj.i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>obj.base<span style="color:#f92672">::</span>i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><p><strong>一般来说，基类和派生类不定义同名成员变量。</strong></p>
<h3 id="类的保护成员">类的保护成员</h3>
<p>存取权限说明符：<code>protected</code></p>
<ul>
<li>基类的 <code>private</code> 成员可以被下列函数访问
<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
</ul>
</li>
<li>基类的 <code>public</code> 成员可以被下列函数访问
<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数</li>
<li>派生类的友元函数</li>
<li>其他函数</li>
</ul>
</li>
<li>基类的 <code>protected</code> 成员可以被下列函数访问
<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数可以访问当前对象（也就是派生类成员函数当前作用的对象）的基类的保护成员</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Father</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nPrivate;<span style="color:#75715e">//私有成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nPublic;<span style="color:#75715e">//共有成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nProtected;<span style="color:#75715e">//保护成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Father{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">AccessFather</span>(){
</span></span><span style="display:flex;"><span>		nPublic<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		nPrivate<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//wrong
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		nProtected<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//ok，访问从基类继承的protected成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Son f;
</span></span><span style="display:flex;"><span>		f.nProtected<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	Father f;
</span></span><span style="display:flex;"><span>	Son s;
</span></span><span style="display:flex;"><span>	f.nPublic<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	s.nPublic<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	f.nProtected<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	f.nPrivate<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	s.nProtected<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	s.nPrivate<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="一点补充针对-protected-的详细解释">一点补充：针对 <code>protected</code> 的详细解释</h3>
<p>为什么在上述代码中，派生类的成员函数 <code>AccessFather</code> 中 <code>f.nProtected=1</code> 是可以的，但是主函数 <code>main</code> 中 <code>f.nProtected=1</code> 和 <code>s.nProtected=1</code> 都不行？</p>
<p>​<strong>1.派生类成员函数中的 <code>f.nProtected = 1</code> 为什么合法？​</strong>​</p>
<ul>
<li>​<strong>上下文</strong>​：<code>Son::AccessFather()</code> 是派生类 <code>Son</code> 的成员函数。</li>
<li>​<strong>规则</strong>​：<br>
在派生类的成员函数中，​<strong>可以通过「派生类对象」访问其直接基类的 <code>protected</code> 成员</strong>​（无论该对象是否是当前 <code>this</code> 对象）。</li>
<li>​<strong>代码分析</strong>​：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Son f;         <span style="color:#75715e">// 创建一个 Son 对象 f
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>f.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// ✔️ 合法：通过 Son 对象访问 Father 的 protected 成员
</span></span></span></code></pre></div><p>这里的 <code>f</code> 是 <code>Son</code> 类型的对象，<code>AccessFather()</code> 作为 <code>Son</code> 的成员函数，允许通过任何 <code>Son</code> 对象访问其基类 <code>Father</code> 的 <code>protected</code> 成员。</p>
<p><strong>2.主函数中的 <code>f.nProtected = 1</code> 和 <code>s.nProtected = 1</code> 为什么非法？​</strong>​</p>
<ul>
<li>​<strong>上下文</strong>​：<code>main()</code> 是外部函数，不属于 <code>Father</code> 或 <code>Son</code> 的成员函数或友元。</li>
<li>​<strong>规则</strong>​：<code>protected</code> 成员只能被以下角色访问：
<ul>
<li>基类自身的成员函数和友元</li>
<li>派生类的成员函数（通过「派生类对象」或「当前 <code>this</code> 对象」）</li>
<li>派生类的友元（通过派生类对象）</li>
</ul>
</li>
<li>​<strong>代码分析</strong>​：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Father f;  <span style="color:#75715e">// 基类对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>f.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// ❌ 非法：外部函数无法访问基类的 protected 成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Son s;     <span style="color:#75715e">// 派生类对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>s.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// ❌ 非法：外部函数无法通过派生类对象间接访问基类的 protected 成员
</span></span></span></code></pre></div><p>尽管 <code>s</code> 是 <code>Son</code> 对象，但 <code>main()</code> 作为外部函数，无法直接访问任何类的 <code>protected</code> 成员。</p>
<p><strong>3.关键区别总结</strong>​</p>
<table>
  <thead>
      <tr>
          <th>​<strong>场景</strong>​</th>
          <th>​<strong>是否合法</strong>​</th>
          <th>​<strong>原因</strong>​</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>Son::AccessFather()</code> 中的 <code>f.nProtected</code></td>
          <td>✔️ 合法</td>
          <td>派生类成员函数可以通过「派生类对象」访问基类的 <code>protected</code> 成员</td>
      </tr>
      <tr>
          <td><code>main()</code> 中的 <code>f.nProtected</code></td>
          <td>❌ 非法</td>
          <td>外部函数无法访问基类的 <code>protected</code> 成员</td>
      </tr>
      <tr>
          <td><code>main()</code> 中的 <code>s.nProtected</code></td>
          <td>❌ 非法</td>
          <td>外部函数无法通过派生类对象间接访问基类的 <code>protected</code> 成员（即使该对象属于派生类）</td>
      </tr>
  </tbody>
</table>
<p><strong>4.进一步验证</strong>​</p>
<p>如果尝试在 <code>Son::AccessFather()</code> 中通过 ​<strong>基类对象</strong>​ 访问 <code>protected</code> 成员，也会失败：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Son<span style="color:#f92672">::</span>AccessFather() {
</span></span><span style="display:flex;"><span>    Father base;        <span style="color:#75715e">// 创建一个基类对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    base.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// ❌ 非法：派生类无法通过基类对象访问 protected 成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>因为此处 <code>base</code> 是基类对象，而非派生类对象。</p>
<p>​<strong>5.语言设计逻辑</strong>​</p>
<p><code>protected</code> 的访问规则旨在实现以下目标：</p>
<ul>
<li><strong>允许派生类扩展基类的功能</strong>​：派生类可以访问基类的 <code>protected</code> 成员，用于实现继承相关的逻辑。</li>
<li><strong>保持封装性</strong>​：外部代码（包括派生类的用户）无法直接访问 <code>protected</code> 成员，避免破坏基类的内部状态。</li>
</ul>
<p>通过这种设计，C++ 在「代码复用」和「封装性」之间取得了平衡。</p>
<hr>
<h2 id="4派生类的构造函数">4.派生类的构造函数</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bug</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nLegs;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nColor;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> nType;
</span></span><span style="display:flex;"><span>		Bug(<span style="color:#66d9ef">int</span> legs,<span style="color:#66d9ef">int</span> color);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintBug</span>(){};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FlyBug</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Bug{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> nWings;
</span></span><span style="display:flex;"><span>	Public:
</span></span><span style="display:flex;"><span>		FlyBug(<span style="color:#66d9ef">int</span> legs,<span style="color:#66d9ef">int</span> color,<span style="color:#66d9ef">int</span> wings);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Bug<span style="color:#f92672">::</span>Bug(<span style="color:#66d9ef">int</span> legs,<span style="color:#66d9ef">int</span> color){
</span></span><span style="display:flex;"><span>	nLegs<span style="color:#f92672">=</span>legs;
</span></span><span style="display:flex;"><span>	nColor<span style="color:#f92672">=</span>color;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//错误的FlyBug构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FlyBug<span style="color:#f92672">::</span>FlyBug(<span style="color:#66d9ef">int</span> legs,<span style="color:#66d9ef">int</span> color,<span style="color:#66d9ef">int</span> wings){
</span></span><span style="display:flex;"><span>	nLegs<span style="color:#f92672">=</span>legs;<span style="color:#75715e">//error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	nColor<span style="color:#f92672">=</span>color;<span style="color:#75715e">//error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	nType<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	nWings<span style="color:#f92672">=</span>wings;<span style="color:#75715e">//ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//正确的FlyBug构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>FlyBug<span style="color:#f92672">::</span>FlyBug(<span style="color:#66d9ef">int</span> legs,<span style="color:#66d9ef">int</span> color,<span style="color:#66d9ef">int</span> wings)<span style="color:#f92672">:</span>Bug(legs,color){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//直接在初始化列表里面对基类的私有成员进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	nWings<span style="color:#f92672">=</span>wings;<span style="color:#75715e">//这里也可以同样在初始化列表中进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	FlyBug fb(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>	fb.PrintBug();
</span></span><span style="display:flex;"><span>	fb.nType<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	fb.nLegs<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;<span style="color:#75715e">//error，nLegs是私有成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>在创建派生类的对象时，需要调用基类的构造函数来初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。</strong></li>
<li>调用基类构造函数的两种方式
<ul>
<li>显示方式：在派生类的构造函数中，为基类的构造函数提供参数 。<code>derived::derived(arg_derived-list):base(arg_base-list)</code></li>
<li>隐式方式：在派生类的构造函数中，省略基类构造函数，派生类的构造函数则自动调用基类的默认构造函数。</li>
</ul>
</li>
<li><strong>派生类的析构函数被执行时，执行完派生类的析构函数后，会自动调用基类的析构函数。</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>		Base(<span style="color:#66d9ef">int</span> i)<span style="color:#f92672">:</span>n(i){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base &#34;</span> <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; constructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>Base(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base &#34;</span> <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; destructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Base{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		Derived(<span style="color:#66d9ef">int</span> i)<span style="color:#f92672">:</span>Base(i){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived constructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>Derived(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived destructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	Derived Obj(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出内容为</p>
<pre tabindex="0"><code>Base 3 constructed
Derived constructed
Derived destructed
Base 3 destructed
</code></pre><p><strong>封闭派生类对象的构造函数执行顺序</strong></p>
<ol>
<li>先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员；</li>
<li>在执行成员对象类的构造函数，用以初始化派生类对象中的成员对象；</li>
<li>最后执行派生类自己的构造函数。</li>
</ol>
<p><strong>封闭派生类对象的析构函数执行顺序</strong></p>
<ol>
<li>先执行派生类自己的析构函数；</li>
<li>再依次执行各成员对象类的析构函数；</li>
<li>最后执行基类的析构函数。</li>
</ol>
<p>析构函数的调用顺序与构造函数的调用顺序相反。</p>
<h2 id="5public-继承的赋值兼容规则">5.<code>public</code> 继承的赋值兼容规则</h2>
<h3 id="公有继承的赋值兼容规则">公有继承的赋值兼容规则</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">base</span>{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">derived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> base{};<span style="color:#75715e">//实际上还可以写protected、private
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>							<span style="color:#75715e">//当写public时称为公有继承
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>base b;
</span></span><span style="display:flex;"><span>derived d;
</span></span></code></pre></div><ol>
<li>派生类对象可以赋值给基类对象 <code>b=d;</code>(反过来写 <code>d=b;</code> 是不行的)；</li>
<li>派生类对象可以初始化基类引用 `base&amp; br=d;</li>
<li>派生类对象的地址可以赋值给基类指针 <code>base* pb=&amp;d;</code></li>
</ol>
<p><strong>需要注意的是，如果派生方式是 <code>private</code> 或 <code>protected</code>，则上述三条不可行。</strong></p>
<h3 id="直接基类与间接基类">直接基类与间接基类</h3>
<p>假定有类 A 派生类 B，类 B 派生类 C，类 C 派生类 D，……</p>
<ul>
<li>类 A 是类 B 的直接基类</li>
<li>类 B 是类 C 的直接基类，类 A 是类 C 的间接基类</li>
<li>类 C 是类 D 的直接基类，类 A、B 是类 D 的间接基类</li>
</ul>
<p>在声明派生类时，<strong>只需要</strong>列出它的直接基类</p>
<ul>
<li>派生类沿着类的层次自动向上继承它的间接基类</li>
<li>派生类的成员包括
<ul>
<li>派生类自己定义的成员</li>
<li>直接基类中的所有成员</li>
<li>所有间接基类的全部成员</li>
</ul>
</li>
</ul>
<p>下面是一个多层派生的例子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>		Base(<span style="color:#66d9ef">int</span> i)<span style="color:#f92672">:</span>n(i){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base &#34;</span> <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; constructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>Base(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base &#34;</span> <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; destructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Base{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		Derived(<span style="color:#66d9ef">int</span> i)<span style="color:#f92672">:</span>Base(i){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived constructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>Derived(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived destructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MoreDerived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Derived{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		MoreDerived()<span style="color:#f92672">:</span>Derived(<span style="color:#ae81ff">4</span>){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MoreDerived constructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">~</span>MoreDerived(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MoreDerived destructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	MoreDerived Obj;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出内容为</p>
<pre tabindex="0"><code>Base 4 constructed
Derived constructed
MoreDerived constructed
MoreDerived destructed
Derived destructed
Base 4 destructed
</code></pre>
    </div>
    
    <div class="post-copyright">
      <div class="copyright-info">
        <p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p>
        <p>本文链接：<a href="https://kibrac.github.io/posts/c&#43;&#43;5/">https://kibrac.github.io/posts/c&#43;&#43;5/</a></p>
      </div>
    </div>
    
    
    <div class="post-tags">
      
      <a href="/tags/c&#43;&#43;/" class="tag">#C&#43;&#43;</a>
      
    </div>
    
    
    <div class="post-navigation">
      
      <a class="prev-post" href="https://kibrac.github.io/posts/c&#43;&#43;4/">&larr; 面向对象的程序设计学习笔记 4</a>
      
      
      
      <a class="next-post" href="https://kibrac.github.io/posts/c&#43;&#43;6/">面向对象的程序设计学习笔记 6 &rarr;</a>
      
    </div>
    
    
  </article>
  

</div>

    </main>
    
    <footer class="site-footer">
      <div class="footer-container">
  <div class="footer-content">
    <div class="footer-info">
      <p class="copyright">&copy; 2025 Kibrac&#39;s Blog</p>
      
      
    </div>
    
    
  </div>
  
  <div class="footer-bottom">
    <div class="footer-links">
      
      
      <span class="footer-separator">|</span>
      <span>使用 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> 构建</span>
      <span class="footer-separator">|</span>
      <span>主题 <a href="#" rel="noopener noreferrer">PointFive</a></span>
    </div>
</div>
    </footer>
  </div>
  
  
  <script src="https://kibrac.github.io/js/main.js"></script>
  <script src="https://kibrac.github.io/js/code-block.js"></script>
  
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError: false
      });
    });
  </script>
  
  
  
  
</body>
</html>